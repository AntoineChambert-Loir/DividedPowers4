/- Copyright 2022 ACL & MIdFF
! This file was ported from Lean 3 source module divided_powers.dp_algebra.misc
-/
import Mathbin.Algebra.RingQuot
import Mathbin.Algebra.TrivSqZeroExt
import Mathbin.Algebra.Algebra.Operations
import Mathbin.Data.MvPolynomial.Supported
import Mathbin.Data.MvPolynomial.CommRing
import Oneshot.WeightedHomogeneous

-- import algebra.free_algebra
-- import linear_algebra.multilinear.basic
-- import linear_algebra.multilinear.basic
-- import ring_theory.graded_algebra.basic
-- import ring_theory.graded_algebra.basic
-- import ring_theory.tensor_product
-- import ring_theory.tensor_product
-- import data.rel
-- import data.rel
-- import data.nat.order.basic
-- import data.nat.order.basic
-- import algebra.order.monoid.canonical.defs
-- import algebra.order.monoid.canonical.defs
-- Modified version of PR #17855
-- Modified version of PR #17855
-- import ..graded_ring_quot -- Quotients of graded rings
-- import ..graded_ring_quot -- Quotients of graded rings
-- import ..graded_module_quot
-- import ..graded_module_quot
noncomputable section

open Finset MvPolynomial RingQuot DirectSum Ideal Ideal.Quotient

theorem Ideal.pow_eq_bot {R : Type _} [CommSemiring R] [NoZeroDivisors R] {I : Ideal R} {n : ‚Ñï}
    (hn : n ‚â† 0) : I ^ n = ‚ä• ‚Üî I = ‚ä• :=
  by
  induction' n with n ih
  ¬∑ exfalso; exact hn (Eq.refl _)
  ¬∑ by_cases hn0 : n = 0
    ¬∑ rw [hn0, pow_one]
    ¬∑ rw [pow_succ, mul_eq_bot, ih hn0, or_self_iff]
#align ideal.pow_eq_bot Ideal.pow_eq_bot

namespace MvPolynomial

variable {R S œÉ : Type _} [CommSemiring R] [CommSemiring S]

@[simp]
theorem eval‚ÇÇHom.smul (f : R ‚Üí+* S) (g : œÉ ‚Üí S) (r : R) (P : MvPolynomial œÉ R) :
    eval‚ÇÇHom f g (r ‚Ä¢ P) = f r ‚Ä¢ eval‚ÇÇHom f g P := by
  simp only [smul_eq_C_mul, coe_eval‚ÇÇ_hom, eval‚ÇÇ_mul, eval‚ÇÇ_C, Algebra.id.smul_eq_mul]
#align mv_polynomial.eval‚ÇÇ_hom.smul MvPolynomial.eval‚ÇÇHom.smul

variable [Algebra R S]

variable (R)

/-- `mv_polynomial.eval‚ÇÇ (algebra_map R S) g` as an `R`-algebra homomorphism. -/
def eval‚ÇÇAlgHom (g : œÉ ‚Üí S) : MvPolynomial œÉ R ‚Üí‚Çê[R] S :=
  { eval‚ÇÇHom (algebraMap R S) g with
    commutes' := fun r => by rw [RingHom.toFun_eq_coe, coe_eval‚ÇÇ_hom, algebra_map_eq, eval‚ÇÇ_C] }
#align mv_polynomial.eval‚ÇÇ_alg_hom MvPolynomial.eval‚ÇÇAlgHom

variable {R}

theorem eval‚ÇÇAlgHom_apply (g : œÉ ‚Üí S) (P : MvPolynomial œÉ R) :
    eval‚ÇÇAlgHom R g P = eval‚ÇÇHom (algebraMap R S) g P :=
  rfl
#align mv_polynomial.eval‚ÇÇ_alg_hom_apply MvPolynomial.eval‚ÇÇAlgHom_apply

@[simp]
theorem coe_eval‚ÇÇAlgHom (g : œÉ ‚Üí S) : ‚áë(eval‚ÇÇAlgHom R g) = eval‚ÇÇ (algebraMap R S) g :=
  rfl
#align mv_polynomial.coe_eval‚ÇÇ_alg_hom MvPolynomial.coe_eval‚ÇÇAlgHom

@[simp]
theorem eval‚ÇÇAlgHom_X' (g : œÉ ‚Üí S) (i : œÉ) : eval‚ÇÇAlgHom R g (X i : MvPolynomial œÉ R) = g i :=
  eval‚ÇÇ_X (algebraMap R S) g i
#align mv_polynomial.eval‚ÇÇ_alg_hom_X' MvPolynomial.eval‚ÇÇAlgHom_X'

end MvPolynomial

section IdealsAndRel

theorem quotient_mk_eq_ofRel {A : Type _} [CommRing A] {r : A ‚Üí A ‚Üí Prop} {a b : A} (h : r a b) :
    mk (ofRel r) a = mk (ofRel r) b :=
  by
  suffices hinj : Function.Injective (RingQuot.ringQuotEquivIdealQuotient r).invFun
  ¬∑ apply hinj; exact mk_ring_hom_rel h
  exact
    function.injective_iff_has_left_inverse.mpr
      ‚ü®(ring_quot_equiv_ideal_quotient r).toFun, (ring_quot_equiv_ideal_quotient r).right_inv‚ü©
#align quotient_mk_eq_of_rel quotient_mk_eq_ofRel

namespace Ideal

theorem quotient_mk_eq_ringQuot_apply (R : Type _) [CommRing R] {A : Type _} [CommRing A]
    [Algebra R A] (r : A ‚Üí A ‚Üí Prop) (a : A) :
    mk (ofRel r) a = ringQuotToIdealQuotient r (mkAlgHom R r a) := by
  rw [‚Üê ring_quot_to_ideal_quotient_apply r a, ‚Üê mk_alg_hom_coe R r] <;> rfl
#align ideal.quotient_mk_eq_ring_quot_apply Ideal.quotient_mk_eq_ringQuot_apply

namespace Quotient

variable {R S : Type _} [CommRing R] [CommRing S]

theorem rel_le_ker (I : Ideal R) {r : R ‚Üí R ‚Üí Prop} (hr : I = ofRel r) (f : R ‚Üí+* S)
    (hf : ‚àÄ {a b : R}, r a b ‚Üí f a = f b) : I ‚â§ f.ker :=
  by
  rw [hr, of_rel, Submodule.span_le]
  rintro x ‚ü®a, b, hx, hab‚ü©
  rw [eq_sub_iff_add_eq.mpr hab, SetLike.mem_coe, RingHom.mem_ker, map_sub, sub_eq_zero, hf hx]
#align ideal.quotient.rel_le_ker Ideal.Quotient.rel_le_ker

/-- Given a binary relation `r` on `R` and a ring homomorphism `f : R ‚Üí+* S` that is constant on
  each equivalent class of `r`, lift `f` to the quotient by the ideal generated by `r`. -/
def liftRel (I : Ideal R) {r : R ‚Üí R ‚Üí Prop} (hr : I = ofRel r) (f : R ‚Üí+* S)
    (hf : ‚àÄ a b : R, r a b ‚Üí f a = f b) : R ‚ß∏ I ‚Üí+* S :=
  lift I f (rel_le_ker I hr f hf)
#align ideal.quotient.lift_rel Ideal.Quotient.liftRel

end Quotient

end Ideal

end IdealsAndRel

namespace TrivSqZeroExt

variable (R M : Type _) [CommSemiring R] [AddCommMonoid M] [Module R M] [Module R·µê·µí·µñ M]
  [IsCentralScalar R M]

def kerIdeal : Ideal (TrivSqZeroExt R M) :=
  RingHom.ker (fstHom R R M)
#align triv_sq_zero_ext.ker_ideal TrivSqZeroExt.kerIdeal

theorem mem_kerIdeal_iff_inr (x : TrivSqZeroExt R M) : x ‚àà kerIdeal R M ‚Üî x = inr x.snd :=
  by
  obtain ‚ü®r, m‚ü© := x
  simp only [ker_ideal, RingHom.mem_ker, fst_hom_apply, fst_mk]
  exact ‚ü®fun hr => by rw [hr]; rfl, fun hrm => by rw [‚Üê fst_mk r m, hrm, fst_inr]‚ü©
#align triv_sq_zero_ext.mem_ker_ideal_iff_inr TrivSqZeroExt.mem_kerIdeal_iff_inr

theorem mem_kerIdeal_iff_exists (x : TrivSqZeroExt R M) : x ‚àà kerIdeal R M ‚Üî ‚àÉ m : M, x = inr m :=
  by rw [mem_ker_ideal_iff_inr] <;> exact ‚ü®fun h => ‚ü®x.snd, h‚ü©, fun ‚ü®m, hm‚ü© => by rw [hm]; rfl‚ü©
#align triv_sq_zero_ext.mem_ker_ideal_iff_exists TrivSqZeroExt.mem_kerIdeal_iff_exists

theorem square_zero : kerIdeal R M ^ 2 = 0 :=
  by
  simp only [pow_two, zero_eq_bot, eq_bot_iff, mul_le, mem_ker_ideal_iff_inr]
  rintro x hx y hy
  rw [hx, hy, mem_bot, inr_mul_inr]
#align triv_sq_zero_ext.square_zero TrivSqZeroExt.square_zero

end TrivSqZeroExt

open Ideal Ideal.Quotient TrivSqZeroExt

section GradedAlgebra

variable {R : Type _} [CommRing R]

variable {A : Type _} [CommRing A] [Algebra R A]

variable {Œπ : Type _} [CanonicallyOrderedAddMonoid Œπ]

variable (ùíú : Œπ ‚Üí Submodule R A)

theorem grade_zero_coe_smul (r : R) (x : ùíú 0) : (‚Üë(r ‚Ä¢ x) : A) = r ‚Ä¢ x :=
  rfl
#align grade_zero_coe_smul grade_zero_coe_smul

variable [DecidableEq Œπ] [GradedAlgebra ùíú]

instance : One ‚Ü•(ùíú 0) :=
  ‚ü®‚ü®1, (@GradedRing.to_gradedMonoid Œπ A (Submodule R A) _ _ _ _ _ ùíú _).one_mem‚ü©‚ü©

instance : Mul ‚Ü•(ùíú 0) :=
  ‚ü®fun x y => ‚ü®x * y, by convert SetLike.mul_mem_graded x.2 y.2 <;> rw [add_zero]‚ü©‚ü©

@[simp]
theorem grade_zero_coe_mul (x y : ùíú 0) : (‚Üë(x * y) : A) = x * y :=
  rfl
#align grade_zero_coe_mul grade_zero_coe_mul

@[simp]
theorem grade_zero_val_mul (x y : ùíú 0) : (x * y).val = x.val * y.val :=
  rfl
#align grade_zero_val_mul grade_zero_val_mul

@[simp]
theorem grade_zero_coe_one : (‚Üë(1 : ùíú 0) : A) = 1 :=
  rfl
#align grade_zero_coe_one grade_zero_coe_one

theorem one_mem : (1 : A) ‚àà ùíú 0 :=
  SetLike.one_mem_graded ùíú
#align one_mem one_mem

example : AddCommMonoid (ùíú 0) :=
  inferInstance

example : Neg (ùíú 0) :=
  AddSubgroupClass.neg

instance gradeZeroCommRing : CommRing ‚Ü•(ùíú 0) :=
  { (inferInstance : AddCommGroup (ùíú 0)) with
    add := (¬∑ + ¬∑)
    zero := 0
    neg := Neg.neg
    one := 1
    mul := (¬∑ * ¬∑)
    mul_assoc := fun x y z => by ext <;> simp only [grade_zero_coe_mul, mul_assoc]
    one_mul := fun x => by ext <;> rw [grade_zero_coe_mul, grade_zero_coe_one, one_mul]
    mul_one := fun x => by ext <;> rw [grade_zero_coe_mul, grade_zero_coe_one, mul_one]
    left_distrib := fun x y z => by
      ext <;> simp only [Submodule.coe_add, grade_zero_coe_mul, left_distrib]
    right_distrib := fun x y z => by
      ext <;> simp only [Submodule.coe_add, grade_zero_coe_mul, right_distrib]
    mul_comm := fun x y => by ext <;> simp only [grade_zero_coe_mul, mul_comm] }
#align grade_zero_comm_ring gradeZeroCommRing

instance gradeZeroAlgebra : Algebra R ‚Ü•(ùíú 0) :=
  Algebra.ofModule'
    (fun r x => by
      ext <;>
        simp only [grade_zero_coe_mul, grade_zero_coe_smul, grade_zero_coe_one,
          Algebra.smul_mul_assoc, one_mul])
    fun r x => by
    ext <;>
      simp only [grade_zero_coe_mul, grade_zero_coe_smul, grade_zero_coe_one, Algebra.mul_smul_comm,
        mul_one]
#align grade_zero_algebra gradeZeroAlgebra

/-- The projection from `A` to the degree `i` component `ùíú i`, as an `R`-linear map. -/
def proj (i : Œπ) : A ‚Üí‚Çó[R] ùíú i where
  toFun a := decompose ùíú a i
  map_add' a b := by rw [decompose_add, add_apply]
  map_smul' r a := by rw [decompose_smul, DFinsupp.coe_smul, Pi.smul_apply, RingHom.id_apply]
#align proj proj

@[simps]
def projZeroRingHom' : A ‚Üí+* ùíú 0 where
  toFun a := proj ùíú 0 a
  map_one' := by
    ext
    simp only [proj, LinearMap.coe_mk, decompose_of_mem_same ùíú (one_mem ùíú), grade_zero_coe_one]
  map_zero' := by simp only [proj, decompose_zero, LinearMap.coe_mk, zero_apply]
  map_add' _ _ := by simp only [proj, decompose_add, LinearMap.coe_mk, add_apply]
  map_mul' x y := by
    ext
    simp only [proj, LinearMap.coe_mk, SetLike.coe_eq_coe, grade_zero_coe_mul, ‚Üê
      GradedRing.projZeroRingHom_apply ùíú, ‚Üê _root_.map_mul]
#align proj_zero_ring_hom' projZeroRingHom'

end GradedAlgebra

section GradedAlgebra

variable {R : Type _} [CommRing R]

def GalgHom.IsHomogeneous {Œπ : Type _} {A : Type _} [CommRing A] [Algebra R A]
    (ùíú : Œπ ‚Üí Submodule R A) {B : Type _} [CommRing B] [Algebra R B] (‚Ñ¨ : Œπ ‚Üí Submodule R B)
    (f : A ‚Üí‚Çê[R] B) :=
  ‚àÄ i a, a ‚àà ùíú i ‚Üí f a ‚àà ‚Ñ¨ i
#align galg_hom.is_homogeneous GalgHom.IsHomogeneous

theorem Finsupp.prod.mem_grade {Œ∫ A : Type _} [AddCommMonoid Œ∫] [DecidableEq Œ∫] [CommRing A]
    [Algebra R A] (ùíú : Œ∫ ‚Üí Submodule R A) [GradedAlgebra ùíú] {œÉ : Type _} (c : œÉ ‚Üí‚ÇÄ ‚Ñï) (f : œÉ ‚Üí A)
    (d : œÉ ‚Üí Œ∫) (hc : ‚àÄ s ‚àà c.support, f s ‚àà ùíú (d s)) :
    (c.Prod fun s e => f s ^ e) ‚àà ùíú (c.Sum fun s e => e ‚Ä¢ d s) := by
  classical
  rw [Finsupp.prod, Finsupp.sum]
  let p : Finset œÉ ‚Üí Prop := fun s =>
    s ‚äÜ c.support ‚Üí (s.Prod fun i => f i ^ c i) ‚àà ùíú (s.Sum fun i => c i ‚Ä¢ d i)
  apply @Finset.induction_on œÉ p _ c.support
  ¬∑ exact imp_intro (SetLike.one_mem_graded ùíú)
  ¬∑ intro a s ha hs hs'
    rw [Finset.prod_insert ha, Finset.sum_insert ha]
    exact
      SetLike.mul_mem_graded (SetLike.pow_mem_graded _ (hc a (hs' (mem_insert_self a s))))
        (hs (subset_trans (subset_insert a s) hs'))
  ¬∑ exact subset_rfl
#align finsupp.prod.mem_grade Finsupp.prod.mem_grade

def GalgHom.IsHomogeneous' {Œπ Œ∫ : Type _}
    -- [add_comm_monoid Œπ] [decidable_eq Œπ]
    (A : Type _)
    [CommRing A] [Algebra R A] (ùíú : Œπ ‚Üí Submodule R A)
    -- [graded_algebra ùíú]
    (B : Type _)
    [CommRing B] [Algebra R B] (‚Ñ¨ : Œ∫ ‚Üí Submodule R B)
    -- [graded_algebra ‚Ñ¨]
    (œÜ : Œπ ‚Üí Œ∫)
    (f : A ‚Üí‚Çê[R] B) :=
  ‚àÄ i a, a ‚àà ùíú i ‚Üí f a ‚àà ‚Ñ¨ (œÜ i)
#align galg_hom.is_homogeneous' GalgHom.IsHomogeneous'

theorem foo (œÉ : Type _) {Œπ Œ∫ : Type _} [AddCommMonoid Œπ]
    --[decidable_eq Œπ]
    [AddCommMonoid Œ∫]
    [DecidableEq Œ∫] (A : Type _) [CommRing A] [Algebra R A] (ùíú : Œ∫ ‚Üí Submodule R A)
    [GradedAlgebra ùíú] (w : œÉ ‚Üí Œπ) (œÜ : Œπ ‚Üí+ Œ∫) (f : œÉ ‚Üí A) (h : ‚àÄ s : œÉ, f s ‚àà ùíú (œÜ (w s))) :
    GalgHom.IsHomogeneous'-- _ R _ Œπ Œ∫ (mv_polynomial œÉ R) _
      _
      (weightedHomogeneousSubmodule R w) _ ùíú œÜ (MvPolynomial.aeval f) :=
  by
  intro i p hp
  simp only [mem_weighted_homogeneous_submodule, is_weighted_homogeneous] at hp 
  rw [p.as_sum]
  rw [map_sum]
  apply Submodule.sum_mem
  intro c hc
  rw [aeval_monomial]
  rw [‚Üê smul_eq_mul]
  rw [algebraMap_smul]
  apply Submodule.smul_mem
  convert Finsupp.prod.mem_grade ùíú c f _ fun s _ => h s
  rw [‚Üê hp (mem_support_iff.mp hc)]
  simp only [weighted_degree']
  rw [Finsupp.total]
  simp only [Finsupp.coe_lsum, Finsupp.sum]
  rw [map_sum]
  simp only [LinearMap.coe_smulRight, LinearMap.id_coe, id.def, Algebra.id.smul_eq_mul]
  apply congr_arg‚ÇÇ _ rfl
  ext s
  rw [AddMonoidHom.map_nsmul]
#align foo foo

end GradedAlgebra

theorem MvPolynomial.vars_x_subset {R : Type _} {œÉ : Type _} (n : œÉ) [CommSemiring R] :
    (X n : MvPolynomial œÉ R).vars ‚äÜ {n} := by
  classical
  intro u
  rw [X, mem_vars, mem_singleton]
  rintro ‚ü®c, hc, hc'‚ü©
  by_contra h'
  rw [mem_support_iff, coeff_monomial, Ne.def] at hc 
  by_cases h : Finsupp.single n 1 = c
  ¬∑ rw [‚Üê h, Finsupp.mem_support_iff, Ne.def, Finsupp.single_apply] at hc' 
    apply hc'; rw [if_neg (Ne.symm h')]
  ¬∑ apply hc; rw [if_neg h]
#align mv_polynomial.vars_X_subset MvPolynomial.vars_x_subset

section

open MvPolynomial

variable {R M : Type _} [CommRing R]

instance : GradedAlgebra (weightedHomogeneousSubmodule R (Prod.fst : ‚Ñï √ó M ‚Üí ‚Ñï)) :=
  weightedGradedAlgebra _ _

variable {R}

def degree (v : ‚Ñï √ó M ‚Üí‚ÇÄ ‚Ñï) : ‚Ñï :=
  finsum fun x => v x * x.1
#align degree degree

def IsHomogeneousOfDegree (p : MvPolynomial (‚Ñï √ó M) R) (n : ‚Ñï) : Prop :=
  ‚àÄ v ‚àà p.support, degree v = n
#align is_homogeneous_of_degree IsHomogeneousOfDegree

variable (R)

theorem variable_mem_supported (nm : ‚Ñï √ó M) (hn : 0 < nm.1) :
    X nm ‚àà supported R {nm : ‚Ñï √ó M | 0 < nm.1} :=
  by
  rw [mem_supported]
  refine' Set.Subset.trans (finset.coe_subset.mpr (vars_X_subset nm)) _
  rw [coe_singleton, Set.singleton_subset_iff, Set.mem_setOf_eq]
  exact hn
#align variable_mem_supported variable_mem_supported

def toSupported : MvPolynomial (‚Ñï √ó M) R ‚Üí‚Çê[R] supported R {nm : ‚Ñï √ó M | 0 < nm.1} :=
  aeval fun nm : ‚Ñï √ó M =>
    dite (0 < nm.1) (fun h => ‚ü®X nm, variable_mem_supported R nm h‚ü©) fun h => 1
#align to_supported toSupported

theorem toSupported_is_homogeneous :
    GalgHom.IsHomogeneous' (MvPolynomial (‚Ñï √ó M) R)
      (weightedHomogeneousSubmodule R (Prod.fst : ‚Ñï √ó M ‚Üí ‚Ñï)) (MvPolynomial (‚Ñï √ó M) R)
      (weightedHomogeneousSubmodule R Prod.fst) (id : ‚Ñï ‚Üí ‚Ñï)
      ((Subalgebra.val _).comp (toSupported R)) :=
  by
  classical
  have h :=
    @foo R _ (‚Ñï √ó M) ‚Ñï ‚Ñï _ _ _ (MvPolynomial (‚Ñï √ó M) R) _ _
      (weighted_homogeneous_submodule R Prod.fst) _ Prod.fst (AddMonoidHom.id ‚Ñï)
      ((Subalgebra.val _).toFun.comp fun nm : ‚Ñï √ó M =>
        dite (0 < nm.1) (fun h => ‚ü®X nm, variable_mem_supported R nm h‚ü©) fun h => 1)
      _
  have heq :
    aeval
        ((supported R {nm : ‚Ñï √ó M | 0 < nm.fst}).val.toFun ‚àò fun nm : ‚Ñï √ó M =>
          dite (0 < nm.fst) (fun h : 0 < nm.fst => ‚ü®X nm, _‚ü©) fun h : ¬¨0 < nm.fst => 1) =
      (supported R {nm : ‚Ñï √ó M | 0 < nm.fst}).val.comp (toSupported R) :=
    by
    apply MvPolynomial.algHom_ext
    intro nm
    simp only [toSupported, AlgHom.toFun_eq_coe, Function.comp_apply, AlgHom.coe_comp, aeval_X]
  rw [HEq] at h 
  exact h
  ¬∑ intro nm
    simp only [mem_weighted_homogeneous_submodule, AlgHom.toFun_eq_coe, Subalgebra.coe_val,
      Function.comp_apply, AddMonoidHom.id_apply]
    split_ifs
    ¬∑ exact is_weighted_homogeneous_X R _ _
    ¬∑ simp only [not_lt, le_zero_iff] at h 
      rw [h, algebraMap.coe_one]
      exact is_weighted_homogeneous_one R _
#align to_supported_is_homogeneous toSupported_is_homogeneous

variable (M)

-- TODO: generalize
theorem eq_finsupp_single_of_degree_one {d : ‚Ñï √ó M ‚Üí‚ÇÄ ‚Ñï} (hd : (weightedDegree' Prod.fst) d = 1)
    (hsupp : ‚àÄ nm : ‚Ñï √ó M, nm ‚àà d.support ‚Üí 0 < nm.fst) : ‚àÉ m : M, Finsupp.single (1, m) 1 = d := by
  classical
  rw [weighted_degree', Finsupp.total_apply, Finsupp.sum] at hd 
  have hnm : ‚àÉ nm : ‚Ñï √ó M, d nm ‚Ä¢ nm.fst = 1 :=
    by
    by_contra h0
    rw [not_exists] at h0 
    have hd0 : (d.support.sum fun a : ‚Ñï √ó M => d a ‚Ä¢ a.fst) = 0 :=
      by
      rw [Finset.sum_eq_zero]
      intro nm hnm
      rw [‚Üê Nat.lt_one_iff]
      apply lt_of_le_of_ne _ (h0 nm)
      rw [‚Üê hd]
      exact Finset.single_le_sum (fun ab hab => zero_le _) hnm
    rw [hd0] at hd 
    exact zero_ne_one hd
  obtain ‚ü®nm, hnm‚ü© := hnm
  rw [‚Üê hnm] at hd 
  simp only [Algebra.id.smul_eq_mul, mul_eq_one] at hnm 
  use nm.snd
  ext ab
  rw [Finsupp.single_apply]
  split_ifs with hab <;> rw [‚Üê hnm.2, eq_comm, Prod.mk.eta] at hab 
  ¬∑ rw [hab, hnm.1]
  ¬∑ rw [eq_comm]
    by_contra hab'
    have hne0 : d ab * ab.fst ‚â† 0 :=
      mul_ne_zero hab' (ne_of_gt (hsupp ab (finsupp.mem_support_iff.mpr hab')))
    have hnm_mem : nm ‚àà d.support := by rw [Finsupp.mem_support_iff, hnm.1]; exact one_ne_zero
    simp only [Finset.sum_eq_sum_diff_singleton_add hnm_mem, add_left_eq_self,
      Algebra.id.smul_eq_mul, sum_eq_zero_iff, mem_sdiff,
      Finsupp.mem_support_iff,--ne.def,
      mem_singleton] at
      hd 
    exact hne0 (hd ab ‚ü®hab', hab‚ü©)
#align eq_finsupp_single_of_degree_one eq_finsupp_single_of_degree_one

end

