/- Copyright 2022 ACL & MIdFF
! This file was ported from Lean 3 source module divided_powers.dp_algebra.misc
-/

import DividedPowers.ForMathlib.WeightedHomogeneous

import Mathlib.Algebra.RingQuot
import Mathlib.Algebra.TrivSqZeroExt
import Mathlib.Algebra.Algebra.Operations
import Mathlib.Data.MvPolynomial.Supported
import Mathlib.Data.MvPolynomial.CommRing

-- import algebra.free_algebra
-- import linear_algebra.multilinear.basic
-- import linear_algebra.multilinear.basic
-- import ring_theory.graded_algebra.basic
-- import ring_theory.graded_algebra.basic
-- import ring_theory.tensor_product
-- import ring_theory.tensor_product
-- import data.rel
-- import data.rel
-- import data.nat.order.basic
-- import data.nat.order.basic
-- import algebra.order.monoid.canonical.defs
-- import algebra.order.monoid.canonical.defs
-- Modified version of PR #17855
-- Modified version of PR #17855
-- import ..graded_ring_quot -- Quotients of graded rings
-- import ..graded_ring_quot -- Quotients of graded rings
-- import ..graded_module_quot
-- import ..graded_module_quot
noncomputable section

open Finset MvPolynomial RingQuot DirectSum Ideal Ideal.Quotient

theorem Ideal.pow_eq_bot {R : Type _} [CommSemiring R] [NoZeroDivisors R] {I : Ideal R} {n : ‚Ñï}
    (hn : n ‚â† 0) : I ^ n = ‚ä• ‚Üî I = ‚ä• :=
  by
  induction' n with n ih
  ¬∑ exfalso; exact hn (Eq.refl _)
  ¬∑ by_cases hn0 : n = 0
    ¬∑ rw [hn0, pow_one]
    ¬∑ rw [pow_succ, mul_eq_bot, ih hn0, or_self_iff]
#align ideal.pow_eq_bot Ideal.pow_eq_bot

namespace MvPolynomial

variable {R S œÉ : Type _} [CommSemiring R] [CommSemiring S]

@[simp]
theorem eval‚ÇÇHom.smul (f : R ‚Üí+* S) (g : œÉ ‚Üí S) (r : R) (P : MvPolynomial œÉ R) :
    eval‚ÇÇHom f g (r ‚Ä¢ P) = f r ‚Ä¢ eval‚ÇÇHom f g P := by
  simp only [smul_eq_C_mul, coe_eval‚ÇÇHom, eval‚ÇÇ_mul, eval‚ÇÇ_C, Algebra.id.smul_eq_mul]
#align mv_polynomial.eval‚ÇÇ_hom.smul MvPolynomial.eval‚ÇÇHom.smul

variable [Algebra R S]

variable (R)

/-- `mv_polynomial.eval‚ÇÇ (algebra_map R S) g` as an `R`-algebra homomorphism. -/
def eval‚ÇÇAlgHom (g : œÉ ‚Üí S) : MvPolynomial œÉ R ‚Üí‚Çê[R] S :=
  { eval‚ÇÇHom (algebraMap R S) g with
    commutes' := fun r => by rw [RingHom.toFun_eq_coe, coe_eval‚ÇÇHom, algebraMap_eq, eval‚ÇÇ_C] }
#align mv_polynomial.eval‚ÇÇ_alg_hom MvPolynomial.eval‚ÇÇAlgHom

variable {R}

theorem eval‚ÇÇAlgHom_apply (g : œÉ ‚Üí S) (P : MvPolynomial œÉ R) :
    eval‚ÇÇAlgHom R g P = eval‚ÇÇHom (algebraMap R S) g P :=
  rfl
#align mv_polynomial.eval‚ÇÇ_alg_hom_apply MvPolynomial.eval‚ÇÇAlgHom_apply

@[simp]
theorem coe_eval‚ÇÇAlgHom (g : œÉ ‚Üí S) : ‚áë(eval‚ÇÇAlgHom R g) = eval‚ÇÇ (algebraMap R S) g :=
  rfl
#align mv_polynomial.coe_eval‚ÇÇ_alg_hom MvPolynomial.coe_eval‚ÇÇAlgHom

@[simp]
theorem eval‚ÇÇAlgHom_X' (g : œÉ ‚Üí S) (i : œÉ) : eval‚ÇÇAlgHom R g (X i : MvPolynomial œÉ R) = g i :=
  eval‚ÇÇ_X (algebraMap R S) g i
set_option linter.uppercaseLean3 false
#align mv_polynomial.eval‚ÇÇ_alg_hom_X' MvPolynomial.eval‚ÇÇAlgHom_X'
set_option linter.uppercaseLean3 true

end MvPolynomial

section IdealsAndRel

theorem quotient_mk_eq_ofRel {A : Type _} [CommRing A] {r : A ‚Üí A ‚Üí Prop} {a b : A} (h : r a b) :
    mk (ofRel r) a = mk (ofRel r) b :=
  by
  suffices hinj : Function.Injective (RingQuot.ringQuotEquivIdealQuotient r).invFun
  ¬∑ apply hinj; exact mkRingHom_rel h
  rw [Function.injective_iff_hasLeftInverse]
  exact ‚ü®(ringQuotEquivIdealQuotient r).toFun, (ringQuotEquivIdealQuotient r).right_inv‚ü©
#align quotient_mk_eq_of_rel quotient_mk_eq_ofRel

namespace Ideal

theorem quotient_mk_eq_ringQuot_apply (R : Type _) [CommRing R] {A : Type _} [CommRing A]
    [Algebra R A] (r : A ‚Üí A ‚Üí Prop) (a : A) :
    mk (ofRel r) a = ringQuotToIdealQuotient r (mkAlgHom R r a) := by
  rw [‚Üê ringQuotToIdealQuotient_apply r a, ‚Üê mkAlgHom_coe R r]
  rfl
#align ideal.quotient_mk_eq_ring_quot_apply Ideal.quotient_mk_eq_ringQuot_apply

namespace Quotient

variable {R S : Type _} [CommRing R] [CommRing S]

theorem rel_le_ker (I : Ideal R) {r : R ‚Üí R ‚Üí Prop} (hr : I = ofRel r) (f : R ‚Üí+* S)
    (hf : ‚àÄ {a b : R}, r a b ‚Üí f a = f b) : I ‚â§ RingHom.ker f :=
  by
  rw [hr, ofRel, Submodule.span_le]
  rintro x ‚ü®a, b, hx, hab‚ü©
  rw [eq_sub_iff_add_eq.mpr hab, SetLike.mem_coe, RingHom.mem_ker, map_sub, sub_eq_zero, hf hx]
#align ideal.quotient.rel_le_ker Ideal.Quotient.rel_le_ker

/-- Given a binary relation `r` on `R` and a ring homomorphism `f : R ‚Üí+* S` that is constant on
  each equivalent class of `r`, lift `f` to the quotient by the ideal generated by `r`. -/
def liftRel (I : Ideal R) {r : R ‚Üí R ‚Üí Prop} (hr : I = ofRel r) (f : R ‚Üí+* S)
    (hf : ‚àÄ {a b : R}, r a b ‚Üí f a = f b) : R ‚ß∏ I ‚Üí+* S := 
  lift I f (rel_le_ker I hr f hf)
  
#align ideal.quotient.lift_rel Ideal.Quotient.liftRel

end Quotient

end Ideal

end IdealsAndRel

namespace TrivSqZeroExt

variable (R M : Type _) [CommSemiring R] [AddCommMonoid M] [Module R M] [Module R·µê·µí·µñ M]
  [IsCentralScalar R M]

def kerIdeal : Ideal (TrivSqZeroExt R M) :=
  RingHom.ker (fstHom R R M)
#align triv_sq_zero_ext.ker_ideal TrivSqZeroExt.kerIdeal

theorem mem_kerIdeal_iff_inr (x : TrivSqZeroExt R M) : x ‚àà kerIdeal R M ‚Üî x = inr x.snd :=
  by
  obtain ‚ü®r, m‚ü© := x
  simp only [kerIdeal, RingHom.mem_ker, fstHom_apply, fst_mk]
  exact ‚ü®fun hr => by rw [hr]; rfl, fun hrm => by rw [‚Üê fst_mk r m, hrm, fst_inr]‚ü©
#align triv_sq_zero_ext.mem_ker_ideal_iff_inr TrivSqZeroExt.mem_kerIdeal_iff_inr

theorem mem_kerIdeal_iff_exists (x : TrivSqZeroExt R M) : x ‚àà kerIdeal R M ‚Üî ‚àÉ m : M, x = inr m := by 
  rw [mem_kerIdeal_iff_inr]
  exact ‚ü®fun h => ‚ü®x.snd, h‚ü©, fun ‚ü®m, hm‚ü© => by rw [hm]; rfl‚ü©
#align triv_sq_zero_ext.mem_ker_ideal_iff_exists TrivSqZeroExt.mem_kerIdeal_iff_exists

theorem sqZero : kerIdeal R M ^ 2 = (‚ä• : Ideal (TrivSqZeroExt R M)) :=
  by
  simp only [pow_two, zero_eq_bot, eq_bot_iff, mul_le, mem_kerIdeal_iff_inr]
  rintro x hx y hy
  rw [hx, hy, mem_bot, inr_mul_inr]
#align triv_sq_zero_ext.square_zero TrivSqZeroExt.sqZero

end TrivSqZeroExt

open Ideal Ideal.Quotient TrivSqZeroExt

section GradedAlgebra

variable {R : Type _} [CommRing R]

variable {A : Type _} [CommRing A] [Algebra R A]

variable {Œπ : Type _} [CanonicallyOrderedAddMonoid Œπ]

variable (ùíú : Œπ ‚Üí Submodule R A)

theorem gradeZero_coe_smul (r : R) (x : ùíú 0) : (‚Üë(r ‚Ä¢ x) : A) = r ‚Ä¢ x :=
  rfl
#align grade_zero_coe_smul gradeZero_coe_smul

variable [DecidableEq Œπ] [GradedAlgebra ùíú]

instance : One (ùíú 0) where
  one : ùíú 0 := ‚ü®1, SetLike.one_mem_graded ùíú‚ü©

instance : Mul (ùíú 0) where
  mul := fun x y => ‚ü®x * y, by 
    convert SetLike.mul_mem_graded x.2 y.2
    rw [add_zero]‚ü©

@[simp]
theorem gradeZero_coe_mul (x y : ùíú 0) : (‚Üë(x * y) : A) = x * y :=
  rfl
#align grade_zero_coe_mul gradeZero_coe_mul

@[simp]
theorem gradeZero_val_mul (x y : ùíú 0) : (x * y).val = x.val * y.val :=
  rfl
#align grade_zero_val_mul gradeZero_val_mul

@[simp]
theorem gradeZero_coe_zero : (‚Üë(0 : ùíú 0) : A) = 0 :=
  rfl
#align grade_zero_coe_zero gradeZero_coe_zero

@[simp]
theorem gradeZero_coe_one : (‚Üë(1 : ùíú 0) : A) = 1 :=
  rfl
#align grade_zero_coe_one gradeZero_coe_one

theorem one_mem : (1 : A) ‚àà ùíú 0 :=
  SetLike.one_mem_graded ùíú
#align one_mem one_mem

example : AddCommMonoid (ùíú 0) :=
  inferInstance

example : Neg (ùíú 0) :=
  AddSubgroupClass.neg

instance gradeZeroCommRing : CommRing (ùíú 0) :=
  { (inferInstance : AddCommGroup (ùíú 0)) with
    add := (¬∑ + ¬∑)
    zero := 0
    neg := Neg.neg
    one := 1
    mul := (¬∑ * ¬∑)
    zero_mul := fun x => by
      ext
      rw [gradeZero_coe_mul, gradeZero_coe_zero, zero_mul]
    mul_zero := fun x => by
      ext
      rw [gradeZero_coe_mul, gradeZero_coe_zero, mul_zero]
    mul_assoc := fun x y z => by 
      ext
      simp only [gradeZero_coe_mul, mul_assoc]
    one_mul := fun x => by 
      ext
      rw [gradeZero_coe_mul, gradeZero_coe_one, one_mul]
    mul_one := fun x => by 
      ext
      rw [gradeZero_coe_mul, gradeZero_coe_one, mul_one]
    left_distrib := fun x y z => by
      ext
      simp only [Submodule.coe_add, gradeZero_coe_mul, left_distrib]
    right_distrib := fun x y z => by
      ext
      simp only [Submodule.coe_add, gradeZero_coe_mul, right_distrib]
    mul_comm := fun x y => by 
      ext
      simp only [gradeZero_coe_mul, mul_comm]
     }
#align grade_zero_comm_ring gradeZeroCommRing

instance gradeZeroAlgebra : Algebra R (ùíú 0) :=
  Algebra.ofModule'
    (fun r x => by
      ext
      simp only [gradeZero_coe_mul, gradeZero_coe_smul, SetLike.val_smul,
        gradeZero_coe_one, Algebra.smul_mul_assoc, one_mul])
    (fun r x => by
      ext
      simp only [gradeZero_coe_mul, gradeZero_coe_smul, SetLike.val_smul,
        gradeZero_coe_one, Algebra.mul_smul_comm, mul_one])
#align grade_zero_algebra gradeZeroAlgebra

/-- The projection from `A` to the degree `i` component `ùíú i`, as an `R`-linear map. -/
def proj (i : Œπ) : A ‚Üí‚Çó[R] ùíú i where
  toFun a := decompose ùíú a i
  map_add' a b := by simp only [decompose_add, add_apply]
  map_smul' r a := by 
    simp only [decompose_smul, RingHom.id_apply]
    rfl
#align proj proj

@[simps]
def projZeroRingHom' : A ‚Üí+* ùíú 0 where
  toFun a := proj ùíú 0 a
  map_one' := by
    ext
    simp only [proj, LinearMap.coe_mk, AddHom.coe_mk,
     decompose_of_mem_same ùíú (one_mem ùíú), gradeZero_coe_one]
  map_zero' := by simp only [proj, decompose_zero, LinearMap.coe_mk, AddHom.coe_mk, zero_apply]
  map_add' _ _ := by simp only [proj, decompose_add, LinearMap.coe_mk, AddHom.coe_mk, add_apply]
  map_mul' x y := by
    ext
    simp only [proj, LinearMap.coe_mk, AddHom.coe_mk, SetLike.coe_eq_coe,
      gradeZero_coe_mul, ‚Üê GradedRing.projZeroRingHom_apply ùíú, ‚Üê _root_.map_mul]
#align proj_zero_ring_hom' projZeroRingHom'

end GradedAlgebra

section GradedAlgebra

variable {R : Type _} [CommRing R]

def GalgHom.IsHomogeneous {Œπ : Type _} {A : Type _} [CommRing A] [Algebra R A]
    (ùíú : Œπ ‚Üí Submodule R A) {B : Type _} [CommRing B] [Algebra R B] (‚Ñ¨ : Œπ ‚Üí Submodule R B)
    (f : A ‚Üí‚Çê[R] B) :=
  ‚àÄ i a, a ‚àà ùíú i ‚Üí f a ‚àà ‚Ñ¨ i
#align galg_hom.is_homogeneous GalgHom.IsHomogeneous

theorem Finsupp.prod.mem_grade {Œ∫ A : Type _} [AddCommMonoid Œ∫] [DecidableEq Œ∫] [CommRing A]
    [Algebra R A] (ùíú : Œ∫ ‚Üí Submodule R A) [GradedAlgebra ùíú] {œÉ : Type _} (c : œÉ ‚Üí‚ÇÄ ‚Ñï) (f : œÉ ‚Üí A)
    (d : œÉ ‚Üí Œ∫) (hc : ‚àÄ s ‚àà c.support, f s ‚àà ùíú (d s)) :
    (c.prod fun s e => f s ^ e) ‚àà ùíú (c.sum fun s e => e ‚Ä¢ d s) := by
  classical
  rw [Finsupp.prod, Finsupp.sum]
  let p : Finset œÉ ‚Üí Prop := fun s =>
    s ‚äÜ c.support ‚Üí (s.prod fun i => f i ^ c i) ‚àà ùíú (s.sum fun i => c i ‚Ä¢ d i)
  apply @Finset.induction_on œÉ p _ c.support
  ¬∑ exact imp_intro (SetLike.one_mem_graded ùíú)
  ¬∑ intro a s ha hs hs'
    rw [Finset.prod_insert ha, Finset.sum_insert ha]
    exact
      SetLike.mul_mem_graded (SetLike.pow_mem_graded _ (hc a (hs' (mem_insert_self a s))))
        (hs (subset_trans (subset_insert a s) hs'))
  ¬∑ exact subset_rfl
#align finsupp.prod.mem_grade Finsupp.prod.mem_grade

def GalgHom.isHomogeneous' {Œπ Œ∫ : Type _}
    -- [add_comm_monoid Œπ] [decidable_eq Œπ]
    (A : Type _)
    [CommRing A] [Algebra R A] (ùíú : Œπ ‚Üí Submodule R A)
    -- [graded_algebra ùíú]
    (B : Type _)
    [CommRing B] [Algebra R B] (‚Ñ¨ : Œ∫ ‚Üí Submodule R B)
    -- [graded_algebra ‚Ñ¨]
    (œÜ : Œπ ‚Üí Œ∫)
    (f : A ‚Üí‚Çê[R] B) :=
  ‚àÄ i a, a ‚àà ùíú i ‚Üí f a ‚àà ‚Ñ¨ (œÜ i)
#align galg_hom.is_homogeneous' GalgHom.isHomogeneous'

/-- The evaluation of a weighted homogeneous polynomial at
  elements of adequate grades is homogeneous -/
theorem GalgHom.isHomogeneous'_aeval (œÉ : Type _) {Œπ Œ∫ : Type _} [AddCommMonoid Œπ]
    [AddCommMonoid Œ∫] [DecidableEq Œ∫] 
    (A : Type _) [CommRing A] [Algebra R A] 
    (ùíú : Œ∫ ‚Üí Submodule R A) [GradedAlgebra ùíú] 
    (w : œÉ ‚Üí Œπ) (œÜ : Œπ ‚Üí+ Œ∫) (f : œÉ ‚Üí A) (h : ‚àÄ s : œÉ, f s ‚àà ùíú (œÜ (w s))) :
    GalgHom.isHomogeneous' (MvPolynomial œÉ R)
      (weightedHomogeneousSubmodule R w) A ùíú œÜ (MvPolynomial.aeval f) := by
  intro i p hp
  simp only [mem_weightedHomogeneousSubmodule, IsWeightedHomogeneous] at hp 
  rw [p.as_sum, map_sum]
  apply Submodule.sum_mem
  intro c hc
  rw [aeval_monomial, ‚Üê smul_eq_mul, algebraMap_smul]
  apply Submodule.smul_mem
  convert Finsupp.prod.mem_grade ùíú c f _ fun s _ => h s
  rw [‚Üê hp (mem_support_iff.mp hc), MvPolynomial.weightedDegree'_apply]
  rw [Finsupp.sum, map_sum, Finsupp.sum_of_support_subset _ le_rfl]
  apply Finset.sum_congr rfl
  . intro x _ ; simp only [map_nsmul]
  . intro s _ ; simp only [zero_smul]
#align foo GalgHom.isHomogeneous'_aeval

end GradedAlgebra

theorem MvPolynomial.vars_X_subset {R : Type _} {œÉ : Type _} (n : œÉ) [CommSemiring R] :
    (X n : MvPolynomial œÉ R).vars ‚äÜ {n} := by
  classical
  intro u
  rw [X, mem_vars, mem_singleton]
  rintro ‚ü®c, hc, hc'‚ü©
  by_contra h'
  rw [mem_support_iff, coeff_monomial, Ne.def] at hc 
  by_cases h : Finsupp.single n 1 = c
  ¬∑ rw [‚Üê h, Finsupp.mem_support_iff, Ne.def, Finsupp.single_apply] at hc' 
    apply hc'; rw [if_neg (Ne.symm h')]
  ¬∑ apply hc; rw [if_neg h]
set_option linter.uppercaseLean3 false
#align mv_polynomial.vars_X_subset MvPolynomial.vars_X_subset
set_option linter.uppercaseLean3 true

section

open MvPolynomial

variable {R M : Type _} [CommRing R]  

instance [DecidableEq R] [DecidableEq M] : 
  GradedAlgebra (weightedHomogeneousSubmodule R (Prod.fst : ‚Ñï √ó M ‚Üí ‚Ñï)) :=
  weightedGradedAlgebra _ _

def degree (v : ‚Ñï √ó M ‚Üí‚ÇÄ ‚Ñï) : ‚Ñï :=
  finsum fun x => v x * x.1
#align degree degree

def IsHomogeneousOfDegree (p : MvPolynomial (‚Ñï √ó M) R) (n : ‚Ñï) : Prop :=
  ‚àÄ v ‚àà p.support, degree v = n
#align is_homogeneous_of_degree IsHomogeneousOfDegree

variable (R)

theorem variable_mem_supported (nm : ‚Ñï √ó M) (hn : 0 < nm.1) :
    X nm ‚àà supported R {nm : ‚Ñï √ó M | 0 < nm.1} :=
  by
  rw [mem_supported]
  refine' Set.Subset.trans (Finset.coe_subset.mpr (vars_X_subset nm)) _
  rw [coe_singleton, Set.singleton_subset_iff, Set.mem_setOf_eq]
  exact hn
#align variable_mem_supported variable_mem_supported

def toSupported : MvPolynomial (‚Ñï √ó M) R ‚Üí‚Çê[R] supported R {nm : ‚Ñï √ó M | 0 < nm.1} :=
  aeval fun nm : ‚Ñï √ó M =>
    dite (0 < nm.1) (fun h => ‚ü®X nm, variable_mem_supported R nm h‚ü©) fun _ => 1
#align to_supported toSupported

theorem toSupported_isHomogeneous' [DecidableEq M] [DecidableEq R] :
    GalgHom.isHomogeneous' (MvPolynomial (‚Ñï √ó M) R)
      (weightedHomogeneousSubmodule R (Prod.fst : ‚Ñï √ó M ‚Üí ‚Ñï)) (MvPolynomial (‚Ñï √ó M) R)
      (weightedHomogeneousSubmodule R Prod.fst) (id : ‚Ñï ‚Üí ‚Ñï)
      ((Subalgebra.val _).comp (toSupported R)) :=
  by
  have heq : aeval
    ((supported R {nm : ‚Ñï √ó M | 0 < nm.fst}).val.toFun ‚àò 
        fun nm : ‚Ñï √ó M =>
          if h : 0 < nm.fst
          then ‚ü®X nm, variable_mem_supported R nm h‚ü©
          else 1) =
      (supported R {nm : ‚Ñï √ó M | 0 < nm.fst}).val.comp (toSupported R) :=
    by
    apply MvPolynomial.algHom_ext
    intro nm
    simp only [toSupported, AlgHom.toFun_eq_coe, Function.comp_apply, AlgHom.coe_comp, aeval_X]
  rw [‚Üê heq]
  apply GalgHom.isHomogeneous'_aeval (‚Ñï √ó M) (MvPolynomial (‚Ñï √ó M) R)
    (weightedHomogeneousSubmodule R Prod.fst) Prod.fst (AddMonoidHom.id ‚Ñï)
  ¬∑ intro nm
    simp only [mem_weightedHomogeneousSubmodule, AlgHom.toFun_eq_coe, Subalgebra.coe_val,
      Function.comp_apply, AddMonoidHom.id_apply]
    split_ifs with h
    ¬∑ apply isWeightedHomogeneous_X
    ¬∑ simp only [not_lt, le_zero_iff] at h 
      rw [h, OneMemClass.coe_one]
      apply isWeightedHomogeneous_one
#align to_supported_is_homogeneous toSupported_isHomogeneous'

variable (M)

-- TODO: generalize
theorem eq_finsupp_single_of_degree_one [DecidableEq M]
    {d : ‚Ñï √ó M ‚Üí‚ÇÄ ‚Ñï} (hd : (weightedDegree' Prod.fst) d = 1)
    (hsupp : ‚àÄ nm ‚àà d.support, 0 < nm.fst) : 
  ‚àÉ m : M, Finsupp.single (1, m) 1 = d := by
  rw [weightedDegree'_apply, Finsupp.sum] at hd 
  have hnm : ‚àÉ nm : ‚Ñï √ó M, d nm ‚Ä¢ nm.fst = 1 := by
    by_contra h0
    rw [not_exists] at h0 
    have hd0 : (d.support.sum fun a : ‚Ñï √ó M => d a ‚Ä¢ a.fst) = 0 := by
      rw [Finset.sum_eq_zero]
      intro nm hnm
      rw [‚Üê Nat.lt_one_iff]
      apply lt_of_le_of_ne _ (h0 nm)
      rw [‚Üê hd]
      exact Finset.single_le_sum (fun x _ => zero_le (d x ‚Ä¢ x.fst)) hnm
    rw [hd0] at hd 
    exact zero_ne_one hd
  obtain ‚ü®nm, hnm‚ü© := hnm
  rw [‚Üê hnm] at hd 
  simp only [Algebra.id.smul_eq_mul, mul_eq_one] at hnm 
  use nm.snd
  ext ab
  rw [Finsupp.single_apply]
  split_ifs with hab <;> rw [‚Üê hnm.2, eq_comm, Prod.mk.eta] at hab 
  ¬∑ rw [hab, hnm.1]
  ¬∑ rw [eq_comm]
    by_contra hab'
    have hne0 : d ab * ab.fst ‚â† 0 :=
      mul_ne_zero hab' (ne_of_gt (hsupp ab (Finsupp.mem_support_iff.mpr hab')))
    have hnm_mem : nm ‚àà d.support := by rw [Finsupp.mem_support_iff, hnm.1]; exact one_ne_zero
    simp only [Finset.sum_eq_sum_diff_singleton_add hnm_mem, add_left_eq_self,
      Algebra.id.smul_eq_mul, sum_eq_zero_iff, mem_sdiff,
      Finsupp.mem_support_iff, mem_singleton] at hd 
    exact hne0 (hd ab ‚ü®hab', hab‚ü©)
#align eq_finsupp_single_of_degree_one eq_finsupp_single_of_degree_one

end

