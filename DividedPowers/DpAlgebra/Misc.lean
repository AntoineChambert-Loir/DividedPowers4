/- Copyright 2022 ACL & MIdFF
! This file was ported from Lean 3 source module divided_powers.dp_algebra.misc
-/

import DividedPowers.ForMathlib.WeightedHomogeneous

import Mathlib.Algebra.RingQuot
import Mathlib.Algebra.TrivSqZeroExt
import Mathlib.Algebra.Algebra.Operations
import Mathlib.Data.MvPolynomial.Supported
import Mathlib.Data.MvPolynomial.CommRing

-- import algebra.free_algebra
-- import linear_algebra.multilinear.basic
-- import linear_algebra.multilinear.basic
-- import ring_theory.graded_algebra.basic
-- import ring_theory.graded_algebra.basic
-- import ring_theory.tensor_product
-- import ring_theory.tensor_product
-- import data.rel
-- import data.rel
-- import data.nat.order.basic
-- import data.nat.order.basic
-- import algebra.order.monoid.canonical.defs
-- import algebra.order.monoid.canonical.defs
-- Modified version of PR #17855
-- Modified version of PR #17855
-- import ..graded_ring_quot -- Quotients of graded rings
-- import ..graded_ring_quot -- Quotients of graded rings
-- import ..graded_module_quot
-- import ..graded_module_quot
noncomputable section

open Finset MvPolynomial RingQuot DirectSum Ideal Ideal.Quotient

theorem Ideal.pow_eq_bot {R : Type _} [CommSemiring R] [NoZeroDivisors R] {I : Ideal R} {n : ℕ}
    (hn : n ≠ 0) : I ^ n = ⊥ ↔ I = ⊥ :=
  by
  induction' n with n ih
  · exfalso; exact hn (Eq.refl _)
  · by_cases hn0 : n = 0
    · rw [hn0, pow_one]
    · rw [pow_succ, mul_eq_bot, ih hn0, or_self_iff]
#align ideal.pow_eq_bot Ideal.pow_eq_bot

namespace MvPolynomial

variable {R S σ : Type _} [CommSemiring R] [CommSemiring S]

@[simp]
theorem eval₂Hom.smul (f : R →+* S) (g : σ → S) (r : R) (P : MvPolynomial σ R) :
    eval₂Hom f g (r • P) = f r • eval₂Hom f g P := by
  simp only [smul_eq_C_mul, coe_eval₂Hom, eval₂_mul, eval₂_C, Algebra.id.smul_eq_mul]
#align mv_polynomial.eval₂_hom.smul MvPolynomial.eval₂Hom.smul

variable [Algebra R S]

variable (R)

/-- `mv_polynomial.eval₂ (algebra_map R S) g` as an `R`-algebra homomorphism. -/
def eval₂AlgHom (g : σ → S) : MvPolynomial σ R →ₐ[R] S :=
  { eval₂Hom (algebraMap R S) g with
    commutes' := fun r => by rw [RingHom.toFun_eq_coe, coe_eval₂Hom, algebraMap_eq, eval₂_C] }
#align mv_polynomial.eval₂_alg_hom MvPolynomial.eval₂AlgHom

variable {R}

theorem eval₂AlgHom_apply (g : σ → S) (P : MvPolynomial σ R) :
    eval₂AlgHom R g P = eval₂Hom (algebraMap R S) g P :=
  rfl
#align mv_polynomial.eval₂_alg_hom_apply MvPolynomial.eval₂AlgHom_apply

@[simp]
theorem coe_eval₂AlgHom (g : σ → S) : ⇑(eval₂AlgHom R g) = eval₂ (algebraMap R S) g :=
  rfl
#align mv_polynomial.coe_eval₂_alg_hom MvPolynomial.coe_eval₂AlgHom

@[simp]
theorem eval₂AlgHom_X' (g : σ → S) (i : σ) : eval₂AlgHom R g (X i : MvPolynomial σ R) = g i :=
  eval₂_X (algebraMap R S) g i
set_option linter.uppercaseLean3 false
#align mv_polynomial.eval₂_alg_hom_X' MvPolynomial.eval₂AlgHom_X'
set_option linter.uppercaseLean3 true

end MvPolynomial

section IdealsAndRel

theorem quotient_mk_eq_ofRel {A : Type _} [CommRing A] {r : A → A → Prop} {a b : A} (h : r a b) :
    mk (ofRel r) a = mk (ofRel r) b :=
  by
  suffices hinj : Function.Injective (RingQuot.ringQuotEquivIdealQuotient r).invFun
  · apply hinj; exact mkRingHom_rel h
  rw [Function.injective_iff_hasLeftInverse]
  exact ⟨(ringQuotEquivIdealQuotient r).toFun, (ringQuotEquivIdealQuotient r).right_inv⟩
#align quotient_mk_eq_of_rel quotient_mk_eq_ofRel

namespace Ideal

theorem quotient_mk_eq_ringQuot_apply (R : Type _) [CommRing R] {A : Type _} [CommRing A]
    [Algebra R A] (r : A → A → Prop) (a : A) :
    mk (ofRel r) a = ringQuotToIdealQuotient r (mkAlgHom R r a) := by
  rw [← ringQuotToIdealQuotient_apply r a, ← mkAlgHom_coe R r]
  rfl
#align ideal.quotient_mk_eq_ring_quot_apply Ideal.quotient_mk_eq_ringQuot_apply

namespace Quotient

variable {R S : Type _} [CommRing R] [CommRing S]

theorem rel_le_ker (I : Ideal R) {r : R → R → Prop} (hr : I = ofRel r) (f : R →+* S)
    (hf : ∀ {a b : R}, r a b → f a = f b) : I ≤ RingHom.ker f :=
  by
  rw [hr, ofRel, Submodule.span_le]
  rintro x ⟨a, b, hx, hab⟩
  rw [eq_sub_iff_add_eq.mpr hab, SetLike.mem_coe, RingHom.mem_ker, map_sub, sub_eq_zero, hf hx]
#align ideal.quotient.rel_le_ker Ideal.Quotient.rel_le_ker

/-- Given a binary relation `r` on `R` and a ring homomorphism `f : R →+* S` that is constant on
  each equivalent class of `r`, lift `f` to the quotient by the ideal generated by `r`. -/
def liftRel (I : Ideal R) {r : R → R → Prop} (hr : I = ofRel r) (f : R →+* S)
    (hf : ∀ {a b : R}, r a b → f a = f b) : R ⧸ I →+* S := 
  lift I f (rel_le_ker I hr f hf)
  
#align ideal.quotient.lift_rel Ideal.Quotient.liftRel

end Quotient

end Ideal

end IdealsAndRel

namespace TrivSqZeroExt

variable (R M : Type _) [CommSemiring R] [AddCommMonoid M] [Module R M] [Module Rᵐᵒᵖ M]
  [IsCentralScalar R M]

def kerIdeal : Ideal (TrivSqZeroExt R M) :=
  RingHom.ker (fstHom R R M)
#align triv_sq_zero_ext.ker_ideal TrivSqZeroExt.kerIdeal

theorem mem_kerIdeal_iff_inr (x : TrivSqZeroExt R M) : x ∈ kerIdeal R M ↔ x = inr x.snd :=
  by
  obtain ⟨r, m⟩ := x
  simp only [kerIdeal, RingHom.mem_ker, fstHom_apply, fst_mk]
  exact ⟨fun hr => by rw [hr]; rfl, fun hrm => by rw [← fst_mk r m, hrm, fst_inr]⟩
#align triv_sq_zero_ext.mem_ker_ideal_iff_inr TrivSqZeroExt.mem_kerIdeal_iff_inr

theorem mem_kerIdeal_iff_exists (x : TrivSqZeroExt R M) : x ∈ kerIdeal R M ↔ ∃ m : M, x = inr m := by 
  rw [mem_kerIdeal_iff_inr]
  exact ⟨fun h => ⟨x.snd, h⟩, fun ⟨m, hm⟩ => by rw [hm]; rfl⟩
#align triv_sq_zero_ext.mem_ker_ideal_iff_exists TrivSqZeroExt.mem_kerIdeal_iff_exists

theorem sqZero : kerIdeal R M ^ 2 = (⊥ : Ideal (TrivSqZeroExt R M)) :=
  by
  simp only [pow_two, zero_eq_bot, eq_bot_iff, mul_le, mem_kerIdeal_iff_inr]
  rintro x hx y hy
  rw [hx, hy, mem_bot, inr_mul_inr]
#align triv_sq_zero_ext.square_zero TrivSqZeroExt.sqZero

end TrivSqZeroExt

open Ideal Ideal.Quotient TrivSqZeroExt

section GradedAlgebra

variable {R : Type _} [CommRing R]

variable {A : Type _} [CommRing A] [Algebra R A]

variable {ι : Type _} [CanonicallyOrderedAddMonoid ι]

variable (𝒜 : ι → Submodule R A)

theorem gradeZero_coe_smul (r : R) (x : 𝒜 0) : (↑(r • x) : A) = r • x :=
  rfl
#align grade_zero_coe_smul gradeZero_coe_smul

variable [DecidableEq ι] [GradedAlgebra 𝒜]

instance : One (𝒜 0) where
  one : 𝒜 0 := ⟨1, SetLike.one_mem_graded 𝒜⟩

instance : Mul (𝒜 0) where
  mul := fun x y => ⟨x * y, by 
    convert SetLike.mul_mem_graded x.2 y.2
    rw [add_zero]⟩

@[simp]
theorem gradeZero_coe_mul (x y : 𝒜 0) : (↑(x * y) : A) = x * y :=
  rfl
#align grade_zero_coe_mul gradeZero_coe_mul

@[simp]
theorem gradeZero_val_mul (x y : 𝒜 0) : (x * y).val = x.val * y.val :=
  rfl
#align grade_zero_val_mul gradeZero_val_mul

@[simp]
theorem gradeZero_coe_zero : (↑(0 : 𝒜 0) : A) = 0 :=
  rfl
#align grade_zero_coe_zero gradeZero_coe_zero

@[simp]
theorem gradeZero_coe_one : (↑(1 : 𝒜 0) : A) = 1 :=
  rfl
#align grade_zero_coe_one gradeZero_coe_one

theorem one_mem : (1 : A) ∈ 𝒜 0 :=
  SetLike.one_mem_graded 𝒜
#align one_mem one_mem

example : AddCommMonoid (𝒜 0) :=
  inferInstance

example : Neg (𝒜 0) :=
  AddSubgroupClass.neg

instance gradeZeroCommRing : CommRing (𝒜 0) :=
  { (inferInstance : AddCommGroup (𝒜 0)) with
    add := (· + ·)
    zero := 0
    neg := Neg.neg
    one := 1
    mul := (· * ·)
    zero_mul := fun x => by
      ext
      rw [gradeZero_coe_mul, gradeZero_coe_zero, zero_mul]
    mul_zero := fun x => by
      ext
      rw [gradeZero_coe_mul, gradeZero_coe_zero, mul_zero]
    mul_assoc := fun x y z => by 
      ext
      simp only [gradeZero_coe_mul, mul_assoc]
    one_mul := fun x => by 
      ext
      rw [gradeZero_coe_mul, gradeZero_coe_one, one_mul]
    mul_one := fun x => by 
      ext
      rw [gradeZero_coe_mul, gradeZero_coe_one, mul_one]
    left_distrib := fun x y z => by
      ext
      simp only [Submodule.coe_add, gradeZero_coe_mul, left_distrib]
    right_distrib := fun x y z => by
      ext
      simp only [Submodule.coe_add, gradeZero_coe_mul, right_distrib]
    mul_comm := fun x y => by 
      ext
      simp only [gradeZero_coe_mul, mul_comm]
     }
#align grade_zero_comm_ring gradeZeroCommRing

instance gradeZeroAlgebra : Algebra R (𝒜 0) :=
  Algebra.ofModule'
    (fun r x => by
      ext
      simp only [gradeZero_coe_mul, gradeZero_coe_smul, SetLike.val_smul,
        gradeZero_coe_one, Algebra.smul_mul_assoc, one_mul])
    (fun r x => by
      ext
      simp only [gradeZero_coe_mul, gradeZero_coe_smul, SetLike.val_smul,
        gradeZero_coe_one, Algebra.mul_smul_comm, mul_one])
#align grade_zero_algebra gradeZeroAlgebra

/-- The projection from `A` to the degree `i` component `𝒜 i`, as an `R`-linear map. -/
def proj (i : ι) : A →ₗ[R] 𝒜 i where
  toFun a := decompose 𝒜 a i
  map_add' a b := by simp only [decompose_add, add_apply]
  map_smul' r a := by 
    simp only [decompose_smul, RingHom.id_apply]
    rfl
#align proj proj

@[simps]
def projZeroRingHom' : A →+* 𝒜 0 where
  toFun a := proj 𝒜 0 a
  map_one' := by
    ext
    simp only [proj, LinearMap.coe_mk, AddHom.coe_mk,
     decompose_of_mem_same 𝒜 (one_mem 𝒜), gradeZero_coe_one]
  map_zero' := by simp only [proj, decompose_zero, LinearMap.coe_mk, AddHom.coe_mk, zero_apply]
  map_add' _ _ := by simp only [proj, decompose_add, LinearMap.coe_mk, AddHom.coe_mk, add_apply]
  map_mul' x y := by
    ext
    simp only [proj, LinearMap.coe_mk, AddHom.coe_mk, SetLike.coe_eq_coe,
      gradeZero_coe_mul, ← GradedRing.projZeroRingHom_apply 𝒜, ← _root_.map_mul]
#align proj_zero_ring_hom' projZeroRingHom'

end GradedAlgebra

section GradedAlgebra

variable {R : Type _} [CommRing R]

def GalgHom.IsHomogeneous {ι : Type _} {A : Type _} [CommRing A] [Algebra R A]
    (𝒜 : ι → Submodule R A) {B : Type _} [CommRing B] [Algebra R B] (ℬ : ι → Submodule R B)
    (f : A →ₐ[R] B) :=
  ∀ i a, a ∈ 𝒜 i → f a ∈ ℬ i
#align galg_hom.is_homogeneous GalgHom.IsHomogeneous

theorem Finsupp.prod.mem_grade {κ A : Type _} [AddCommMonoid κ] [DecidableEq κ] [CommRing A]
    [Algebra R A] (𝒜 : κ → Submodule R A) [GradedAlgebra 𝒜] {σ : Type _} (c : σ →₀ ℕ) (f : σ → A)
    (d : σ → κ) (hc : ∀ s ∈ c.support, f s ∈ 𝒜 (d s)) :
    (c.prod fun s e => f s ^ e) ∈ 𝒜 (c.sum fun s e => e • d s) := by
  classical
  rw [Finsupp.prod, Finsupp.sum]
  let p : Finset σ → Prop := fun s =>
    s ⊆ c.support → (s.prod fun i => f i ^ c i) ∈ 𝒜 (s.sum fun i => c i • d i)
  apply @Finset.induction_on σ p _ c.support
  · exact imp_intro (SetLike.one_mem_graded 𝒜)
  · intro a s ha hs hs'
    rw [Finset.prod_insert ha, Finset.sum_insert ha]
    exact
      SetLike.mul_mem_graded (SetLike.pow_mem_graded _ (hc a (hs' (mem_insert_self a s))))
        (hs (subset_trans (subset_insert a s) hs'))
  · exact subset_rfl
#align finsupp.prod.mem_grade Finsupp.prod.mem_grade

def GalgHom.isHomogeneous' {ι κ : Type _}
    -- [add_comm_monoid ι] [decidable_eq ι]
    (A : Type _)
    [CommRing A] [Algebra R A] (𝒜 : ι → Submodule R A)
    -- [graded_algebra 𝒜]
    (B : Type _)
    [CommRing B] [Algebra R B] (ℬ : κ → Submodule R B)
    -- [graded_algebra ℬ]
    (φ : ι → κ)
    (f : A →ₐ[R] B) :=
  ∀ i a, a ∈ 𝒜 i → f a ∈ ℬ (φ i)
#align galg_hom.is_homogeneous' GalgHom.isHomogeneous'

/-- The evaluation of a weighted homogeneous polynomial at
  elements of adequate grades is homogeneous -/
theorem GalgHom.isHomogeneous'_aeval (σ : Type _) {ι κ : Type _} [AddCommMonoid ι]
    [AddCommMonoid κ] [DecidableEq κ] 
    (A : Type _) [CommRing A] [Algebra R A] 
    (𝒜 : κ → Submodule R A) [GradedAlgebra 𝒜] 
    (w : σ → ι) (φ : ι →+ κ) (f : σ → A) (h : ∀ s : σ, f s ∈ 𝒜 (φ (w s))) :
    GalgHom.isHomogeneous' (MvPolynomial σ R)
      (weightedHomogeneousSubmodule R w) A 𝒜 φ (MvPolynomial.aeval f) := by
  intro i p hp
  simp only [mem_weightedHomogeneousSubmodule, IsWeightedHomogeneous] at hp 
  rw [p.as_sum, map_sum]
  apply Submodule.sum_mem
  intro c hc
  rw [aeval_monomial, ← smul_eq_mul, algebraMap_smul]
  apply Submodule.smul_mem
  convert Finsupp.prod.mem_grade 𝒜 c f _ fun s _ => h s
  rw [← hp (mem_support_iff.mp hc), MvPolynomial.weightedDegree'_apply]
  rw [Finsupp.sum, map_sum, Finsupp.sum_of_support_subset _ le_rfl]
  apply Finset.sum_congr rfl
  . intro x _ ; simp only [map_nsmul]
  . intro s _ ; simp only [zero_smul]
#align foo GalgHom.isHomogeneous'_aeval

end GradedAlgebra

theorem MvPolynomial.vars_X_subset {R : Type _} {σ : Type _} (n : σ) [CommSemiring R] :
    (X n : MvPolynomial σ R).vars ⊆ {n} := by
  classical
  intro u
  rw [X, mem_vars, mem_singleton]
  rintro ⟨c, hc, hc'⟩
  by_contra h'
  rw [mem_support_iff, coeff_monomial, Ne.def] at hc 
  by_cases h : Finsupp.single n 1 = c
  · rw [← h, Finsupp.mem_support_iff, Ne.def, Finsupp.single_apply] at hc' 
    apply hc'; rw [if_neg (Ne.symm h')]
  · apply hc; rw [if_neg h]
set_option linter.uppercaseLean3 false
#align mv_polynomial.vars_X_subset MvPolynomial.vars_X_subset
set_option linter.uppercaseLean3 true

section

open MvPolynomial

variable {R M : Type _} [CommRing R]  

instance [DecidableEq R] [DecidableEq M] : 
  GradedAlgebra (weightedHomogeneousSubmodule R (Prod.fst : ℕ × M → ℕ)) :=
  weightedGradedAlgebra _ _

def degree (v : ℕ × M →₀ ℕ) : ℕ :=
  finsum fun x => v x * x.1
#align degree degree

def IsHomogeneousOfDegree (p : MvPolynomial (ℕ × M) R) (n : ℕ) : Prop :=
  ∀ v ∈ p.support, degree v = n
#align is_homogeneous_of_degree IsHomogeneousOfDegree

variable (R)

theorem variable_mem_supported (nm : ℕ × M) (hn : 0 < nm.1) :
    X nm ∈ supported R {nm : ℕ × M | 0 < nm.1} :=
  by
  rw [mem_supported]
  refine' Set.Subset.trans (Finset.coe_subset.mpr (vars_X_subset nm)) _
  rw [coe_singleton, Set.singleton_subset_iff, Set.mem_setOf_eq]
  exact hn
#align variable_mem_supported variable_mem_supported

def toSupported : MvPolynomial (ℕ × M) R →ₐ[R] supported R {nm : ℕ × M | 0 < nm.1} :=
  aeval fun nm : ℕ × M =>
    dite (0 < nm.1) (fun h => ⟨X nm, variable_mem_supported R nm h⟩) fun _ => 1
#align to_supported toSupported

theorem toSupported_isHomogeneous' [DecidableEq M] [DecidableEq R] :
    GalgHom.isHomogeneous' (MvPolynomial (ℕ × M) R)
      (weightedHomogeneousSubmodule R (Prod.fst : ℕ × M → ℕ)) (MvPolynomial (ℕ × M) R)
      (weightedHomogeneousSubmodule R Prod.fst) (id : ℕ → ℕ)
      ((Subalgebra.val _).comp (toSupported R)) :=
  by
  have heq : aeval
    ((supported R {nm : ℕ × M | 0 < nm.fst}).val.toFun ∘ 
        fun nm : ℕ × M =>
          if h : 0 < nm.fst
          then ⟨X nm, variable_mem_supported R nm h⟩
          else 1) =
      (supported R {nm : ℕ × M | 0 < nm.fst}).val.comp (toSupported R) :=
    by
    apply MvPolynomial.algHom_ext
    intro nm
    simp only [toSupported, AlgHom.toFun_eq_coe, Function.comp_apply, AlgHom.coe_comp, aeval_X]
  rw [← heq]
  apply GalgHom.isHomogeneous'_aeval (ℕ × M) (MvPolynomial (ℕ × M) R)
    (weightedHomogeneousSubmodule R Prod.fst) Prod.fst (AddMonoidHom.id ℕ)
  · intro nm
    simp only [mem_weightedHomogeneousSubmodule, AlgHom.toFun_eq_coe, Subalgebra.coe_val,
      Function.comp_apply, AddMonoidHom.id_apply]
    split_ifs with h
    · apply isWeightedHomogeneous_X
    · simp only [not_lt, le_zero_iff] at h 
      rw [h, OneMemClass.coe_one]
      apply isWeightedHomogeneous_one
#align to_supported_is_homogeneous toSupported_isHomogeneous'

variable (M)

-- TODO: generalize
theorem eq_finsupp_single_of_degree_one [DecidableEq M]
    {d : ℕ × M →₀ ℕ} (hd : (weightedDegree' Prod.fst) d = 1)
    (hsupp : ∀ nm ∈ d.support, 0 < nm.fst) : 
  ∃ m : M, Finsupp.single (1, m) 1 = d := by
  rw [weightedDegree'_apply, Finsupp.sum] at hd 
  have hnm : ∃ nm : ℕ × M, d nm • nm.fst = 1 := by
    by_contra h0
    rw [not_exists] at h0 
    have hd0 : (d.support.sum fun a : ℕ × M => d a • a.fst) = 0 := by
      rw [Finset.sum_eq_zero]
      intro nm hnm
      rw [← Nat.lt_one_iff]
      apply lt_of_le_of_ne _ (h0 nm)
      rw [← hd]
      exact Finset.single_le_sum (fun x _ => zero_le (d x • x.fst)) hnm
    rw [hd0] at hd 
    exact zero_ne_one hd
  obtain ⟨nm, hnm⟩ := hnm
  rw [← hnm] at hd 
  simp only [Algebra.id.smul_eq_mul, mul_eq_one] at hnm 
  use nm.snd
  ext ab
  rw [Finsupp.single_apply]
  split_ifs with hab <;> rw [← hnm.2, eq_comm, Prod.mk.eta] at hab 
  · rw [hab, hnm.1]
  · rw [eq_comm]
    by_contra hab'
    have hne0 : d ab * ab.fst ≠ 0 :=
      mul_ne_zero hab' (ne_of_gt (hsupp ab (Finsupp.mem_support_iff.mpr hab')))
    have hnm_mem : nm ∈ d.support := by rw [Finsupp.mem_support_iff, hnm.1]; exact one_ne_zero
    simp only [Finset.sum_eq_sum_diff_singleton_add hnm_mem, add_left_eq_self,
      Algebra.id.smul_eq_mul, sum_eq_zero_iff, mem_sdiff,
      Finsupp.mem_support_iff, mem_singleton] at hd 
    exact hne0 (hd ab ⟨hab', hab⟩)
#align eq_finsupp_single_of_degree_one eq_finsupp_single_of_degree_one

end

