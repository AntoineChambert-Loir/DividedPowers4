/- Copyright 2022 ACL & MIdFF
! This file was ported from Lean 3 source module divided_powers.dp_algebra.misc
-/
import Mathbin.Algebra.RingQuot
import Mathbin.Algebra.TrivSqZeroExt
import Mathbin.Algebra.Algebra.Operations
import Mathbin.Data.MvPolynomial.Supported
import Mathbin.Data.MvPolynomial.CommRing
import Oneshot.WeightedHomogeneous

-- import algebra.free_algebra
-- import linear_algebra.multilinear.basic
-- import linear_algebra.multilinear.basic
-- import ring_theory.graded_algebra.basic
-- import ring_theory.graded_algebra.basic
-- import ring_theory.tensor_product
-- import ring_theory.tensor_product
-- import data.rel
-- import data.rel
-- import data.nat.order.basic
-- import data.nat.order.basic
-- import algebra.order.monoid.canonical.defs
-- import algebra.order.monoid.canonical.defs
-- Modified version of PR #17855
-- Modified version of PR #17855
-- import ..graded_ring_quot -- Quotients of graded rings
-- import ..graded_ring_quot -- Quotients of graded rings
-- import ..graded_module_quot
-- import ..graded_module_quot
noncomputable section

open Finset MvPolynomial RingQuot DirectSum Ideal Ideal.Quotient

theorem Ideal.pow_eq_bot {R : Type _} [CommSemiring R] [NoZeroDivisors R] {I : Ideal R} {n : ℕ}
    (hn : n ≠ 0) : I ^ n = ⊥ ↔ I = ⊥ :=
  by
  induction' n with n ih
  · exfalso; exact hn (Eq.refl _)
  · by_cases hn0 : n = 0
    · rw [hn0, pow_one]
    · rw [pow_succ, mul_eq_bot, ih hn0, or_self_iff]
#align ideal.pow_eq_bot Ideal.pow_eq_bot

namespace MvPolynomial

variable {R S σ : Type _} [CommSemiring R] [CommSemiring S]

@[simp]
theorem eval₂Hom.smul (f : R →+* S) (g : σ → S) (r : R) (P : MvPolynomial σ R) :
    eval₂Hom f g (r • P) = f r • eval₂Hom f g P := by
  simp only [smul_eq_C_mul, coe_eval₂_hom, eval₂_mul, eval₂_C, Algebra.id.smul_eq_mul]
#align mv_polynomial.eval₂_hom.smul MvPolynomial.eval₂Hom.smul

variable [Algebra R S]

variable (R)

/-- `mv_polynomial.eval₂ (algebra_map R S) g` as an `R`-algebra homomorphism. -/
def eval₂AlgHom (g : σ → S) : MvPolynomial σ R →ₐ[R] S :=
  { eval₂Hom (algebraMap R S) g with
    commutes' := fun r => by rw [RingHom.toFun_eq_coe, coe_eval₂_hom, algebra_map_eq, eval₂_C] }
#align mv_polynomial.eval₂_alg_hom MvPolynomial.eval₂AlgHom

variable {R}

theorem eval₂AlgHom_apply (g : σ → S) (P : MvPolynomial σ R) :
    eval₂AlgHom R g P = eval₂Hom (algebraMap R S) g P :=
  rfl
#align mv_polynomial.eval₂_alg_hom_apply MvPolynomial.eval₂AlgHom_apply

@[simp]
theorem coe_eval₂AlgHom (g : σ → S) : ⇑(eval₂AlgHom R g) = eval₂ (algebraMap R S) g :=
  rfl
#align mv_polynomial.coe_eval₂_alg_hom MvPolynomial.coe_eval₂AlgHom

@[simp]
theorem eval₂AlgHom_X' (g : σ → S) (i : σ) : eval₂AlgHom R g (X i : MvPolynomial σ R) = g i :=
  eval₂_X (algebraMap R S) g i
#align mv_polynomial.eval₂_alg_hom_X' MvPolynomial.eval₂AlgHom_X'

end MvPolynomial

section IdealsAndRel

theorem quotient_mk_eq_ofRel {A : Type _} [CommRing A] {r : A → A → Prop} {a b : A} (h : r a b) :
    mk (ofRel r) a = mk (ofRel r) b :=
  by
  suffices hinj : Function.Injective (RingQuot.ringQuotEquivIdealQuotient r).invFun
  · apply hinj; exact mk_ring_hom_rel h
  exact
    function.injective_iff_has_left_inverse.mpr
      ⟨(ring_quot_equiv_ideal_quotient r).toFun, (ring_quot_equiv_ideal_quotient r).right_inv⟩
#align quotient_mk_eq_of_rel quotient_mk_eq_ofRel

namespace Ideal

theorem quotient_mk_eq_ringQuot_apply (R : Type _) [CommRing R] {A : Type _} [CommRing A]
    [Algebra R A] (r : A → A → Prop) (a : A) :
    mk (ofRel r) a = ringQuotToIdealQuotient r (mkAlgHom R r a) := by
  rw [← ring_quot_to_ideal_quotient_apply r a, ← mk_alg_hom_coe R r] <;> rfl
#align ideal.quotient_mk_eq_ring_quot_apply Ideal.quotient_mk_eq_ringQuot_apply

namespace Quotient

variable {R S : Type _} [CommRing R] [CommRing S]

theorem rel_le_ker (I : Ideal R) {r : R → R → Prop} (hr : I = ofRel r) (f : R →+* S)
    (hf : ∀ {a b : R}, r a b → f a = f b) : I ≤ f.ker :=
  by
  rw [hr, of_rel, Submodule.span_le]
  rintro x ⟨a, b, hx, hab⟩
  rw [eq_sub_iff_add_eq.mpr hab, SetLike.mem_coe, RingHom.mem_ker, map_sub, sub_eq_zero, hf hx]
#align ideal.quotient.rel_le_ker Ideal.Quotient.rel_le_ker

/-- Given a binary relation `r` on `R` and a ring homomorphism `f : R →+* S` that is constant on
  each equivalent class of `r`, lift `f` to the quotient by the ideal generated by `r`. -/
def liftRel (I : Ideal R) {r : R → R → Prop} (hr : I = ofRel r) (f : R →+* S)
    (hf : ∀ a b : R, r a b → f a = f b) : R ⧸ I →+* S :=
  lift I f (rel_le_ker I hr f hf)
#align ideal.quotient.lift_rel Ideal.Quotient.liftRel

end Quotient

end Ideal

end IdealsAndRel

namespace TrivSqZeroExt

variable (R M : Type _) [CommSemiring R] [AddCommMonoid M] [Module R M] [Module Rᵐᵒᵖ M]
  [IsCentralScalar R M]

def kerIdeal : Ideal (TrivSqZeroExt R M) :=
  RingHom.ker (fstHom R R M)
#align triv_sq_zero_ext.ker_ideal TrivSqZeroExt.kerIdeal

theorem mem_kerIdeal_iff_inr (x : TrivSqZeroExt R M) : x ∈ kerIdeal R M ↔ x = inr x.snd :=
  by
  obtain ⟨r, m⟩ := x
  simp only [ker_ideal, RingHom.mem_ker, fst_hom_apply, fst_mk]
  exact ⟨fun hr => by rw [hr]; rfl, fun hrm => by rw [← fst_mk r m, hrm, fst_inr]⟩
#align triv_sq_zero_ext.mem_ker_ideal_iff_inr TrivSqZeroExt.mem_kerIdeal_iff_inr

theorem mem_kerIdeal_iff_exists (x : TrivSqZeroExt R M) : x ∈ kerIdeal R M ↔ ∃ m : M, x = inr m :=
  by rw [mem_ker_ideal_iff_inr] <;> exact ⟨fun h => ⟨x.snd, h⟩, fun ⟨m, hm⟩ => by rw [hm]; rfl⟩
#align triv_sq_zero_ext.mem_ker_ideal_iff_exists TrivSqZeroExt.mem_kerIdeal_iff_exists

theorem square_zero : kerIdeal R M ^ 2 = 0 :=
  by
  simp only [pow_two, zero_eq_bot, eq_bot_iff, mul_le, mem_ker_ideal_iff_inr]
  rintro x hx y hy
  rw [hx, hy, mem_bot, inr_mul_inr]
#align triv_sq_zero_ext.square_zero TrivSqZeroExt.square_zero

end TrivSqZeroExt

open Ideal Ideal.Quotient TrivSqZeroExt

section GradedAlgebra

variable {R : Type _} [CommRing R]

variable {A : Type _} [CommRing A] [Algebra R A]

variable {ι : Type _} [CanonicallyOrderedAddMonoid ι]

variable (𝒜 : ι → Submodule R A)

theorem grade_zero_coe_smul (r : R) (x : 𝒜 0) : (↑(r • x) : A) = r • x :=
  rfl
#align grade_zero_coe_smul grade_zero_coe_smul

variable [DecidableEq ι] [GradedAlgebra 𝒜]

instance : One ↥(𝒜 0) :=
  ⟨⟨1, (@GradedRing.to_gradedMonoid ι A (Submodule R A) _ _ _ _ _ 𝒜 _).one_mem⟩⟩

instance : Mul ↥(𝒜 0) :=
  ⟨fun x y => ⟨x * y, by convert SetLike.mul_mem_graded x.2 y.2 <;> rw [add_zero]⟩⟩

@[simp]
theorem grade_zero_coe_mul (x y : 𝒜 0) : (↑(x * y) : A) = x * y :=
  rfl
#align grade_zero_coe_mul grade_zero_coe_mul

@[simp]
theorem grade_zero_val_mul (x y : 𝒜 0) : (x * y).val = x.val * y.val :=
  rfl
#align grade_zero_val_mul grade_zero_val_mul

@[simp]
theorem grade_zero_coe_one : (↑(1 : 𝒜 0) : A) = 1 :=
  rfl
#align grade_zero_coe_one grade_zero_coe_one

theorem one_mem : (1 : A) ∈ 𝒜 0 :=
  SetLike.one_mem_graded 𝒜
#align one_mem one_mem

example : AddCommMonoid (𝒜 0) :=
  inferInstance

example : Neg (𝒜 0) :=
  AddSubgroupClass.neg

instance gradeZeroCommRing : CommRing ↥(𝒜 0) :=
  { (inferInstance : AddCommGroup (𝒜 0)) with
    add := (· + ·)
    zero := 0
    neg := Neg.neg
    one := 1
    mul := (· * ·)
    mul_assoc := fun x y z => by ext <;> simp only [grade_zero_coe_mul, mul_assoc]
    one_mul := fun x => by ext <;> rw [grade_zero_coe_mul, grade_zero_coe_one, one_mul]
    mul_one := fun x => by ext <;> rw [grade_zero_coe_mul, grade_zero_coe_one, mul_one]
    left_distrib := fun x y z => by
      ext <;> simp only [Submodule.coe_add, grade_zero_coe_mul, left_distrib]
    right_distrib := fun x y z => by
      ext <;> simp only [Submodule.coe_add, grade_zero_coe_mul, right_distrib]
    mul_comm := fun x y => by ext <;> simp only [grade_zero_coe_mul, mul_comm] }
#align grade_zero_comm_ring gradeZeroCommRing

instance gradeZeroAlgebra : Algebra R ↥(𝒜 0) :=
  Algebra.ofModule'
    (fun r x => by
      ext <;>
        simp only [grade_zero_coe_mul, grade_zero_coe_smul, grade_zero_coe_one,
          Algebra.smul_mul_assoc, one_mul])
    fun r x => by
    ext <;>
      simp only [grade_zero_coe_mul, grade_zero_coe_smul, grade_zero_coe_one, Algebra.mul_smul_comm,
        mul_one]
#align grade_zero_algebra gradeZeroAlgebra

/-- The projection from `A` to the degree `i` component `𝒜 i`, as an `R`-linear map. -/
def proj (i : ι) : A →ₗ[R] 𝒜 i where
  toFun a := decompose 𝒜 a i
  map_add' a b := by rw [decompose_add, add_apply]
  map_smul' r a := by rw [decompose_smul, DFinsupp.coe_smul, Pi.smul_apply, RingHom.id_apply]
#align proj proj

@[simps]
def projZeroRingHom' : A →+* 𝒜 0 where
  toFun a := proj 𝒜 0 a
  map_one' := by
    ext
    simp only [proj, LinearMap.coe_mk, decompose_of_mem_same 𝒜 (one_mem 𝒜), grade_zero_coe_one]
  map_zero' := by simp only [proj, decompose_zero, LinearMap.coe_mk, zero_apply]
  map_add' _ _ := by simp only [proj, decompose_add, LinearMap.coe_mk, add_apply]
  map_mul' x y := by
    ext
    simp only [proj, LinearMap.coe_mk, SetLike.coe_eq_coe, grade_zero_coe_mul, ←
      GradedRing.projZeroRingHom_apply 𝒜, ← _root_.map_mul]
#align proj_zero_ring_hom' projZeroRingHom'

end GradedAlgebra

section GradedAlgebra

variable {R : Type _} [CommRing R]

def GalgHom.IsHomogeneous {ι : Type _} {A : Type _} [CommRing A] [Algebra R A]
    (𝒜 : ι → Submodule R A) {B : Type _} [CommRing B] [Algebra R B] (ℬ : ι → Submodule R B)
    (f : A →ₐ[R] B) :=
  ∀ i a, a ∈ 𝒜 i → f a ∈ ℬ i
#align galg_hom.is_homogeneous GalgHom.IsHomogeneous

theorem Finsupp.prod.mem_grade {κ A : Type _} [AddCommMonoid κ] [DecidableEq κ] [CommRing A]
    [Algebra R A] (𝒜 : κ → Submodule R A) [GradedAlgebra 𝒜] {σ : Type _} (c : σ →₀ ℕ) (f : σ → A)
    (d : σ → κ) (hc : ∀ s ∈ c.support, f s ∈ 𝒜 (d s)) :
    (c.Prod fun s e => f s ^ e) ∈ 𝒜 (c.Sum fun s e => e • d s) := by
  classical
  rw [Finsupp.prod, Finsupp.sum]
  let p : Finset σ → Prop := fun s =>
    s ⊆ c.support → (s.Prod fun i => f i ^ c i) ∈ 𝒜 (s.Sum fun i => c i • d i)
  apply @Finset.induction_on σ p _ c.support
  · exact imp_intro (SetLike.one_mem_graded 𝒜)
  · intro a s ha hs hs'
    rw [Finset.prod_insert ha, Finset.sum_insert ha]
    exact
      SetLike.mul_mem_graded (SetLike.pow_mem_graded _ (hc a (hs' (mem_insert_self a s))))
        (hs (subset_trans (subset_insert a s) hs'))
  · exact subset_rfl
#align finsupp.prod.mem_grade Finsupp.prod.mem_grade

def GalgHom.IsHomogeneous' {ι κ : Type _}
    -- [add_comm_monoid ι] [decidable_eq ι]
    (A : Type _)
    [CommRing A] [Algebra R A] (𝒜 : ι → Submodule R A)
    -- [graded_algebra 𝒜]
    (B : Type _)
    [CommRing B] [Algebra R B] (ℬ : κ → Submodule R B)
    -- [graded_algebra ℬ]
    (φ : ι → κ)
    (f : A →ₐ[R] B) :=
  ∀ i a, a ∈ 𝒜 i → f a ∈ ℬ (φ i)
#align galg_hom.is_homogeneous' GalgHom.IsHomogeneous'

theorem foo (σ : Type _) {ι κ : Type _} [AddCommMonoid ι]
    --[decidable_eq ι]
    [AddCommMonoid κ]
    [DecidableEq κ] (A : Type _) [CommRing A] [Algebra R A] (𝒜 : κ → Submodule R A)
    [GradedAlgebra 𝒜] (w : σ → ι) (φ : ι →+ κ) (f : σ → A) (h : ∀ s : σ, f s ∈ 𝒜 (φ (w s))) :
    GalgHom.IsHomogeneous'-- _ R _ ι κ (mv_polynomial σ R) _
      _
      (weightedHomogeneousSubmodule R w) _ 𝒜 φ (MvPolynomial.aeval f) :=
  by
  intro i p hp
  simp only [mem_weighted_homogeneous_submodule, is_weighted_homogeneous] at hp 
  rw [p.as_sum]
  rw [map_sum]
  apply Submodule.sum_mem
  intro c hc
  rw [aeval_monomial]
  rw [← smul_eq_mul]
  rw [algebraMap_smul]
  apply Submodule.smul_mem
  convert Finsupp.prod.mem_grade 𝒜 c f _ fun s _ => h s
  rw [← hp (mem_support_iff.mp hc)]
  simp only [weighted_degree']
  rw [Finsupp.total]
  simp only [Finsupp.coe_lsum, Finsupp.sum]
  rw [map_sum]
  simp only [LinearMap.coe_smulRight, LinearMap.id_coe, id.def, Algebra.id.smul_eq_mul]
  apply congr_arg₂ _ rfl
  ext s
  rw [AddMonoidHom.map_nsmul]
#align foo foo

end GradedAlgebra

theorem MvPolynomial.vars_x_subset {R : Type _} {σ : Type _} (n : σ) [CommSemiring R] :
    (X n : MvPolynomial σ R).vars ⊆ {n} := by
  classical
  intro u
  rw [X, mem_vars, mem_singleton]
  rintro ⟨c, hc, hc'⟩
  by_contra h'
  rw [mem_support_iff, coeff_monomial, Ne.def] at hc 
  by_cases h : Finsupp.single n 1 = c
  · rw [← h, Finsupp.mem_support_iff, Ne.def, Finsupp.single_apply] at hc' 
    apply hc'; rw [if_neg (Ne.symm h')]
  · apply hc; rw [if_neg h]
#align mv_polynomial.vars_X_subset MvPolynomial.vars_x_subset

section

open MvPolynomial

variable {R M : Type _} [CommRing R]

instance : GradedAlgebra (weightedHomogeneousSubmodule R (Prod.fst : ℕ × M → ℕ)) :=
  weightedGradedAlgebra _ _

variable {R}

def degree (v : ℕ × M →₀ ℕ) : ℕ :=
  finsum fun x => v x * x.1
#align degree degree

def IsHomogeneousOfDegree (p : MvPolynomial (ℕ × M) R) (n : ℕ) : Prop :=
  ∀ v ∈ p.support, degree v = n
#align is_homogeneous_of_degree IsHomogeneousOfDegree

variable (R)

theorem variable_mem_supported (nm : ℕ × M) (hn : 0 < nm.1) :
    X nm ∈ supported R {nm : ℕ × M | 0 < nm.1} :=
  by
  rw [mem_supported]
  refine' Set.Subset.trans (finset.coe_subset.mpr (vars_X_subset nm)) _
  rw [coe_singleton, Set.singleton_subset_iff, Set.mem_setOf_eq]
  exact hn
#align variable_mem_supported variable_mem_supported

def toSupported : MvPolynomial (ℕ × M) R →ₐ[R] supported R {nm : ℕ × M | 0 < nm.1} :=
  aeval fun nm : ℕ × M =>
    dite (0 < nm.1) (fun h => ⟨X nm, variable_mem_supported R nm h⟩) fun h => 1
#align to_supported toSupported

theorem toSupported_is_homogeneous :
    GalgHom.IsHomogeneous' (MvPolynomial (ℕ × M) R)
      (weightedHomogeneousSubmodule R (Prod.fst : ℕ × M → ℕ)) (MvPolynomial (ℕ × M) R)
      (weightedHomogeneousSubmodule R Prod.fst) (id : ℕ → ℕ)
      ((Subalgebra.val _).comp (toSupported R)) :=
  by
  classical
  have h :=
    @foo R _ (ℕ × M) ℕ ℕ _ _ _ (MvPolynomial (ℕ × M) R) _ _
      (weighted_homogeneous_submodule R Prod.fst) _ Prod.fst (AddMonoidHom.id ℕ)
      ((Subalgebra.val _).toFun.comp fun nm : ℕ × M =>
        dite (0 < nm.1) (fun h => ⟨X nm, variable_mem_supported R nm h⟩) fun h => 1)
      _
  have heq :
    aeval
        ((supported R {nm : ℕ × M | 0 < nm.fst}).val.toFun ∘ fun nm : ℕ × M =>
          dite (0 < nm.fst) (fun h : 0 < nm.fst => ⟨X nm, _⟩) fun h : ¬0 < nm.fst => 1) =
      (supported R {nm : ℕ × M | 0 < nm.fst}).val.comp (toSupported R) :=
    by
    apply MvPolynomial.algHom_ext
    intro nm
    simp only [toSupported, AlgHom.toFun_eq_coe, Function.comp_apply, AlgHom.coe_comp, aeval_X]
  rw [HEq] at h 
  exact h
  · intro nm
    simp only [mem_weighted_homogeneous_submodule, AlgHom.toFun_eq_coe, Subalgebra.coe_val,
      Function.comp_apply, AddMonoidHom.id_apply]
    split_ifs
    · exact is_weighted_homogeneous_X R _ _
    · simp only [not_lt, le_zero_iff] at h 
      rw [h, algebraMap.coe_one]
      exact is_weighted_homogeneous_one R _
#align to_supported_is_homogeneous toSupported_is_homogeneous

variable (M)

-- TODO: generalize
theorem eq_finsupp_single_of_degree_one {d : ℕ × M →₀ ℕ} (hd : (weightedDegree' Prod.fst) d = 1)
    (hsupp : ∀ nm : ℕ × M, nm ∈ d.support → 0 < nm.fst) : ∃ m : M, Finsupp.single (1, m) 1 = d := by
  classical
  rw [weighted_degree', Finsupp.total_apply, Finsupp.sum] at hd 
  have hnm : ∃ nm : ℕ × M, d nm • nm.fst = 1 :=
    by
    by_contra h0
    rw [not_exists] at h0 
    have hd0 : (d.support.sum fun a : ℕ × M => d a • a.fst) = 0 :=
      by
      rw [Finset.sum_eq_zero]
      intro nm hnm
      rw [← Nat.lt_one_iff]
      apply lt_of_le_of_ne _ (h0 nm)
      rw [← hd]
      exact Finset.single_le_sum (fun ab hab => zero_le _) hnm
    rw [hd0] at hd 
    exact zero_ne_one hd
  obtain ⟨nm, hnm⟩ := hnm
  rw [← hnm] at hd 
  simp only [Algebra.id.smul_eq_mul, mul_eq_one] at hnm 
  use nm.snd
  ext ab
  rw [Finsupp.single_apply]
  split_ifs with hab <;> rw [← hnm.2, eq_comm, Prod.mk.eta] at hab 
  · rw [hab, hnm.1]
  · rw [eq_comm]
    by_contra hab'
    have hne0 : d ab * ab.fst ≠ 0 :=
      mul_ne_zero hab' (ne_of_gt (hsupp ab (finsupp.mem_support_iff.mpr hab')))
    have hnm_mem : nm ∈ d.support := by rw [Finsupp.mem_support_iff, hnm.1]; exact one_ne_zero
    simp only [Finset.sum_eq_sum_diff_singleton_add hnm_mem, add_left_eq_self,
      Algebra.id.smul_eq_mul, sum_eq_zero_iff, mem_sdiff,
      Finsupp.mem_support_iff,--ne.def,
      mem_singleton] at
      hd 
    exact hne0 (hd ab ⟨hab', hab⟩)
#align eq_finsupp_single_of_degree_one eq_finsupp_single_of_degree_one

end

