/-
Copyright (c) 2024 Antoine Chambert-Loir, MarÃ­a InÃ©s de Frutos-FernÃ¡ndez. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir, MarÃ­a InÃ©s de Frutos-FernÃ¡ndez
-/
import Mathlib.Algebra.RingQuot
import Mathlib.RingTheory.GradedAlgebra.Homogeneous.Ideal
import Mathlib.RingTheory.Ideal.Quotient.Operations

/-! # Graded algebra structure on a ring quotient

Let `R` be a commutative semiring, `A` a commutative `R`-algebra, `I` an ideal in `A`, and
`ğ’œ : Î¹ â†’ Submodule R A` a grading on `A` indexed by an additive monoid `Î¹`.

## Main definitions

* `Rel.IsPureHomogeneous`: a relation `r` is `PureHomogeneous` iff `r a b` implies that `a` and `b`
  are homogeneous of the same degree.

* `Rel.IsHomogeneous`: a relation is `Homogeneous` iff `r a b` implies that the components of
  `a` and `b` are related by `r`.

* `Ideal.gradedQuotAlg`: the quotient of a graded algebra by a homogeneous ideal, as a
  graded algebra

* `quotGradedAlgebra`: the graded algebra structure on `RingQuot rel`.

* `Ideal.quotSubmodule`: the graded pieces of `A â§¸ I`.

* `Ideal.quotDecomposition` : the decomposition of `A/I` as the direct sum of its graded
  components.

## Main results

* `RingConGen.Rel.isHomogeneous_of`: the equivalence ring relation generated by a homogeneous
  relation is homogeneous.

-/

open DirectSum Function

section Classes

namespace LinearMapClass

variable {R Î² Î³ : Type*} [Semiring R] [AddCommMonoid Î²] [Module R Î²] [AddCommMonoid Î³] [Module R Î³]

instance coeTCToLinearMap {F : Type*} [FunLike F Î² Î³] [LinearMapClass F R Î² Î³] :
    CoeTC F (Î² â†’â‚—[R] Î³) := âŸ¨fun h => âŸ¨h, map_smul hâŸ©âŸ©

theorem coe_coe {F : Type*} [FunLike F Î² Î³] [LinearMapClass F R Î² Î³] (f : F) :
    ((f : Î² â†’â‚—[R] Î³) : Î² â†’ Î³) = f := rfl

theorem coe_coe' {F : Type*} [FunLike F Î² Î³] [LinearMapClass F R Î² Î³] (f : F) :
    ((f : Î² â†’â‚—[R] Î³) : Î² â†’+ Î³) = f := rfl

end LinearMapClass

namespace AlgHomClass

variable {R Î² Î³ : Type*} [CommSemiring R] [Semiring Î²] [Algebra R Î²] [Semiring Î³] [Algebra R Î³]

theorem toLinearMap_coe_coe {F : Type*} [FunLike F Î² Î³] [AlgHomClass F R Î² Î³] (h : F) :
    ((h : Î² â†’â‚—[R] Î³) : Î² â†’ Î³) = h := rfl

end AlgHomClass

end Classes

theorem DFinsupp.mk_eq_sum {Î¹ : Type*} [DecidableEq Î¹] {Î² : Î¹ â†’ Type*}
    [âˆ€ i, AddCommMonoid (Î² i)] (s : Finset Î¹) (f : âˆ€ i, Î² i) :
    (DFinsupp.mk s fun i => f i) = s.sum fun i => of Î² i (f i) := by
  ext i
  simp only [DFinsupp.mk_apply]
  split_ifs with hi
  Â· rw [DFinsupp.finset_sum_apply, Finset.sum_eq_single_of_mem i hi
      (fun j _ hij =>  of_eq_of_ne _ _ _ hij.symm), of_eq_same]
  Â· rw [DFinsupp.finset_sum_apply, Finset.sum_eq_zero
      (fun j hj => of_eq_of_ne _ _ _ (ne_of_mem_of_not_mem hj hi).symm)]

section DirectSum

namespace DirectSum

variable {Î¹ : Type*} {R : Type*} [Semiring R]

/-- The components of a direct sum, as add_monoid_hom -/
def component' {Î² : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] (i : Î¹) : (â¨ i, Î² i) â†’+ Î² i :=
  component â„• Î¹ Î² i

theorem component'_eq {Î² : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] (x : DirectSum Î¹ Î²) (i : Î¹) :
    component' i x = x i := rfl

theorem ext_iff' {Î² : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)]
    (x y : â¨ i, Î² i) : x = y â†” âˆ€ i, component' i x = component' i y := DirectSum.ext_iff

/- Four versions of a direct sum of maps
   direct_sum.map'' : for add_monoid_hom
   direct_sum.lmap''  : for linear_map
   the  double-primed versions are defined in terms of classes
   In principle, the latter should suffice. -/

variable [DecidableEq Î¹]

/-- `AddMonoidHom` from a direct sum to a direct sum given by families of
  `AddMonoidHomClass` maps. -/
def map'' {Î² Î³ : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] [âˆ€ i, AddCommMonoid (Î³ i)]
    {F : âˆ€ _ : Î¹, Type*} [âˆ€ i, FunLike (F i) (Î² i) (Î³ i)]
    [âˆ€ i, AddMonoidHomClass (F i) (Î² i) (Î³ i)] (h : âˆ€ i, F i) :
    (â¨ i, Î² i) â†’+ â¨ i, Î³ i :=
  toAddMonoid fun i => (of Î³ i).comp (h i)

/-- `AddMonoidHom` from a direct sum to a direct sum given by families of `AddMonoidHom`s. -/
def map' {Î² Î³ : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] [âˆ€ i, AddCommMonoid (Î³ i)]
    (h : âˆ€ i, Î² i â†’+ Î³ i) : (â¨ i, Î² i) â†’+ (â¨ i, Î³ i) :=
  toAddMonoid fun i => (of Î³ i).comp (h i)

/-- `LinearMap` from a direct sum to a direct sum given by families of `LinearMapClass` maps. -/
def lmap'' {Î² Î³ : Î¹ â†’ Type*}
    [âˆ€ i, AddCommMonoid (Î² i)] [âˆ€ i, Module R (Î² i)]
    [âˆ€ i, AddCommMonoid (Î³ i)] [âˆ€ i, Module R (Î³ i)]
    {F : âˆ€ _ : Î¹, Type*} [âˆ€ i, FunLike (F i) (Î² i) (Î³ i)] [âˆ€ i, LinearMapClass (F i) R (Î² i) (Î³ i)]
    (h : âˆ€ i, F i) : (â¨ i, Î² i) â†’â‚—[R] (â¨ i, Î³ i) :=
  toModule R Î¹ (â¨ i, Î³ i) fun i => (lof R Î¹ Î³ i).comp (h i : Î² i â†’â‚—[R] Î³ i)

/-- `LinearMap` from a direct sum to a direct sum given by families of `LinearMap`s. -/
def lmap' {Î² Î³ : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] [âˆ€ i, Module R (Î² i)]
    [âˆ€ i, AddCommMonoid (Î³ i)] [âˆ€ i, Module R (Î³ i)] (h : âˆ€ i, Î² i â†’â‚—[R] Î³ i) :
    (â¨ i, Î² i) â†’â‚—[R] (â¨ i, Î³ i) :=
  toModule R Î¹ _ fun i => (lof R Î¹ Î³ i).comp (h i)

theorem map'_eq_lmap'_toAddMonoidHom {Î² Î³ : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)]
    [âˆ€ i, AddCommMonoid (Î³ i)] (h : âˆ€ i, Î² i â†’+ Î³ i) :
    map' h = (lmap' fun i => (h i).toNatLinearMap).toAddMonoidHom := rfl

theorem lmap'_toAddMonoidHom_eq_map' {Î² Î³ : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)]
    [âˆ€ i, Module R (Î² i)] [âˆ€ i, AddCommMonoid (Î³ i)] [âˆ€ i, Module R (Î³ i)]
    (h : âˆ€ i, Î² i â†’â‚—[R] Î³ i) :
    (lmap' h).toAddMonoidHom = map' fun i => (h i).toAddMonoidHom := rfl

-- Lemmas to help computation
theorem map''_of {Î² Î³ : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] [âˆ€ i, AddCommMonoid (Î³ i)]
    {F : Î¹ â†’ Type*} [âˆ€ i, FunLike (F i) (Î² i) (Î³ i)] [âˆ€ i, AddMonoidHomClass (F i) (Î² i) (Î³ i)]
    (h : âˆ€ i, F i) (i : Î¹) (x : Î² i) : map'' h (of Î² i x) = of Î³ i (h i x) := by
  simp only [map'', toAddMonoid_of, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe]
  rfl

theorem map''_apply {Î² Î³ : Î¹ â†’ Type*} [Î  i, AddCommMonoid (Î² i)] [Î  i, AddCommMonoid (Î³ i)]
    {F : Î  _i, Type*} [âˆ€ i, FunLike (F i) (Î² i) (Î³ i)] [Î  i, AddMonoidHomClass (F i) (Î² i) (Î³ i)]
    (h : Î  i, F i) (x : DirectSum Î¹ Î²) (i : Î¹) : map'' h x i = h i (x i) := by
  let f : DirectSum Î¹ Î² â†’+ Î³ i :=
  { toFun := fun x => map'' h x i
    map_zero' := by simp only [map_zero, zero_apply]
    map_add' := by simp only [map_add, add_apply, forall_const] }
  let g : DirectSum Î¹ Î² â†’+ Î³ i :=
  { toFun := fun y => h i (y i)
    map_zero' := by simp only [zero_apply, map_zero]
    map_add' := by simp only [add_apply, map_add, forall_const] }
  change f x = g x
  suffices f = g by
    rw [this]
  apply addHom_ext
  intros j y
  simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, map''_of, f, g]
  by_cases hj : i = j
  Â· rw [hj]; simp only [of_eq_same]
  Â· simp only [of_eq_of_ne j i _ hj, map_zero]

theorem map'_of {Î² Î³ : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] [âˆ€ i, AddCommMonoid (Î³ i)]
    (h : âˆ€ i, Î² i â†’+ Î³ i) (i : Î¹) (x : Î² i) :
    map' h (of Î² i x) = of Î³ i (h i x) := by
  simp [map', toAddMonoid_of, AddMonoidHom.coe_comp]

theorem lmap'_lof {Î² Î³ : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] [âˆ€ i, AddCommMonoid (Î³ i)]
    [âˆ€ i, Module R (Î² i)] [âˆ€ i, Module R (Î³ i)] (h : âˆ€ i, Î² i â†’â‚—[R] Î³ i) (i : Î¹) (x : Î² i) :
  lmap' h (lof R Î¹ Î² i x) = lof R Î¹ Î³ i (h i x) := by
  simp [lmap', toModule_lof, LinearMap.coe_comp]

theorem lmap'_surjective {Î² Î³ : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] [âˆ€ i, Module R (Î² i)]
    [âˆ€ i, AddCommMonoid (Î³ i)] [âˆ€ i, Module R (Î³ i)] (f : âˆ€ i, Î² i â†’â‚—[R] Î³ i)
    (h : âˆ€ i, Surjective (f i)) : Surjective (lmap' f) := by
  intro c
  induction' c using DirectSum.induction_on with i xi x y hx hy
  . exact âŸ¨0, map_zero _âŸ©
  . use of _ i (h i xi).choose
    rw [â† lof_eq_of R, lmap'_lof, lof_eq_of, (h i xi).choose_spec]
  . obtain âŸ¨a, ha, rflâŸ© := hx
    obtain âŸ¨b, hb, rflâŸ© := hy
    exact âŸ¨a + b, map_add _ _ _âŸ©

theorem lmap'_apply {Î² Î³ : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] [âˆ€ i, AddCommMonoid (Î³ i)]
    [âˆ€ i, Module R (Î² i)] [âˆ€ i, Module R (Î³ i)] (h : âˆ€ i, Î² i â†’â‚—[R] Î³ i) (x : â¨ i, Î² i) (i : Î¹) :
    lmap' h x i = h i (x i) := by
  simp only [apply_eq_component R, â† LinearMap.comp_apply]
  apply LinearMap.congr_fun
  ext j y
  simp only [LinearMap.comp_apply, lmap'_lof]
  simp only [lof_eq_of, â† apply_eq_component]
  by_cases hji : i = j
  Â· rw [hji]; simp only [of_eq_same]
  Â· simp only [of_eq_of_ne j i _ hji, map_zero]

theorem toModule_comp_lmap'_eq {Î² Î³ : Î¹ â†’ Type*} {Î´ : Type*} [âˆ€ i, AddCommMonoid (Î² i)]
    [âˆ€ i, AddCommMonoid (Î³ i)] [AddCommMonoid Î´] [âˆ€ i, Module R (Î² i)] [âˆ€ i, Module R (Î³ i)]
    [Module R Î´] (h : âˆ€ i, Î² i â†’â‚—[R] Î³ i) (f : âˆ€ i, Î³ i â†’â‚—[R] Î´) (x : â¨ i, Î² i) :
    toModule R Î¹ Î´ f (lmap' h x) = toModule R Î¹ Î´ (fun i => (f i).comp (h i)) x := by
  rw [â† LinearMap.comp_apply]
  apply LinearMap.congr_fun
  ext i y
  simp only [LinearMap.coe_comp, comp_apply, lmap'_lof, toModule_lof]

theorem map'_apply {Î² Î³ : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] [âˆ€ i, AddCommMonoid (Î³ i)]
    (h : âˆ€ i, Î² i â†’+ Î³ i) (x : â¨ i, Î² i) (i : Î¹) : map' h x i = h i (x i) := by
  let f : (â¨ i, Î² i) â†’+ Î³ i :=
    { toFun     := fun x => map' h x i
      map_zero' := by simp only [map_zero, zero_apply]
      map_add'  := by simp only [map_add, add_apply, forall_const] }
  let g : (â¨ i, Î² i) â†’+ Î³ i :=
    { toFun     := fun y => h i (y i)
      map_zero' := by simp only [zero_apply, map_zero]
      map_add'  := by simp only [add_apply, map_add, forall_const] }
  change f x = g x
  apply DFunLike.congr_fun
  ext j y
  simp only [f, g, AddMonoidHom.coe_comp, AddMonoidHom.coe_mk, ZeroHom.coe_mk, comp_apply,
    map'_of]
  by_cases hj : i = j
  Â· rw [hj]; simp only [of_eq_same]
  Â· simp only [of_eq_of_ne j i _ hj, map_zero]

theorem mk_apply {Î² : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] (s : Finset Î¹)
    (f : (âˆ€ i : (â†‘s : Set Î¹), Î² i.1)) (i : Î¹) :
    mk Î² s f i = if h : i âˆˆ s then f âŸ¨i, hâŸ© else 0 := rfl

theorem mk_eq_sum' {Î² : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] (s : Finset Î¹) (f : âˆ€ i, Î² i) :
    (mk Î² s (fun i => f i)) = s.sum (fun i => of Î² i (f i)) := by
  apply DFinsupp.ext
  intro i
  convert mk_apply s _ i
  rw [DFinsupp.finset_sum_apply]
  split_ifs with hi
  Â· rw [Finset.sum_eq_single_of_mem i hi (fun j _ hij => of_eq_of_ne _ _ _ hij.symm),
      â† lof_eq_of â„•, lof_apply]
  Â· exact Finset.sum_eq_zero (fun _ hj â†¦ of_eq_of_ne _ _ _ (ne_of_mem_of_not_mem hj hi).symm)

theorem mk_eq_sum {Î² : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] (s : Finset Î¹) (x : âˆ€ i : s, Î² i) :
  mk Î² s x = s.sum fun i => of Î² i (if h : i âˆˆ s then x âŸ¨i, hâŸ© else 0) := by
  apply DFinsupp.ext
  intro i
  rw [mk_apply]
  split_ifs with hi
  Â· rw [DFinsupp.finset_sum_apply, Finset.sum_eq_single i (fun j _ hji =>
      of_eq_of_ne _ _ _ hji.symm), of_eq_same, dif_pos hi]
    Â· intro his
      rw [of_eq_same, dif_neg his]
  Â· rw [DFinsupp.finset_sum_apply, Finset.sum_eq_zero
      (fun j hj => of_eq_of_ne _ _ _ (ne_of_mem_of_not_mem hj hi).symm)]

theorem toAddMonoid_mk {Î² : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] {Î³ : Type*} [AddCommMonoid Î³]
    (Ïˆ : âˆ€ i, Î² i â†’+ Î³) (s : Finset Î¹) (x : âˆ€ i : s, Î² i) :
    toAddMonoid Ïˆ (mk Î² s x) =
      s.sum fun i => Ïˆ i (if h : i âˆˆ s then x âŸ¨i, hâŸ© else 0) := by
  rw [mk_eq_sum, map_sum, Finset.sum_congr rfl (fun i _ => toAddMonoid_of _ _ _)]

theorem map_apply' {Î² Î³ : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] [âˆ€ i, AddCommMonoid (Î³ i)]
    [âˆ€ (i : Î¹) (x : Î² i), Decidable (x â‰  0)]  {F : âˆ€ _, Type*} [âˆ€ i, FunLike (F i) (Î² i) (Î³ i)]
    [âˆ€ i, AddMonoidHomClass (F i) (Î² i) (Î³ i)] (h : âˆ€ i, F i) (x : â¨ i, Î² i) :
    map'' h x = mk Î³ x.support (fun i => (h i) (x i)) := by
  conv_lhs => rw [â† sum_support_of x]
  simp_rw [map_sum, map''_of]
  rw [eq_comm]
  convert mk_eq_sum x.support fun i => (h i) (x i)
  rwa [dif_pos]

end DirectSum

end DirectSum

section GradedQuot

section Semiring

variable {R Î¹ A : Type*} [CommSemiring R] [DecidableEq Î¹] [AddMonoid Î¹] [CommSemiring A]
  [Algebra R A] (ğ’œ : Î¹ â†’ Submodule R A)

section HomogeneousRelation

variable (rel : A â†’ A â†’ Prop)

lemma DirectSum.decomposeAlgEquiv_coe [GradedAlgebra ğ’œ] (a : A) :
    decomposeAlgEquiv ğ’œ a = decompose ğ’œ a := by rfl

lemma RingConGen.Rel.sum {Î± : Type*} [Ring Î±] (r : RingCon Î±) {Î¹ : Type*} [DecidableEq Î¹]
    {a b : Î¹ â†’ Î±} (s : Finset Î¹) (hs : âˆ€ i âˆˆ s, r (a i) (b i)) :
    RingConGen.Rel r (s.sum a) (s.sum b) := by
  revert hs
  induction s using Finset.induction_on with
  | empty => exact fun _ =>  RingConGen.Rel.refl _
  | insert j t hj ht =>
    intro hs
    simp only [Finset.sum_insert hj]
    exact (RingConGen.Rel.of _ _ (hs j (Finset.mem_insert_self j t))).add
      (ht (fun i hi =>  hs i (Finset.mem_insert_of_mem hi)))

theorem DFinsupp.sum_of_support_le {M : Type*} [AddCommMonoid M] {Î¹ : Type*}
    [dec_Î¹ : DecidableEq Î¹] {Î² : Î¹ â†’ Type*} [inst : (i : Î¹) â†’ AddCommMonoid (Î² i)]
    [inst : (i : Î¹) â†’ (x : Î² i) â†’ Decidable (x â‰  0)] {h : (i : Î¹) â†’ (Î² i â†’+ M)}
    {x : DFinsupp Î²} {s : Finset Î¹} (hs : DFinsupp.support x âŠ† s) :
    x.sum (fun i y => h i y) = s.sum (fun i => h i (x i)) := by
  simp only [DFinsupp.sum]
  apply Finset.sum_subset hs
  . intro i _ hi'
    simp only [DFinsupp.mem_support_toFun, ne_eq, not_not] at hi'
    rw [hi', map_zero]

namespace Rel
/-- A relation `r` is `PureHomogeneous` iff `r a b` implies that `a` and `b`
  are homogeneous of the same degree. -/
def IsPureHomogeneous :=
  âˆ€ {a b : A} (_ : rel a b), âˆƒ i, a âˆˆ ğ’œ i âˆ§ b âˆˆ ğ’œ i

/-- A relation is `Homogeneous` iff `r a b` implies that the components of `a` and `b`
  are related by `r`. -/
def IsHomogeneous [GradedAlgebra ğ’œ] : Prop :=
  âˆ€ {a b : A} (_ : rel a b), âˆ€ i,
    rel ((decomposeAlgEquiv ğ’œ).toLinearMap a i) ((decomposeAlgEquiv ğ’œ).toLinearMap b i)

variable {ğ’œ rel}

lemma isHomogeneous_of_isPureHomogeneous [GradedAlgebra ğ’œ] (hrel : IsPureHomogeneous ğ’œ rel)
    (hrel0 : rel 0 0) : IsHomogeneous ğ’œ rel := by
  intro a b h i
  obtain âŸ¨j, ha, hbâŸ© := hrel h
  by_cases hij : j = i
  . rw [â† hij]
    simp only [AlgEquiv.toLinearMap_apply, decomposeAlgEquiv_coe, decompose_of_mem_same, ha, hb, h]
  . simp only [AlgEquiv.toLinearMap_apply, decomposeAlgEquiv_coe, decompose_of_mem_ne _ ha hij,
      decompose_of_mem_ne _ hb hij]
    exact hrel0 -- needs that rel is reflexive

end Rel

theorem DirectSum.sum_of_support_le {Î¹ : Type*} [DecidableEq Î¹] (Î² : Î¹ â†’ Type*)
    [(i : Î¹) â†’ AddCommMonoid (Î² i)] [(i : Î¹) â†’ (x : Î² i) â†’ Decidable (x â‰  0)]
    {x : â¨ (i : Î¹), Î² i} {s : Finset Î¹} (hs : DFinsupp.support x âŠ† s) :
    s.sum (fun i => (of Î² i) (x i)) = x := by
  conv_rhs => rw [â† sum_support_of x]
  rw [eq_comm]
  apply Finset.sum_subset hs
  . intro i _ hi'
    simp only [DFinsupp.mem_support_toFun, ne_eq, not_not] at hi'
    rw [hi', map_zero]

theorem DirectSum.finsupp_sum_support_decompose'
    {Î¹ : Type u_3} {M : Type u_1} {Ïƒ : Type u_2} [DecidableEq Î¹] [AddCommMonoid M] [SetLike Ïƒ M]
    [AddSubmonoidClass Ïƒ M] (â„³ : Î¹ â†’ Ïƒ) [Decomposition â„³]
    [(i : Î¹) â†’ (x : { x // x âˆˆ â„³ i }) â†’ Decidable (x â‰  0)] (r : M) :
    r = ((decompose â„³) r).sum (fun _ x => â†‘x) := by
  conv_lhs => rw [â† sum_support_decompose â„³ r]
  rfl

open Relation

theorem eqvGenIsHomogeneous_of [GradedAlgebra ğ’œ] (hr : Rel.IsHomogeneous ğ’œ rel) :
    Rel.IsHomogeneous ğ’œ (EqvGen rel) := by
  intro a b h
  induction h with
  | rel a b h => exact fun i => EqvGen.rel _ _ (hr h i)
  | refl a => exact fun i => EqvGen.refl _
  | symm a b _ k => exact fun i => EqvGen.symm _ _ (k i)
  | trans a b c _ _ k k' => exact fun i => EqvGen.trans _ _ _ (k i) (k' i)

lemma rel_of_sum_of_rel_add {A : Type*} [AddCommMonoid A] {r : A â†’ A â†’ Prop} (hr_zero : r 0 0)
    (hr_add : âˆ€ {a b c d} (_ : r a c) (_ : r b d), r (a + b) (c + d)) {Î¹ : Type*} [DecidableEq Î¹]
    {f g : Î¹ â†’ A} {s : Finset Î¹} (H : âˆ€ i âˆˆ s, r (f i) (g i)) : r (s.sum f) (s.sum g) := by
  revert H
  induction s using Finset.induction_on with
  | empty => exact fun _ =>  hr_zero
  | @insert i s hi hs =>
    intro H
    simp only [Finset.sum_insert hi]
    exact hr_add (H _ (Finset.mem_insert_self _ _))
      (hs (fun _ hi => H _ (Finset.mem_insert_of_mem hi)))

lemma rel_of_finsupp_sum_of_rel_add {A : Type*} [AddCommMonoid A] {r : A â†’ A â†’ Prop}
    (hr_zero : r 0 0) (hr_add : âˆ€ {a b c d} (_ : r a c) (_ : r b d), r (a + b) (c + d))
    {Î¹ : Type*} [DecidableEq Î¹] {f g : Î¹ â†’â‚€ A} (H : âˆ€ i, r (f i) (g i)) :
    r (f.sum fun _ x => x) (g.sum fun _ x => x) := by
  rw [Finsupp.sum_of_support_subset f Finset.subset_union_left,
    Finsupp.sum_of_support_subset g Finset.subset_union_right]
  exact rel_of_sum_of_rel_add hr_zero hr_add (fun i _ =>  H i)
  all_goals { intro _ _ ; rfl }

lemma rel_of_dsum_of_rel_add {A : Type*} [AddCommMonoid A] {r : A â†’ A â†’ Prop} (hr_zero : r 0 0)
    (hr_add : âˆ€ {a b c d} (_ : r a c) (_ : r b d), r (a + b) (c + d)) {Î¹ : Type*} [DecidableEq Î¹]
    {Î² : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)] {f g : (i : Î¹) â†’ Î² i} (h : (i : Î¹) â†’ (Î² i â†’+ A))
    {s : Finset Î¹} (H : âˆ€ i âˆˆ s, r (h i (f i)) (h i (g i))) :
  r (s.sum (fun i => h i (f i))) (s.sum (fun i => h i (g i))) := by
  revert H
  induction s using Finset.induction_on with
  | empty => exact fun _ => hr_zero
  | @insert i s hi hs =>
    intro H
    simp only [Finset.sum_insert hi]
    exact hr_add (H _ (Finset.mem_insert_self _ _))
      (hs (fun _ hi => H _ (Finset.mem_insert_of_mem hi)))

lemma rel_of_dfinsupp_sum_of_rel_add {A : Type*} [AddCommMonoid A] {r : A â†’ A â†’ Prop}
    (hr_zero : r 0 0) (hr_add : âˆ€ {a b c d} (_ : r a c) (_ : r b d), r (a + b) (c + d))
    {Î¹ : Type*} [DecidableEq Î¹] {Î² : Î¹ â†’ Type*} [âˆ€ i, AddCommMonoid (Î² i)]
    [âˆ€ i (y : Î² i), Decidable (y â‰  0)] (h : (i : Î¹) â†’ (Î² i â†’+ A)) (h' : (i : Î¹) â†’ (Î² i â†’+ A))
    {f g : DFinsupp Î²} (H : âˆ€ i, r (h i (f i)) (h' i (g i))) :
    r (f.sum fun i y => h i y) (g.sum fun i y => h' i y) := by
  have := Finset.subset_union_left (sâ‚ := f.support) (sâ‚‚ := g.support)
  rw [DFinsupp.sum_of_support_le (Finset.subset_union_left (sâ‚ := f.support) (sâ‚‚ := g.support)),
    DFinsupp.sum_of_support_le (Finset.subset_union_right (sâ‚ := f.support) (sâ‚‚ := g.support))]
  exact rel_of_sum_of_rel_add hr_zero hr_add (fun i _ => H i)

private def Î¦ (n i j : Î¹) : ğ’œ i â†’+ ğ’œ j â†’+ A where
  toFun x := {
    toFun y   := if i + j = n then x * y else (0 : A)
    map_add' a a' := by
      split_ifs <;> simp only [Submodule.coe_add, mul_add, add_zero]
    map_zero' := by simp only [ZeroMemClass.coe_zero, mul_zero, ite_self] }
  map_add' b b' := by
    ext a
    simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, AddMonoidHom.add_apply]
    split_ifs <;> simp only [Submodule.coe_add, add_mul, add_zero]
  map_zero' := by simp only [ZeroMemClass.coe_zero, zero_mul, ite_self]; rfl

private def Î¦y [DecidableEq A] (n : Î¹) (y : DirectSum Î¹ (fun i => ğ’œ i)) (i : Î¹) : (ğ’œ i) â†’+ A where
  toFun a       := y.sum (fun j b => Î¦ ğ’œ n i j a b)
  map_add' a a' := by simp only [map_add, AddMonoidHom.add_apply, DFinsupp.sum_add]
  map_zero'     := by simp only [map_zero, AddMonoidHom.zero_apply, DFinsupp.sum_zero]

/-- The equivalence ring relation generated by a homogeneous relation is homogeneous. -/
theorem RingConGen.Rel.isHomogeneous_of [GradedAlgebra ğ’œ]
    (hr : Rel.IsHomogeneous ğ’œ rel) : Rel.IsHomogeneous ğ’œ (RingConGen.Rel rel) := by
  intro a b h
  induction h with
  | of x y h => exact fun i =>  RingConGen.Rel.of _ _ (hr h i)
  | refl x => exact fun _ => RingConGen.Rel.refl _
  | symm _ h' => exact fun i => RingConGen.Rel.symm (h' i)
  | trans _ _ k k' => exact fun i => RingConGen.Rel.trans (k i) (k' i)
  | add _ _  k k' =>
    intro i
    simp only [map_add]
    exact RingConGen.Rel.add (k i) (k' i)
  | @mul a b c d _ _ k k' =>
    classical
    intro n
    simp only [AlgEquiv.toLinearMap_apply, map_mul, coe_mul_apply_eq_dfinsuppSum]
    apply rel_of_dfinsupp_sum_of_rel_add (RingConGen.Rel.refl 0) (RingConGen.Rel.add)
      (Î¦y ğ’œ n (decomposeAlgEquiv ğ’œ c)) (Î¦y ğ’œ n (decomposeAlgEquiv ğ’œ d))
    intro i
    apply rel_of_dfinsupp_sum_of_rel_add (RingConGen.Rel.refl 0) (RingConGen.Rel.add)
    intro j
    dsimp only [Î¦]
    by_cases hn : i + j = n
    . simp only [if_pos hn]
      exact RingConGen.Rel.mul (k i) (k' j)
    . simp only [if_neg hn]
      exact RingConGen.Rel.refl _

end HomogeneousRelation

end Semiring

section Ring

variable {R Î¹ A : Type*} [CommRing R] [DecidableEq Î¹] [CommRing A] [Algebra R A]
  (ğ’œ : Î¹ â†’ Submodule R A) (r : A â†’ A â†’ Prop)

section AddMonoid

variable [AddMonoid Î¹]

/-- The ideal generated by a pure homogeneous relation is homogeneous. -/
theorem Ideal.isHomogeneous_of_rel_isPureHomogeneous [GradedAlgebra ğ’œ]
    (hr : Rel.IsPureHomogeneous ğ’œ r) : Ideal.IsHomogeneous ğ’œ (Ideal.ofRel r):= by
  apply Ideal.homogeneous_span
  rintro x  âŸ¨a, b, âŸ¨h, heqâŸ©âŸ©
  obtain âŸ¨i, hiâŸ© := hr h
  use i
  rw [(eq_sub_iff_add_eq).mpr heq]
  exact Submodule.sub_mem _ hi.1 hi.2

/-- The ideal generated by a homogeneous relation is homogeneou.s -/
theorem Ideal.isHomogeneous_of_rel_isHomogeneous [hğ’œ : GradedAlgebra ğ’œ]
    (hr : Rel.IsHomogeneous ğ’œ r) : Ideal.IsHomogeneous ğ’œ (Ideal.ofRel r):= by
  classical
  let r' : A â†’ A â†’ Prop := fun a b => âˆƒ i, a âˆˆ ğ’œ i âˆ§ b âˆˆ ğ’œ i âˆ§ r a b
  suffices Ideal.ofRel r = Ideal.ofRel r' by
    rw [this]
    apply Ideal.isHomogeneous_of_rel_isPureHomogeneous
    rintro a b âŸ¨i, hâŸ©
    exact âŸ¨i, h.1, h.2.1âŸ©
  apply le_antisymm
  . intro x hx
    refine Submodule.span_induction ?_ ?_ ?_ ?_ hx
    . rintro x âŸ¨a, b, h', hâŸ©
      rw [â† hğ’œ.left_inv x, â† sum_support_of (Decomposition.decompose' x),
        map_sum]
      apply Ideal.sum_mem
      intro i _
      rw [coeAddMonoidHom_of]
      apply Ideal.subset_span
      use hğ’œ.decompose' a i, hğ’œ.decompose' b i
      constructor
      . use i
        simp only [Decomposition.decompose'_eq, SetLike.coe_mem, true_and]
        simp only [Rel.IsHomogeneous] at hr
        exact hr h' i
      . simp only [Decomposition.decompose'_eq, â† h, decompose_add, add_apply, Submodule.coe_add]
    . simp only [Submodule.zero_mem]
    . intro x y _ _ hx hy
      exact Ideal.add_mem _ hx hy
    . intro a x _ hx
      simp only [smul_eq_mul]
      apply Ideal.mul_mem_left _ _ hx
  . exact fun x hx' â†¦ Submodule.span_induction
      (fun x âŸ¨a, b, âŸ¨i, _, _, h'âŸ©, hâŸ© â†¦ Ideal.subset_span âŸ¨a, b, h', hâŸ©)
      (Submodule.zero_mem _) (fun _ _ _ _ hx hy => Ideal.add_mem _ hx hy)
      (fun a _ _ hx => Ideal.mul_mem_left _ a hx) hx'

end AddMonoid

end Ring

section Rel

open DirectSum Function

variable {R Î¹ A : Type*} [CommSemiring R] [DecidableEq Î¹] [CommSemiring A] [Algebra R A]
  (ğ’œ : Î¹ â†’ Submodule R A) (rel : A â†’ A â†’ Prop)

variable (R)

/-- The graded pieces of `RingQuot rel`. -/
def quotSubmodule (i : Î¹) : Submodule R (RingQuot rel) :=
  Submodule.map (RingQuot.mkAlgHom R rel) (ğ’œ i)

/-- The canonical LinearMap from the graded pieces of A to that of RingQuot rel. -/
def quotCompMap (i : Î¹) : (ğ’œ i) â†’â‚—[R] (quotSubmodule R ğ’œ rel i) where
  toFun u := âŸ¨RingQuot.mkAlgHom R rel â†‘u, by
      rw [quotSubmodule, Submodule.mem_map]
      exact âŸ¨â†‘u, u.prop, rflâŸ©âŸ©
  map_add' u v := by
    simp only [Submodule.coe_add, map_add, AddMemClass.mk_add_mk]
  map_smul' r u := by
    simp only [SetLike.val_smul, map_smul, RingHom.id_apply]; rfl

/-- The `R`-linear map to `RingQuot rel` from the direct sum of its components. -/
def quotDecompose' : DirectSum Î¹ (fun i => quotSubmodule R ğ’œ rel i) â†’â‚—[R] RingQuot rel :=
  toModule R Î¹ _ (fun i => Submodule.subtype (quotSubmodule R ğ’œ rel i))

variable {R}

instance SetLike.GradedMonoid_RingQuot [AddMonoid Î¹] [hğ’œ : SetLike.GradedMonoid ğ’œ] :
  SetLike.GradedMonoid (fun i => (ğ’œ i).map (RingQuot.mkAlgHom R rel)) where
    one_mem :=  âŸ¨1, hğ’œ.one_mem, by simp only [map_one]âŸ©
    mul_mem := fun i j x y => by
      rintro âŸ¨a, ha, rflâŸ© âŸ¨b, hb, rflâŸ©
      exact âŸ¨a*b, âŸ¨hğ’œ.mul_mem ha hb, map_mul _ _ _âŸ©âŸ©

theorem quotDecompose_left_inv'_aux :
    (coeLinearMap fun i => Submodule.map (RingQuot.mkAlgHom R rel) (ğ’œ i)).comp
      (lmap' (quotCompMap R ğ’œ rel)) =
    (RingQuot.mkAlgHom R rel).toLinearMap.comp (coeLinearMap ğ’œ) := by
  apply linearMap_ext
  intro i
  ext âŸ¨x, hxâŸ©
  simp only [quotCompMap, LinearMap.coe_comp, comp_apply, AlgHom.toLinearMap_apply, lmap'_lof]
  simp only [lof_eq_of, coeLinearMap_of]
  rfl

theorem quotDecompose_left_inv'_aux_apply (x) :
    (coeLinearMap fun i => Submodule.map (RingQuot.mkAlgHom R rel) (ğ’œ i))
      (lmap' (quotCompMap R ğ’œ rel) x) =
    (RingQuot.mkAlgHom R rel) (coeLinearMap ğ’œ x) := by
  let e := quotDecompose_left_inv'_aux ğ’œ rel
  simp only [LinearMap.ext_iff, LinearMap.comp_apply, AlgHom.toLinearMap_apply] at e
  apply e

lemma quotDecompose'_apply (a : DirectSum Î¹ (fun i => ğ’œ i)) :
    (quotDecompose' R ğ’œ rel) (lmap' (quotCompMap R ğ’œ rel) a) =
      RingQuot.mkAlgHom R rel (coeLinearMap ğ’œ a) := by
  suffices (quotDecompose' R ğ’œ rel).comp (lmap' (quotCompMap R ğ’œ rel)) =
      (RingQuot.mkAlgHom R rel).toLinearMap.comp (coeLinearMap ğ’œ) by
    simp only [LinearMap.ext_iff, LinearMap.comp_apply, AlgHom.toLinearMap_apply] at this
    apply this
  apply linearMap_ext
  intro i
  ext âŸ¨x, hxâŸ©
  simp only [quotDecompose', LinearMap.coe_comp, comp_apply, AlgHom.toLinearMap_apply,
    lmap'_lof, toModule_lof]
  simp only [lof_eq_of, coeLinearMap_of, quotCompMap, LinearMap.coe_mk,
    AddHom.coe_mk, Submodule.coe_subtype]

section AddMonoid

variable [AddMonoid Î¹]

lemma lmap'_quotCompMap_apply [hğ’œ : GradedAlgebra ğ’œ] (i : Î¹)
    (a : DirectSum Î¹ fun i â†¦ â†¥(ğ’œ i)) :
    RingQuot.mkAlgHom R rel â†‘(((decompose fun i => ğ’œ i) ((coeLinearMap fun i => ğ’œ i) a)) i) =
      ((lmap' (quotCompMap R ğ’œ rel)) a) i := by
  simp only [lmap'_apply]
  congr
  exact hğ’œ.right_inv a

theorem quotDecompose'_surjective [hğ’œ : GradedAlgebra ğ’œ] :
    Surjective (quotDecompose' R ğ’œ rel) := by
  intro x
  obtain âŸ¨a, rflâŸ© := RingQuot.mkAlgHom_surjective R rel x
  let e : (coeLinearMap ğ’œ) ((decomposeAlgEquiv ğ’œ).toLinearMap a) = a :=
    hğ’œ.left_inv a
  use (lmap' (quotCompMap R ğ’œ rel)) ((decomposeAlgEquiv ğ’œ).toLinearMap a)
  conv_rhs => rw [â† e]
  apply quotDecompose_left_inv'_aux_apply

lemma obvious_iff {x y : A} :
    RingQuot.mkRingHom rel x = RingQuot.mkRingHom rel y â†” RingConGen.Rel rel x y := by
  constructor
  . intro h
    suffices âˆ€ x, Quot.mk (RingQuot.Rel rel) x = ((RingQuot.mkRingHom rel) x).toQuot by
      rw [â† RingQuot.eqvGen_rel_eq, â† Quot.eq, this x, this y, h]
    intro x
    simp only [RingQuot.mkRingHom]
    rfl
  . intro h
    induction h with
    | of x y h => exact RingQuot.mkRingHom_rel h
    | refl x => exact rfl
    | symm _ k => exact k.symm
    | trans h h' k k' => rw [k, k']
    | add _ _ k k' => simp only [map_add, k, k']
    | mul _ _ k k' => simp only [map_mul, k, k']


theorem quotDecompose_injective [hğ’œ : GradedAlgebra ğ’œ]
    (hrel : Rel.IsHomogeneous ğ’œ rel) {x y : A}
    (hxy : RingQuot.mkAlgHom R rel x = RingQuot.mkAlgHom R rel y) (i : Î¹) :
    RingQuot.mkAlgHom R rel (hğ’œ.decompose' x i) = RingQuot.mkAlgHom R rel (hğ’œ.decompose' y i) := by
  rw [â† AlgHom.coe_toRingHom, RingQuot.mkAlgHom_coe R rel, obvious_iff] at hxy âŠ¢
  exact RingConGen.Rel.isHomogeneous_of ğ’œ _ hrel hxy i

end AddMonoid

theorem quotDecompose_surjective2 : Surjective (lmap' (quotCompMap R ğ’œ rel)) := by
  apply lmap'_surjective (quotCompMap R ğ’œ rel)
  rintro i âŸ¨x, âŸ¨a, ha, rflâŸ©âŸ©
  exact âŸ¨âŸ¨a, haâŸ©, rflâŸ©

variable [AddMonoid Î¹]

theorem quotDecompose'_injective [hğ’œ : GradedAlgebra ğ’œ]
    (hrel : Rel.IsHomogeneous ğ’œ rel) : Injective (quotDecompose' R ğ’œ rel) := by
  intro x y hxy
  obtain âŸ¨a, ha, rflâŸ© := quotDecompose_surjective2 ğ’œ rel x
  obtain âŸ¨b, hb, rflâŸ© := quotDecompose_surjective2 ğ’œ rel y
  simp only [quotDecompose'_apply] at hxy
  let hxy' := quotDecompose_injective ğ’œ rel hrel hxy
  apply DFinsupp.ext
  intro i
  specialize hxy' i
  simp only [Decomposition.decompose'_eq] at hxy'
  suffices âˆ€ a, RingQuot.mkAlgHom R rel â†‘(((decompose fun i => ğ’œ i)
      ((coeLinearMap fun i => ğ’œ i) a)) i) = ((lmap' (quotCompMap R ğ’œ rel)) a) i by
    simpa only [this, SetLike.coe_eq_coe] using hxy'
  intro a
  simp only [lmap'_apply]
  congr
  exact hğ’œ.right_inv a

theorem quotDecompose_injective' [hğ’œ : GradedAlgebra ğ’œ]
    (hrel : Rel.IsHomogeneous ğ’œ rel) :
    Injective (coeLinearMap (fun i => (ğ’œ i).map (RingQuot.mkAlgHom R rel))) := by
  have hÏ† : âˆ€ i, Surjective (quotCompMap R ğ’œ rel i) := by
    rintro i âŸ¨x, âŸ¨a, ha, rflâŸ© âŸ©
    exact âŸ¨âŸ¨a, haâŸ©, rflâŸ©
  intro x y hxy
  obtain âŸ¨a, ha, rflâŸ© := lmap'_surjective (quotCompMap R ğ’œ rel) hÏ† x
  obtain âŸ¨b, hb, rflâŸ© := lmap'_surjective (quotCompMap R ğ’œ rel) hÏ† y
  simp only [quotDecompose_left_inv'_aux_apply] at hxy
  let hxy' := quotDecompose_injective ğ’œ rel hrel hxy
  apply DFinsupp.ext
  intro i
  specialize hxy' i
  simp only [Decomposition.decompose'_eq] at hxy'
  simpa only [lmap'_quotCompMap_apply, SetLike.coe_eq_coe] using hxy'

lemma quotDecompose'_bijective [GradedAlgebra ğ’œ]
    (hrel : Rel.IsHomogeneous ğ’œ rel) : Bijective (quotDecompose' R ğ’œ rel) :=
  âŸ¨quotDecompose_injective' ğ’œ rel hrel, quotDecompose'_surjective ğ’œ relâŸ©

/-- The decomposition of the quotient ring is an internal direct sum -/
lemma quotDecomposition_IsInternal [GradedAlgebra ğ’œ]
    (hrel : Rel.IsHomogeneous ğ’œ rel) : IsInternal (quotSubmodule R ğ’œ rel) :=
  quotDecompose'_bijective ğ’œ rel hrel

/-- The decomposition of `RingQuot rel` as a direct sum of its graded pieces. -/
noncomputable def quotDecomposition [GradedAlgebra ğ’œ]
    (hrel : Rel.IsHomogeneous ğ’œ rel) : Decomposition (quotSubmodule R ğ’œ rel) :=
  { decompose' := invFun (quotDecompose' R ğ’œ rel)
    left_inv   := rightInverse_invFun (quotDecompose'_surjective ğ’œ rel)
    right_inv  := leftInverse_invFun (quotDecompose_injective' ğ’œ rel hrel) }

/-- The graded algebra structure on `RingQuot rel`. -/
noncomputable def quotGradedAlgebra [GradedAlgebra ğ’œ]
    (hrel : Rel.IsHomogeneous ğ’œ rel) : GradedAlgebra (quotSubmodule R ğ’œ rel) :=
  { toGradedMonoid  := SetLike.GradedMonoid_RingQuot ğ’œ rel
    toDecomposition := quotDecomposition ğ’œ rel hrel }

end Rel

section Ideal

variable (R : Type*) [CommRing R] {Î¹ A : Type*} [CommRing A] [Algebra R A]
  (ğ’œ : Î¹ â†’ Submodule R A) (I : Ideal A)

/-- The graded pieces of A â§¸ I -/
def Ideal.quotSubmodule : Î¹ â†’ Submodule R (A â§¸ I) :=
  fun i => Submodule.map (Ideal.Quotient.mkâ‚ R I) (ğ’œ i)

theorem Ideal.mem_quotSubmodule_iff (i : Î¹) (g : A â§¸ I) :
    g âˆˆ I.quotSubmodule R ğ’œ i â†” âˆƒ a âˆˆ ğ’œ i, Ideal.Quotient.mk I a = g := by
  rw [Ideal.quotSubmodule, Submodule.mem_map, Ideal.Quotient.mkâ‚_eq_mk]

/-- The canonical LinearMap from the graded pieces of `A` to those of `A/I` -/
def Ideal.quotCompMap (i : Î¹) : â†¥(ğ’œ i) â†’â‚—[R] â†¥(quotSubmodule R ğ’œ I i) := {
  toFun := fun u â†¦ âŸ¨Ideal.Quotient.mkâ‚ R I â†‘u, by
      rw [quotSubmodule, Submodule.mem_map]; exact âŸ¨â†‘u, u.prop, rflâŸ©âŸ©
  map_add' := fun u v â†¦ by
    simp only [Submodule.coe_add, map_add, Quotient.mkâ‚_eq_mk, AddMemClass.mk_add_mk]
  map_smul' := fun r u â†¦ by
    simp only [SetLike.val_smul, map_smul, Ideal.Quotient.mkâ‚_eq_mk, RingHom.id_apply]; rfl }

variable [DecidableEq Î¹] [AddMonoid Î¹]

/-- The decomposition at the higher level -/
def Ideal.quotDecomposeLaux [GradedAlgebra ğ’œ] :
    A â†’â‚—[R] DirectSum Î¹ fun i : Î¹ => (I.quotSubmodule R ğ’œ i) :=
  LinearMap.comp (lmap' (I.quotCompMap R ğ’œ)) (decomposeAlgEquiv ğ’œ).toLinearMap

theorem Ideal.quotDecomposeLaux_of_mem_eq_zero [GradedAlgebra ğ’œ] (hI : I.IsHomogeneous ğ’œ) {x : A}
    (hx : x âˆˆ I) (i : Î¹) : ((I.quotDecomposeLaux R ğ’œ) x) i = 0 := by
  rw [Ideal.quotDecomposeLaux, LinearMap.comp_apply, lmap'_apply, quotCompMap]
  simp only [Ideal.Quotient.mkâ‚_eq_mk, AlgEquiv.toLinearMap_apply, decomposeAlgEquiv_apply,
    LinearMap.coe_mk, AddHom.coe_mk, Submodule.mk_eq_zero]
  rw [Ideal.Quotient.eq_zero_iff_mem]
  exact hI i hx

theorem Ideal.quotDecomposeLaux_ker [GradedAlgebra ğ’œ] (hI : I.IsHomogeneous ğ’œ) :
    I.restrictScalars R â‰¤ LinearMap.ker (I.quotDecomposeLaux R ğ’œ) :=
  fun _ hx =>  LinearMap.mem_ker.mpr (DFinsupp.ext (I.quotDecomposeLaux_of_mem_eq_zero R ğ’œ hI hx))

/-- The `R`-linear map from `A/I` to the direct sum of its graded components. -/
def Ideal.quotDecompose [GradedAlgebra ğ’œ] (hI : I.IsHomogeneous ğ’œ) :
    A â§¸ I â†’â‚—[R] DirectSum Î¹ fun i : Î¹ => (I.quotSubmodule R ğ’œ i) := by
  apply @Submodule.liftQ R A _ _ _ (I.restrictScalars R) R
    (DirectSum Î¹ fun i => I.quotSubmodule R ğ’œ i)
    _ _ _ (RingHom.id R) (quotDecomposeLaux R ğ’œ I)
  apply I.quotDecomposeLaux_ker R ğ’œ hI

theorem Ideal.quotDecomposeLaux_apply_mk [GradedAlgebra ğ’œ] (hI : I.IsHomogeneous ğ’œ) (a : A) :
    I.quotDecompose R ğ’œ hI (Ideal.Quotient.mk I a) = I.quotDecomposeLaux R ğ’œ a :=
  Submodule.liftQ_apply (I.restrictScalars R) (quotDecomposeLaux R ğ’œ I) a

private theorem Ideal.quotDecomposition_left_inv'_aux [GradedAlgebra ğ’œ] :
  LinearMap.comp (coeLinearMap (Ideal.quotSubmodule R ğ’œ I)) (lmap' (Ideal.quotCompMap R ğ’œ I)) =
    LinearMap.comp (Submodule.mkQ (Submodule.restrictScalars R I)) (coeLinearMap ğ’œ) := by
  apply linearMap_ext
  intro i
  ext x
  dsimp only [LinearMap.coe_comp, comp_apply]
  change _ = (Submodule.mkQ (Submodule.restrictScalars R I)) (_)
  rw [lmap'_lof]
  simp only [lof_eq_of, coeLinearMap_of, Submodule.mkQ_apply]
  rfl

theorem Ideal.quotDecomposition_left_inv' [hğ’œ : GradedAlgebra ğ’œ] (hI : I.IsHomogeneous ğ’œ) :
    LeftInverse (coeLinearMap (I.quotSubmodule R ğ’œ)) (I.quotDecompose R ğ’œ hI) := by
  intro x
  obtain âŸ¨(a : A), rflâŸ© := Ideal.Quotient.mk_surjective x
  conv_lhs =>
    rw [quotDecomposeLaux_apply_mk, quotDecomposeLaux, LinearMap.comp_apply]
    simp only [AlgEquiv.toLinearMap_apply, â† LinearMap.comp_apply]
  rw [Ideal.quotDecomposition_left_inv'_aux]
  conv_rhs =>
    rw [â† hğ’œ.left_inv a]
    simp only [â† LinearMap.comp_apply]
  rfl

theorem Ideal.quotDecomposition_left_inv [GradedAlgebra ğ’œ] (hI : I.IsHomogeneous ğ’œ) :
    LeftInverse (DirectSum.coeAddMonoidHom (I.quotSubmodule R ğ’œ)) (I.quotDecompose R ğ’œ hI) :=
  I.quotDecomposition_left_inv' R ğ’œ hI

theorem Ideal.quotDecomposition_right_inv' [GradedAlgebra ğ’œ] (hI : I.IsHomogeneous ğ’œ) :
    RightInverse (coeLinearMap (I.quotSubmodule R ğ’œ)) (I.quotDecompose R ğ’œ hI) := by
  rw [rightInverse_iff_comp, â† LinearMap.coe_comp, â† @LinearMap.id_coe R]
  apply congr_arg
  apply linearMap_ext
  intro i
  ext1 y
  obtain âŸ¨x, hx, hxyâŸ© := y.prop
  simp only [LinearMap.coe_comp, comp_apply, LinearMap.id_comp, lof_eq_of, coeLinearMap_of]
  rw [â† hxy, Ideal.Quotient.mkâ‚_eq_mk, Ideal.quotDecomposeLaux_apply_mk, Ideal.quotDecomposeLaux]
  simp only [LinearMap.coe_comp, comp_apply]
  change lmap' _ (decompose ğ’œ x) = _
  suffices decompose ğ’œ x = lof R Î¹ (fun i => ğ’œ i) i (âŸ¨x, hxâŸ© : ğ’œ i) by
    rw [this, lmap'_lof, lof_eq_of]
    apply congr_argâ‚‚ _ rfl
    rw [quotCompMap]
    simp only [Ideal.Quotient.mkâ‚_eq_mk, LinearMap.coe_mk]
    rw [â† Subtype.coe_inj, Subtype.coe_mk, â† hxy]
    simp only [Ideal.Quotient.mkâ‚_eq_mk]
    rfl
  conv_lhs => rw [â† Subtype.coe_mk x hx]
  rw [decompose_coe, lof_eq_of]

theorem Ideal.quotDecomposition_right_inv [GradedAlgebra ğ’œ] (hI : I.IsHomogeneous ğ’œ) :
    RightInverse (DirectSum.coeAddMonoidHom (I.quotSubmodule R ğ’œ)) (I.quotDecompose R ğ’œ hI) :=
  I.quotDecomposition_right_inv' R ğ’œ hI

/-- The decomposition of `A/I` as the direct sum of its graded components. -/
def Ideal.quotDecomposition [GradedAlgebra ğ’œ] (hI : I.IsHomogeneous ğ’œ) :
    Decomposition (I.quotSubmodule R ğ’œ) := {
  decompose' := I.quotDecompose R ğ’œ hI
  left_inv   := I.quotDecomposition_left_inv R ğ’œ hI
  right_inv  := I.quotDecomposition_right_inv R ğ’œ hI }

/-- The quotient of a graded algebra by a homogeneous ideal, as a graded algebra -/
def Ideal.gradedQuotAlg [GradedAlgebra ğ’œ] (hI : I.IsHomogeneous ğ’œ) :
  GradedAlgebra (I.quotSubmodule R ğ’œ) := {
  toDecomposition := I.quotDecomposition R ğ’œ hI
  toGradedMonoid :=
    { one_mem := by
        rw [Ideal.quotSubmodule, Submodule.mem_map]
        exact âŸ¨1, SetLike.one_mem_graded ğ’œ, rflâŸ©
      mul_mem := fun i j gi gj hgi hgj => by
        obtain âŸ¨ai, hai, rflâŸ© := hgi
        obtain âŸ¨aj, haj, rflâŸ© := hgj
        exact âŸ¨ai * aj, âŸ¨SetLike.mul_mem_graded hai haj, _root_.map_mul _ _ _âŸ©âŸ© }}

end Ideal

end GradedQuot
