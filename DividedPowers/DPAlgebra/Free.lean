/-
Copyright (c) 2024 Antoine Chambert-Loir, María Inés de Frutos-Fernández. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir, María Inés de Frutos-Fernández
-/
import DividedPowers.DPAlgebra.BaseChange
import DividedPowers.DPAlgebra.Graded.Basic
import DividedPowers.DPAlgebra.Graded.GradeZero
import DividedPowers.ForMathlib.RingTheory.TensorProduct.DirectLimit.FG
import DividedPowers.ForMathlib.Data.FinsetLemmas
import Mathlib.LinearAlgebra.FreeModule.Basic
import Mathlib.RingTheory.DividedPowers.RatAlgebra
import DividedPowers.ForMathlib.RingTheory.DividedPowers.Basic
noncomputable section

open DividedPowers Finset Ideal Ideal.Quotient MvPolynomial RingQuot

namespace DividedPowerAlgebra

universe u v v₁ v₂ w uA uR uS uM

section Int

open Module

-- Proving that the if `M` is generated by elements `v i`, then `DividedPowerAlgebra R M`
-- is generated by corresponding finite products ∏ dp R (k i) (v i).
example (R M : Type*) [CommRing R] [AddCommGroup M] [Module R M]
    {ι : Type*} (v : ι → M) (hv : Submodule.span R (Set.range v) = ⊤) :
    Submodule.span R (Set.range (fun (n : Finsupp ι ℕ) ↦ n.prod fun i k ↦ dp R k (v i) )) = ⊤ := by
  classical
  rw [eq_top_iff]
  intro p _
  induction p using DividedPowerAlgebra.induction_on with
  | h_C r =>
    simp only [algHom_C, Algebra.algebraMap_eq_smul_one]
    exact Submodule.smul_mem _ _ (Submodule.subset_span ⟨0, by simp⟩)
  | h_add x y hx hy =>
    exact Submodule.add_mem _ (hx Submodule.mem_top) (hy Submodule.mem_top)
  | h_dp x k m hx =>
    have hm : m ∈ Submodule.span R (Set.range v) := by
      simp [hv, Submodule.mem_top]

    rw [Submodule.mem_span_iff_exists_finset_subset] at hm
    obtain ⟨c, s, hs, hc, rfl⟩ := hm
    rw [dp_sum_smul, mul_sum]
    apply Submodule.sum_mem
    intro d hd
    simp only [Algebra.mul_smul_comm]
    apply Submodule.smul_mem
    specialize hx Submodule.mem_top
    rw [Submodule.mem_span_iff_exists_finset_subset] at hx
    obtain ⟨e, t, ht, he, rfl⟩ := hx
    rw [sum_mul]
    apply Submodule.sum_mem
    intro y hy
    simp only [Algebra.smul_mul_assoc]
    apply Submodule.smul_mem
    apply ht at hy
    simp only [Set.mem_range] at hy
    obtain ⟨u, rfl⟩ := hy
    sorry

-- TODO: rename
/-- The basis of the nth graded part of `DividedPowerAlgebra ℤ M` associated with a basis of `M`,
  where `M` is generated by a single element. -/
noncomputable def Int.basis_grade (M : Type v) [AddCommGroup M] (b : Basis Unit ℤ M) (n : ℕ) :
    Basis Unit ℤ (grade ℤ  M n) := by
  classical
  set v : Unit → grade ℤ  M n := fun _ ↦ ⟨dp ℤ n (b ()), dp_mem_grade ℤ M n (b ())⟩
  apply Basis.mk (v := v)
  · simp only [LinearIndependent, ← LinearMapClass.ker_eq_bot, Submodule.eq_bot_iff]
    intro x hx
    suffices x PUnit.unit = 0 by exact Finsupp.ext fun _ ↦ this
    apply Or.resolve_right ?_ (Nat.factorial_ne_zero n)
    let φ : DividedPowerAlgebra ℤ M →ₐ[ℤ] ℚ :=
      DividedPowerAlgebra.lift (RatAlgebra.dividedPowers ⊤) (b.constr ℤ fun _ ↦ 1) (by simp)
    suffices x PUnit.unit = 0 ∨ φ (dp ℤ n (b ())) = 0 by
      simpa [φ] using this
    suffices x PUnit.unit • dp ℤ n (b ()) = 0 by
      simpa using congrArg φ this
    simp only [LinearMap.mem_ker, Finsupp.linearCombination_apply] at hx
    simpa [Finsupp.sum_fintype, v] using hx
  · intro x _
    obtain ⟨p, hp, hpx⟩ := (mem_grade_iff _ _ _ _).mp x.2
    rw [mem_weightedHomogeneousSubmodule] at hp
    simp only [IsWeightedHomogeneous, ne_eq] at hp
    have hv : Set.range v = {v ()} := by simp
    rw [hv, Submodule.mem_span_singleton]
    -- I am not sure if I set up the lemma in the easiest way to conclude this
    sorry

end Int

variable (R : Type u) [CommRing R] (M : Type v) [AddCommGroup M] [Module R M] (x : M) {n : ℕ}
  (N : Type w) [AddCommGroup N] [Module R N]

namespace Free

open Module TensorProduct

example (R M N : Type*) [CommSemiring R] [AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]
    (f : M ≃ₗ[R] N) :
    DividedPowerAlgebra R M ≃ₐ[R] DividedPowerAlgebra R N := by
  exact LinearEquiv.lift f

-- Prop. A2.1
noncomputable example : R ⊗[ℤ] DividedPowerAlgebra ℤ M ≃ₐ[R] DividedPowerAlgebra R (R ⊗[ℤ] M) :=
  DividedPowerAlgebra.dpScalarExtensionEquiv ℤ R M

-- In particular:



example (P Q : {P : Submodule R M // P.FG}) (h : P ≤ Q) :
    DividedPowerAlgebra R P →ₐ[R] DividedPowerAlgebra R Q :=
  LinearMap.lift _ (Submodule.inclusion h)

-- Prop A2.2 (Also see Submodules_fg_equiv)
def directLimit [DecidableEq {P : Submodule R M // P.FG}] :
  DividedPowerAlgebra R (Module.DirectLimit (ι := {P : Submodule R M // P.FG})
      (G := fun P ↦ P.val) (fun ⦃P Q⦄ (h : P ≤ Q) ↦ Submodule.inclusion h)) ≃ₗ[R]
  Module.DirectLimit (ι := {P : Submodule R M // P.FG})
    (fun P ↦ DividedPowerAlgebra R P) (fun ⦃P Q⦄ (h : P ≤ Q) ↦
      (LinearMap.lift _ (Submodule.inclusion h)).toLinearMap) := sorry

example [DecidableEq {P : Submodule R M // P.FG}]: DividedPowerAlgebra R M ≃ₐ[R]
    DividedPowerAlgebra R (Module.DirectLimit (ι := {P : Submodule R M // P.FG})
      (G := fun P ↦ P.val) (fun ⦃P Q⦄ (h : P ≤ Q) ↦ Submodule.inclusion h)) :=
  LinearEquiv.lift (Submodules_fg_equiv R M).symm

def directLimit_of_fg_submodules [DecidableEq {P : Submodule R M // P.FG}] :
    DividedPowerAlgebra R M ≃ₗ[R] Module.DirectLimit (ι := {P : Submodule R M // P.FG})
      (fun P ↦ DividedPowerAlgebra R P)
      (fun ⦃P Q⦄ (h : P ≤ Q) ↦ (LinearMap.lift _ (Submodule.inclusion h)).toLinearMap) :=
  (LinearEquiv.lift (Submodules_fg_equiv R M).symm).toLinearEquiv.trans (directLimit R M)

-- TODO: rename these

private def aux0 : M × N →ₗ[R] M ⊗[R] DividedPowerAlgebra R N where
  toFun x       := x.1 ⊗ₜ 1
  map_add' _ _  := by simp [add_tmul]
  map_smul' _ _ := by simp [smul_tmul]

private lemma aux0_apply (mn : M × N) : aux0 R M N mn = mn.1 ⊗ₜ 1 := rfl

private def aux1 :
    DividedPowerAlgebra R (M × N) →ₐ[R]
      DividedPowerAlgebra R (M ⊗[R] DividedPowerAlgebra R N) :=
  LinearMap.lift R (aux0 R M N)

private lemma aux1_apply_dp (mn : M × N) (p : ℕ) :
    aux1 R M N (dp R p mn) = dp R p (mn.1 ⊗ₜ 1) := by
  simp [aux1, LinearMap.lift_apply_dp, aux0_apply]

example : DividedPowerAlgebra R (M ⊗[R] DividedPowerAlgebra R N) →ₐ[R]
    DividedPowerAlgebra R (DividedPowerAlgebra R N ⊗[R] M) :=
  LinearMap.lift R (TensorProduct.comm R M (DividedPowerAlgebra R N)).toLinearMap

private def aux2 :
    DividedPowerAlgebra R (M × N) →ₐ[R]
      DividedPowerAlgebra R M ⊗[R] DividedPowerAlgebra R N :=
  (((Algebra.TensorProduct.comm R (DividedPowerAlgebra R N) (DividedPowerAlgebra R M)).toAlgHom.comp
    (((dpScalarExtensionInv R (DividedPowerAlgebra R N) M).restrictScalars R).comp
      (LinearMap.lift (DividedPowerAlgebra R N) LinearMap.id))).comp
        (LinearMap.lift R (TensorProduct.comm R M
          (DividedPowerAlgebra R N)).toLinearMap)).comp (aux1 R M N)

private lemma aux2_apply_dp (mn : M × N) (p : ℕ) :
    aux2 R M N (dp R p mn) = dp R p mn.1 ⊗ₜ 1 := by
  simp [aux2, aux1_apply_dp, LinearMap.lift_apply_dp,
    dpScalarExtensionInv_apply_dp]

private def aux_prod_algHom_left :
    (M × N →ₗ[R]
      ↥(PowerSeries.ExponentialModule (DividedPowerAlgebra R M ⊗[R] DividedPowerAlgebra R N))) :=
  exponentialModule_equiv R (M × N) _ (aux2 R M N)

private def aux0' : M × N →ₗ[R] DividedPowerAlgebra R M ⊗[R] N where
  toFun x       := 1 ⊗ₜ x.2
  map_add' _ _  := by simp [tmul_add]
  map_smul' _ _ := by simp

private lemma aux0'_apply (mn : M × N) : aux0' R M N mn = 1 ⊗ₜ mn.2 := rfl

private def aux3 :
    DividedPowerAlgebra R (M × N) →ₐ[R]
      DividedPowerAlgebra R (DividedPowerAlgebra R M ⊗[R] N) :=
  LinearMap.lift R (aux0' R M N)

private lemma aux3_apply_dp (mn : M × N) (p : ℕ) :
    aux3 R M N (dp R p mn) = dp R p (1 ⊗ₜ mn.2) := by
  simp [aux3, LinearMap.lift_apply_dp, aux0'_apply]

private def aux4 :
    DividedPowerAlgebra R (M × N) →ₐ[R]
      DividedPowerAlgebra R M ⊗[R] DividedPowerAlgebra R N :=
  (((dpScalarExtensionInv R (DividedPowerAlgebra R M) N).restrictScalars R).comp
    (LinearMap.lift (DividedPowerAlgebra R M) LinearMap.id)).comp (aux3 R M N)

private lemma aux4_apply_dp (mn : M × N) (p : ℕ) :
    aux4 R M N (dp R p mn) = 1 ⊗ₜ dp R p mn.2 := by
  simp [aux4, aux3_apply_dp, LinearMap.lift_apply_dp,
    dpScalarExtensionInv_apply_dp]

private def aux_prod_algHom_right :
    (M × N →ₗ[R]
      ↥(PowerSeries.ExponentialModule (DividedPowerAlgebra R M ⊗[R] DividedPowerAlgebra R N))) :=
  exponentialModule_equiv R (M × N) _ (aux4 R M N)

private def aux_prod_algHom :
    (M × N →ₗ[R]
      (PowerSeries.ExponentialModule (DividedPowerAlgebra R M ⊗[R] DividedPowerAlgebra R N))) :=
  aux_prod_algHom_left R M N + aux_prod_algHom_right R M N

variable {M N}

def foo (m : M) :
    (PowerSeries.ExponentialModule
      (DividedPowerAlgebra R M ⊗[R] DividedPowerAlgebra R N)) where
  val := Additive.ofMul (PowerSeries.mk (fun p ↦ dp R p m ⊗ₜ 1))
  property := by
    simp only [PowerSeries.mem_exponentialModule_iff', toMul_ofMul,
      PowerSeries.isExponential_iff]
    refine ⟨?_, ?_⟩
    · intro p q
      simp only [PowerSeries.coeff_mk, Algebra.TensorProduct.tmul_mul_tmul, mul_one]
      rw [dp_mul, ← nsmul_eq_mul]
      rfl -- Missing lemma?
    · simp only [PowerSeries.constantCoeff_mk, dp_zero]
      rfl -- Missing lemma?

lemma PowerSeries.coeff_ofMul {R : Type*} [Semiring R] (n : ℕ) (f : PowerSeries R) :
  PowerSeries.coeff n (Additive.ofMul f) = PowerSeries.coeff n f := rfl

private lemma aux_prod_algHom_left_apply (m : M) (n : N) :
    (aux_prod_algHom_left R M N (m, n)) =
      ⟨Additive.ofMul (PowerSeries.mk (fun p ↦ dp R p m ⊗ₜ 1)), by
      simp only [PowerSeries.mem_exponentialModule_iff', toMul_ofMul,
        PowerSeries.isExponential_iff]
      refine ⟨?_, ?_⟩
      · intro p q
        simp only [PowerSeries.coeff_mk, Algebra.TensorProduct.tmul_mul_tmul, mul_one]
        rw [dp_mul, ← nsmul_eq_mul]
        rfl -- Missing lemma?
      · simp only [PowerSeries.constantCoeff_mk, dp_zero]
        -- Missing lemma?
        rfl⟩ := by
  rw [← PowerSeries.ExponentialModule.coe_inj]
  simp only [PowerSeries.ExponentialModule.coe_mk]
  simp only [aux_prod_algHom_left, exponentialModule_equiv_apply, LinearMap.coe_comp,
    Function.comp_apply]
  ext p
  --rw [PowerSeries.coeff_ofMul] Does not work
  -- This is abusing defeq
  have : (PowerSeries.coeff p) (Additive.ofMul
    (PowerSeries.mk fun p ↦ dp R p m ⊗ₜ[R] (1 : DividedPowerAlgebra R N))) =
    (PowerSeries.coeff p) (PowerSeries.mk fun p ↦ dp R p m ⊗ₜ[R] 1) := rfl
  erw [this]
  rw [PowerSeries.coeff_mk, PowerSeries.ExponentialModule.coeff_linearMap
    (S := DividedPowerAlgebra R M ⊗[R] DividedPowerAlgebra R N) (aux2 R M N) p]
  simp [exp_LinearMap, coeff_exp, aux2_apply_dp]

-- TODO: Finish as in lemma above
private lemma aux_prod_algHom_right_apply (m : M) (n : N) :
    (aux_prod_algHom_right R M N (m, n)) =
      ⟨Additive.toMul (PowerSeries.mk (fun q ↦ 1 ⊗ₜ dp R q n)), by sorry⟩ := by
  ext p
  sorry
  /- simp only [aux_prod_algHom_right, exponentialModule_equiv_apply, LinearMap.coe_comp,
    Function.comp_apply, PowerSeries.ExponentialModule.coe_mk, PowerSeries.coeff_mk]
  rw [PowerSeries.ExponentialModule.coeff_linearMap
    (S := DividedPowerAlgebra R M ⊗[R] DividedPowerAlgebra R N) (aux4 R M N) p]
  simp [exp_LinearMap, coeff_exp, aux4_apply_dp] -/

-- TODO: Finish as in lemma above
private lemma aux_prod_algHom_apply (mn : M × N) :
    (aux_prod_algHom R M N mn) =
      ⟨Additive.toMul PowerSeries.mk (fun p ↦ ∑ k ∈ antidiagonal p, dp R k.1 mn.1 ⊗ₜ dp R k.2 mn.2),
        by sorry⟩ := by
  ext1
  simp only [aux_prod_algHom, LinearMap.add_apply, aux_prod_algHom_left_apply,
    aux_prod_algHom_right_apply]
  rw [PowerSeries.ExponentialModule.coe_add]
  -- TODO: discuss this commented out code (it seems problematic)
  --simp only [AddSubmonoid.mk_add_mk, PowerSeries.ExponentialModule.coe_mk]
  simp only [PowerSeries.ExponentialModule.coe_mk]
  ext p
  sorry --simp [PowerSeries.coeff_mk, PowerSeries.coeff_mul]

variable (M N)

def prod_algHom :
    DividedPowerAlgebra R (M × N) →ₐ[R]
      DividedPowerAlgebra R M ⊗[R] DividedPowerAlgebra R N :=
  (exponentialModule_equiv R (M × N) _).symm (aux_prod_algHom R M N)

theorem prod_algHom_apply_dp (mn : M × N) (p : ℕ) :
    (prod_algHom R M N) (dp R p mn) =
      ∑ k ∈ antidiagonal p, (dp R k.1 mn.1) ⊗ₜ (dp R k.2 mn.2) := by
  simp only [prod_algHom, exponentialModule_equiv_symm_apply,
    aux_prod_algHom_apply]
  simp only [PowerSeries.ExponentialModule.coe_mk]
  calc (PowerSeries.coeff p) (Additive.toMul PowerSeries.mk fun p ↦
            ∑ k ∈ antidiagonal p, dp R k.1 mn.1 ⊗ₜ[R] dp R k.2 mn.2)
    _ = (PowerSeries.coeff p) (PowerSeries.mk fun p ↦
            ∑ k ∈ antidiagonal p, dp R k.1 mn.1 ⊗ₜ[R] dp R k.2 mn.2) := rfl
    _ = ∑ k ∈ antidiagonal p, dp R k.1 mn.1 ⊗ₜ[R] dp R k.2 mn.2 := by simp

def tensorProduct_algHom :
    DividedPowerAlgebra R M ⊗[R] DividedPowerAlgebra R N →ₐ[R]
      DividedPowerAlgebra R (M × N) :=
  Algebra.TensorProduct.lift (LinearMap.lift R (LinearMap.inl R M N))
    (LinearMap.lift R (LinearMap.inr R M N)) (fun _ _ ↦ Commute.all _ _)

variable {R M N}

theorem tensorProduct_algHom_apply_tmul (m : DividedPowerAlgebra R M)
    (n : DividedPowerAlgebra R N) :
    ((tensorProduct_algHom R M N) (m ⊗ₜ[R] n)) =
    (LinearMap.lift R (LinearMap.inl R M N)) m * (LinearMap.lift R (LinearMap.inr R M N)) n := by
  simp [tensorProduct_algHom]

theorem prod_algHom_comp_tensorProduct_algHom_apply_tmul_dp (m : M) (n : N) (p q : ℕ) :
    (prod_algHom R M N) ((tensorProduct_algHom R M N) ((dp R p m) ⊗ₜ[R] (dp R q n))) =
      (dp R p m) ⊗ₜ[R] (dp R q n) := by
  rw [tensorProduct_algHom_apply_tmul]
  simp only [LinearMap.lift_apply_dp, LinearMap.coe_inl, LinearMap.coe_inr, map_mul,
    prod_algHom_apply_dp]
  rw [Finset.sum_mul]
  simp_rw [Finset.mul_sum]
  simp only [Algebra.TensorProduct.tmul_mul_tmul]
  calc
    ∑ x ∈ antidiagonal p,
        ∑ i ∈ antidiagonal q, (dp R x.1 m * dp R i.1 0) ⊗ₜ[R] (dp R x.2 0 * dp R i.2 n)
    _ = ∑ i ∈ antidiagonal q, (dp R p m * dp R i.1 0) ⊗ₜ[R] (dp R 0 0 * dp R i.2 n) := by
      rw [Finset.sum_eq_single (p, 0) _ (by simp)]
      simp only [mem_antidiagonal, ne_eq, Prod.forall, Prod.mk.injEq, not_and_or]
      intro a b h h0
      have hb0 : b ≠ 0 := by aesop
      simp [dp_null_of_ne_zero R hb0]
    _ = (dp R p m * dp R 0 0) ⊗ₜ[R] (dp R 0 0 * dp R q n) := by
      rw [Finset.sum_eq_single (0, q) _ (by simp)]
      simp only [mem_antidiagonal, ne_eq, Prod.forall, Prod.mk.injEq, not_and_or]
      intro a b h h0
      have ha0 : a ≠ 0 := by aesop
      simp [dp_null_of_ne_zero R ha0]
    _ = dp R p m ⊗ₜ[R] dp R q n := by simp [dp_zero]

-- This seems too long, maybe I could simplify the h_C case
theorem prod_algHom_comp_tensorProduct_algHom_apply_tmul (m : DividedPowerAlgebra R M)
    (n : DividedPowerAlgebra R N) :
    (prod_algHom R M N) ((tensorProduct_algHom R M N) (m ⊗ₜ[R] n)) = m ⊗ₜ[R] n := by
  rw [tensorProduct_algHom_apply_tmul]
  induction m using DividedPowerAlgebra.induction_on with
  | h_C r =>
    induction n using DividedPowerAlgebra.induction_on with
    | h_C s =>
      simp only [algHom_C, AlgHom.commutes, map_mul, Algebra.TensorProduct.algebraMap_apply,
        Algebra.TensorProduct.tmul_mul_tmul, mul_one]
      rw [mul_comm, ← smul_eq_mul, algebraMap_smul, smul_tmul,
        ← algebraMap_smul (DividedPowerAlgebra R N), smul_eq_mul, mul_one]
    | h_add x y hx hy =>
      simp only [algHom_C, AlgHom.commutes, map_mul,
        Algebra.TensorProduct.algebraMap_apply] at hx hy ⊢
      simp [tmul_add, ← hx, ← hy, mul_add]
    | h_dp x p nm hx =>
      simp only [algHom_C, AlgHom.commutes, map_mul, Algebra.TensorProduct.algebraMap_apply] at hx ⊢
      rw [← mul_assoc, hx]
      simp only [LinearMap.lift_apply_dp, LinearMap.coe_inr, prod_algHom_apply_dp]
      calc (algebraMap R (DividedPowerAlgebra R M)) r ⊗ₜ[R] x *
          ∑ x ∈ antidiagonal p, dp R x.1 0 ⊗ₜ[R] dp R x.2 nm
        _ = (algebraMap R (DividedPowerAlgebra R M)) r ⊗ₜ[R] x * dp R 0 0 ⊗ₜ[R] dp R p nm := by
          congr 1
          rw [Finset.sum_eq_single (0, p) _ (by simp)]
          simp only [mem_antidiagonal, ne_eq, Prod.forall, Prod.mk.injEq, not_and_or]
          intro a b h h0
          have ha0 : a ≠ 0 := by aesop
          simp [dp_null_of_ne_zero R ha0]
        _ = (algebraMap R (DividedPowerAlgebra R M)) r ⊗ₜ[R] x * 1 ⊗ₜ[R] dp R p nm := by
          simp [dp_zero]
        _ = (algebraMap R (DividedPowerAlgebra R M)) r ⊗ₜ[R] (x * dp R p nm) := by simp
  | h_add x y hx hy => simp [add_tmul, ← hx, ← hy, add_mul]
  | h_dp x p nm hx =>
    simp only [map_mul] at hx ⊢
    rw [mul_assoc, mul_comm ((prod_algHom R M N)
      ((LinearMap.lift R (LinearMap.inl R M N)) (dp R p nm))), ← mul_assoc, hx]
    simp only [LinearMap.lift_apply_dp, LinearMap.coe_inl, prod_algHom_apply_dp]
    calc x ⊗ₜ[R] n * ∑ x ∈ antidiagonal p, dp R x.1 nm ⊗ₜ[R] dp R x.2 0
      _ = x ⊗ₜ[R] n * dp R p nm ⊗ₜ[R] dp R 0 0 := by
        -- TODO: there are several goals of this form, I should make a lemma
        congr 1
        rw [Finset.sum_eq_single (p, 0) _ (by simp)]
        simp only [mem_antidiagonal, ne_eq, Prod.forall, Prod.mk.injEq, not_and_or]
        intro a b h h0
        have hb0 : b ≠ 0 := by aesop
        simp [dp_null_of_ne_zero R hb0]
      _ = x ⊗ₜ[R] n * dp R p nm ⊗ₜ[R] 1 := by simp [dp_zero]
      _ = (x * dp R p nm) ⊗ₜ[R] n := by simp only [Algebra.TensorProduct.tmul_mul_tmul, mul_one]



theorem tensorProduct_algHom_comp_prod_algHom_apply_dp (p : ℕ) (nm : M × N) :
    (tensorProduct_algHom R M N) ((prod_algHom R M N) (dp R p nm)) = dp R p nm := by
  rw [prod_algHom_apply_dp]
  simp only [map_sum, tensorProduct_algHom_apply_tmul, LinearMap.lift_apply_dp,
    LinearMap.coe_inl, LinearMap.coe_inr]
  have : nm = (nm.1, 0) + (0, nm.2) := by simp
  conv_rhs => rw [this, dp_add]

variable (R M N)

-- Prop A2.3. This is proven in [Roby1963, theorem III.4]
def prod_algEquiv_tensorProduct :
    DividedPowerAlgebra R (M × N) ≃ₐ[R]
      DividedPowerAlgebra R M ⊗[R] DividedPowerAlgebra R N := by
  apply AlgEquiv.ofAlgHom (prod_algHom R M N) (tensorProduct_algHom R M N)
  · apply AlgHom.ext
    intro x
    induction x using TensorProduct.induction_on with
    | zero => simp
    | tmul m n  =>
      simp only [AlgHom.coe_comp, Function.comp_apply, AlgHom.coe_id, id_eq]
      exact prod_algHom_comp_tensorProduct_algHom_apply_tmul m n
    | add _ _ hx hy => simp only [AlgHom.coe_id, id_eq, map_add, hx, hy] -- faster than simp_all
  · apply AlgHom.ext
    intro x
    induction x using DividedPowerAlgebra.induction_on with
    | h_C => simp
    | h_add x y hx hy =>
      simp only [AlgHom.coe_comp, Function.comp_apply, AlgHom.coe_id, id_eq] at hx hy
      simp [hx, hy]
    | h_dp x p nm hx =>
      simp only [map_mul, hx, AlgHom.coe_id, id_eq, AlgHom.coe_comp, Function.comp_apply]
      congr 1
      exact tensorProduct_algHom_comp_prod_algHom_apply_dp p nm

/-- The basis of the nth graded part of `DividedPowerAlgebra R M` associated with a basis of `M`. -/
noncomputable def basis_grade {ι : Type*} (b : Basis ι R M) (n : ℕ) :
    Basis {d : ι →₀ ℕ // d.degree = n} R (grade R M n) := by
  apply Basis.mk (v := fun ⟨d, hd⟩ ↦
    ⟨d.prod (fun i k ↦ dp R k (b i)), by
      suffices n = d.sum (fun i k ↦ k) by
        simp only [this, Finsupp.sum, Finsupp.prod]
        exact SetLike.prod_mem_graded (grade R M) d
          (fun i ↦ dp R (d i) (b i)) (fun i _ ↦ dp_mem_grade R M (d i) (b i))
      simp only [← hd, Finsupp.degree, Finsupp.sum]⟩)
  · sorry
  · sorry

theorem free_grade [Module.Free R M] (n : ℕ) : Module.Free R (grade R M n) :=
  Module.Free.of_basis (basis_grade R M (Module.Free.chooseBasis R M) n)

/-- The basis of `DividedPowerAlgebra R M` associated with a basis of `M`. -/
noncomputable def basis {ι : Type*} (b : Basis ι R M) :
    Basis (ι →₀ ℕ) R (DividedPowerAlgebra R M) := by
  apply Basis.mk (v := fun d ↦ d.prod (fun i k ↦ dp R k (b i)))
  · rw [linearIndependent_iff]
    intro l hl

    sorry
  · intro x _
    induction x using DirectSum.Decomposition.inductionOn (grade R M) with
    | zero => simp
    | homogeneous =>
      classical
      rename_i n x _
      -- This have should be immediate...
      have : (x : DividedPowerAlgebra R M) ∈
        Submodule.span R (Set.range fun (r : { d : ι →₀ ℕ // d.degree = n }) ↦
          (r : ι →₀ ℕ).prod fun i k ↦ dp R k (b i)) := by
        have := Module.Basis.mem_span (basis_grade R M b n) x
        simp only [Submodule.mem_span_iff_exists_finset_subset] at this ⊢
        obtain ⟨f, t, hss, hsupp, hsum⟩ := this
        use fun x ↦ if hx : x ∈ grade R M n then f ⟨x, hx⟩ else 0,
          Finset.map ⟨Subtype.val, Subtype.val_injective⟩ t
        refine ⟨?_, ?_, by simp [← hsum]⟩
        · simp only [coe_map, Function.Embedding.coeFn_mk, Set.image_subset_iff]
          simp only [basis_grade, Basis.coe_mk] at hss
          apply le_trans hss
          intro x hx
          simp only [Set.mem_range, Subtype.exists] at hx
          obtain ⟨a, ha, rfl⟩ := hx
          simp only [Set.mem_preimage, Set.mem_range, Subtype.exists, exists_prop]
          use a, ha
        · intro a ha
          simp only [Function.support_subset_iff, ne_eq, mem_coe, Subtype.forall,
            Function.mem_support, dite_eq_right_iff, not_forall, coe_map,
            Function.Embedding.coeFn_mk, Set.mem_image, Subtype.exists, exists_and_right,
            exists_eq_right] at hsupp ha ⊢
          obtain ⟨ha, h⟩ := ha
          exact ⟨ha, hsupp a _ h⟩
      apply Set.mem_of_subset_of_mem _ this
      simp only [SetLike.coe_subset_coe]
      apply Submodule.span_mono
      intro x hx
      simp only [Set.mem_range, Subtype.exists, exists_prop] at hx ⊢
      obtain ⟨a, _, ha⟩ := hx
      exact ⟨a, ha⟩
    | add a b ha hb => simp_all [Submodule.add_mem]

theorem free [Module.Free R M] : Module.Free R (DividedPowerAlgebra R M) :=
  Module.Free.of_basis (basis R M (Module.Free.chooseBasis R M))

open Module

variable {R M} {ι : Type*} (b : Basis ι R M) {n : ℕ}

lemma basis_eq (d : ι →₀ ℕ) : basis R M b d = d.prod (fun i k ↦ dp R k (b i)) := by
  simp [basis, Basis.coe_mk]

lemma basis_eq' [DecidableEq ι] {m : M} {n : ℕ} {x : Sym ι n} (hx : x ∈ (b.repr m).support.sym n) :
    ∏ i ∈ (b.repr m).support, dp R (Multiset.count i ↑x) (b i) =
      basis R M b (Multiset.toFinsupp ↑x) := by
  rw [basis_eq, Finsupp.prod_of_support_subset (s := (b.repr m).support)]
  · exact Finset.prod_congr rfl (by simp)
  · intro i
    simp only [mem_sym_iff, Finsupp.mem_support_iff, ne_eq] at hx
    simpa using hx i
  · exact fun i _ ↦ dp_zero R (b i)

lemma basis_zero_eq_one : basis R M b 0 = 1 := by simp [basis_eq]

lemma basis_single_eq (i : ι) (n : ℕ) :
    basis R M b (Finsupp.single i n) = dp R n (b i) := by
  simp only [basis_eq]
  rw [Finsupp.prod_of_support_subset (s := {i}) _ Finsupp.support_single_subset]
  · simp [prod_singleton]
  · simp [dp_zero]

lemma basis_single_one_eq (i : ι) :
    basis R M b (Finsupp.single i 1) = DividedPowerAlgebra.ι R M (b i) := by
  rw [basis_single_eq, ι_def]

theorem basis_repr_ι (m : M) (d) [Decidable (∃ i, d = Finsupp.single i 1)] :
    (basis R M b).repr (DividedPowerAlgebra.ι R M m) d =
      if H : ∃ i, d = Finsupp.single i 1 then b.repr m H.choose else 0 := by
  have hm : m = ((b.repr m).sum fun i c ↦ c • b i) := by
    have := (Basis.linearCombination_repr b m).symm
    simpa only [Finsupp.linearCombination, Finsupp.lsum] using this
  conv_lhs => rw [hm]
  simp [map_finsuppSum]
  simp only [← basis_single_one_eq, Basis.repr_self]
  split_ifs with H
  · obtain ⟨i, rfl⟩ := id H
    rw [Finsupp.sum_eq_single i]
    · simp only [Finsupp.single_eq_same, mul_one]
      apply congr_arg
      rw [← Finsupp.single_left_inj Nat.one_ne_zero]
      exact H.choose_spec
    · intro j hj hji
      rw [ne_comm] at hji
      rw [Finsupp.single_eq_of_ne, mul_zero]
      rwa [ne_eq, Finsupp.single_left_inj Nat.one_ne_zero]
    · simp
  · convert Finsupp.sum_zero with i r
    rw [Finsupp.single_eq_of_ne, mul_zero]
    exact fun H' ↦ H ⟨i, H'⟩

theorem ι_repr_support_eq (m : M) :
    ((basis R M b).repr (DividedPowerAlgebra.ι R M m)).support =
      (b.repr m).support.map ⟨fun i ↦ Finsupp.single i 1, fun i j ↦ by
        simp [Finsupp.single_left_inj Nat.one_ne_zero]⟩ := by
  classical
  ext d
  rw [Finsupp.mem_support_iff, basis_repr_ι]
  split_ifs with H
  · obtain ⟨i, rfl⟩ := id H
    suffices H.choose = i by
      simp only [this, ne_eq, mem_map, Finsupp.mem_support_iff, Function.Embedding.coeFn_mk]
      constructor
      · intro H'
        exact ⟨i, H', rfl⟩
      · rintro ⟨j, hj, H'⟩
        simp_all [Finsupp.single_left_inj Nat.one_ne_zero]
    rw [← Finsupp.single_left_inj Nat.one_ne_zero, H.choose_spec.symm]
  · simp only [ne_eq, not_true_eq_false, mem_map, Finsupp.mem_support_iff,
    Function.Embedding.coeFn_mk, false_iff, not_exists, not_and]
    exact fun i hi hd ↦ H ⟨i, hd.symm⟩

theorem basis_mul (m n : ι →₀ ℕ) :
    basis R M b m * basis R M b n =
      ((m + n).prod fun i r ↦ r.choose (m i)) • basis R M b (m + n) := by
  simp only [basis_eq]
  set s := (m + n).support
  have hms : m.support ⊆ s := Finsupp.support_monotone le_self_add
  have hns : n.support ⊆ s := Finsupp.support_monotone le_add_self
  rw [Finsupp.prod_of_support_subset m hms _ (fun _ _ ↦ by simp [dp_zero]),
    Finsupp.prod_of_support_subset n hns _ (fun _ _ ↦ by simp [dp_zero])]
  simp only [Finsupp.prod, s, ← Finset.prod_mul_distrib, dp_mul, ← Finset.prod_smul']
  exact Finset.prod_congr rfl (fun  _ _ ↦ by simp)

/-
basis R M b f = ∏ i, (b i) ^[f i]

∏ a ∈ s, basis R M b (f a) = ∏ i, ∏ a, (b i)^[f a i]

Now, ∏ a, (b i)^[f a i] = ?? • (b i)^[∑ f a i] where ?? is some integer to be determined.
From the formal expressions (valid in a ℚ-algebra)
∏ a, (b i)^[f a i] = ∏ a, (b i) ^ (f a i) / (f a i)! and
(b i)^[∑ a, f a i] = (b i)^(∑ f a i) / (∑ f a i)!, we infer that
?? = Nat.multinomial s (fun a ↦ f a i)
-/

theorem basis_prod (α : Type*) (f : α → (ι →₀ ℕ)) (s : Finset α) :
    ∏ a ∈ s, basis R M b (f a) = ((∑ a ∈ s, f a).prod fun i _ ↦ Nat.multinomial s (fun a ↦ f a i)) •
      basis R M b (∑ a ∈ s, f a) := by
  classical
  induction s using Finset.induction with
  | empty => simp [basis_zero_eq_one]
  | @insert a s has hrec =>
    rw [Finset.prod_insert has, hrec, mul_smul_comm, basis_mul, ← Finset.sum_insert has]
    simp only [← smul_assoc]
    apply congr_arg₂ _ _ rfl
    have : (∑ x ∈ s, f x).support ⊆ (∑ x ∈ insert a s, f x).support := by
      apply Finsupp.support_monotone
      rw [Finset.sum_insert has]
      exact le_add_self
    simp only [Finsupp.prod]
    simp only [← Finset.prod_sdiff this]
    simp only [smul_eq_mul]
    rw [mul_left_comm]
    apply congr_arg₂
    · apply Finset.prod_congr rfl
      intro i hi
      simp only [mem_sdiff, Finsupp.mem_support_iff, Finsupp.coe_finset_sum, sum_apply, ne_eq,
        sum_eq_zero_iff, mem_insert, forall_eq_or_imp, not_and, not_forall, not_exists,
        not_not] at hi
      rw [Nat.multinomial_insert has]
      simp only [Finset.sum_insert has, Finsupp.coe_add, Finsupp.coe_finset_sum, Pi.add_apply,
        sum_apply]
      symm
      convert mul_one _
      rw [← Nat.mul_right_inj Nat.one_ne_zero, mul_one]
      convert Nat.multinomial_spec _ _
      · symm
        apply Finset.prod_eq_one
        intro x hx
        simp [hi.2 x hx]
      · symm
        convert Nat.factorial_zero
        apply Finset.sum_eq_zero
        intro x hx
        simp [hi.2 x hx]
    · rw [← Finset.prod_mul_distrib]
      apply Finset.prod_congr rfl
      intro i hi
      simp [Finset.sum_insert has, Nat.multinomial_insert has, mul_comm]

theorem basis_repr_mul [DecidableEq ι] (x y : DividedPowerAlgebra R M) (d : ι →₀ ℕ) :
    (basis R M b).repr (x * y) d =
      ∑ uv ∈ antidiagonal d, (d.prod fun a_1 b ↦ (b.choose (uv.1 a_1))) •
        ((basis R M b).repr x uv.1 * (basis R M b).repr y uv.2) := by
  have h (x : DividedPowerAlgebra R M) :
      x = (((basis R M b).repr x).sum fun i c ↦ c • (basis R M b) i) := by
    simpa only using (Basis.linearCombination_repr (basis R M b) x).symm
  conv_lhs => rw [h x, h y]
  simp only [Finsupp.sum, Finset.sum_mul, Finset.mul_sum, map_sum]
  rw [Finset.sum_comm]
  simp only [Algebra.mul_smul_comm, Algebra.smul_mul_assoc, map_smul, Finsupp.coe_finset_sum,
    Finsupp.coe_smul, sum_apply, Pi.smul_apply, smul_eq_mul]
  simp only [basis_mul, map_nsmul]
  rw [← Finset.sum_product']
  apply Finset.sum_congr_of_eq_on_inter
  · intro a ha ha'
    convert mul_zero _
    convert mul_zero _
    simp only [Finsupp.prod]
    simp only [Finsupp.coe_add, Pi.add_apply, Basis.repr_self, Finsupp.smul_single, nsmul_eq_mul,
      Nat.cast_prod, mul_one]
    rw [Finsupp.single_eq_of_ne]
    simp only [mem_antidiagonal] at ha'
    exact Ne.symm ha'
  · intro a ha' ha
    simp only [mem_product, Finsupp.notMem_support_iff, not_and_or] at ha
    rcases ha with ha | ha <;> simp [ha]
  · intro a ha ha'
    simp [mem_antidiagonal] at ha'
    simp only [ha', Basis.repr_self, Finsupp.smul_single, Finsupp.single_eq_same]
    ring

lemma basis_mem_augIdeal {d : ι →₀ ℕ} (hd : d ≠ 0) :
    basis R M b d ∈ augIdeal R M := by
  classical
  simp only [mem_augIdeal_iff, basis_eq, map_finsuppProd, algebraMapInv_dp]
  rw [Finsupp.prod]
  simp only [← Finsupp.support_nonempty_iff] at hd
  obtain ⟨_, hi⟩ := hd
  apply Finset.prod_eq_zero hi
  rw [if_neg (Finsupp.mem_support_iff.mp hi)]

lemma basis_mem_augIdeal_iff [Nontrivial R] (d : ι →₀ ℕ) :
    basis R M b d ∈ augIdeal R M ↔ d ≠ 0 := by
  refine ⟨?_, basis_mem_augIdeal b⟩
  rw [imp_not_comm]
  rintro ⟨rfl⟩
  rw [basis_zero_eq_one, mem_augIdeal_iff, map_one]
  exact one_ne_zero

lemma eq_of_basis (x : DividedPowerAlgebra R M) :
    x = ((basis R M b).repr x).sum fun i c ↦ c • (basis R M b) i := by
  conv_lhs => rw [← Basis.linearCombination_repr (basis R M b) x]
  simp [Finsupp.linearCombination, Finsupp.lsum]

lemma mem_augIdeal_iff_of_repr {x : DividedPowerAlgebra R M} :
    x ∈ augIdeal R M ↔ (basis R M b).repr x 0 = 0 := by
  classical
  have H : x = (((basis R M b).repr x).update 0 0).sum (fun i c ↦ c • (basis R M b) i) +
      (fun i c ↦ c • (basis R M b) i) 0 ((basis R M b).repr x 0) := by
    rw [Finsupp.sum_update_add _ _ _ (fun i c ↦ c • (basis R M b) i) (fun _ ↦ zero_smul R _)
      (fun _ _ _ ↦ add_smul _ _ _), zero_smul, add_zero]
    exact eq_of_basis b x
  have hx' : (((basis R M b).repr x).update 0 0).sum
      (fun i c ↦ c • (basis R M b) i) ∈ augIdeal R M := by
    apply Ideal.sum_mem
    intro c hc
    simp only [Finsupp.support_update_zero, mem_erase, ne_eq, Finsupp.mem_support_iff] at hc
    exact Submodule.smul_of_tower_mem (augIdeal R M) _ (basis_mem_augIdeal b hc.1)
  nth_rewrite 1 [H]
  rw [Submodule.add_mem_iff_right _ hx']
  simp [basis_zero_eq_one, mem_augIdeal_iff, map_smul, map_one, smul_eq_mul]

theorem ne_zero_of_mem_support_of_mem_augIdeal
    {x : DividedPowerAlgebra R M} (hx : x ∈ augIdeal R M) {d : ι →₀ ℕ}
    (hd : d ∈ ((basis R M b).repr x).support) : d ≠ 0 := by
  rintro ⟨rfl⟩
  rw [mem_augIdeal_iff_of_repr b] at hx
  rw [Finsupp.mem_support_iff] at hd
  exact hd hx

theorem eq_of_repr (x : DividedPowerAlgebra R M) :
    x = (((basis R M b).repr x).sum fun i r ↦ r • basis R M b i) := by
  simpa only [Finsupp.linearCombination, Finsupp.lsum] using
    (Basis.linearCombination_repr (basis R M b) x).symm

/- When `M` is free with basis `B` (it would suffice that `B` generates `M`,
then any `x : DividedPowerAlgebra R M` can be written as
 `x = (B.repr x).sum fun d c ↦ c • B d)` :
 `x = ∑ d ∈ (B.repr x).support, B.repr x d • B d`
If `x ∈ augIdeal R M`, then `B.repr x 0 = 0`, and all terms in this
representation belong to `augIdeal R M`.
By the multinomial formula for divided powers, one has
  `dpow n x
    = ∑ d ∈ (B.repr x).support.sym n,
        ∏ i ∈ (B.repr x).support, dpow (d.count i) ((B.repr x i) • B i)
    = ∑ d ∈ (B.repr x).support.sym n,
        ∏ i ∈ (B.repr x).support, (B.repr x i) ^ (d.count i) • dpow (d.count i d) (B i) `
Now, `B i = i.prod (fun j k ↦ dp R k (b j)) = ∏ j ∈ i.support, dp R (i j) (b j)`.
Here, `i ≠ 0`, because `i ∈ (B.repr x).support`.
Consequently, there exists `j` such that `j ∈ i.support`.
dpow m (∏ j ∈ i.support, dp R (i j) (b j))
 = dpow m (dp R (i j) (b j) * ∏ k ≠ j, dp R (i j) (b j))
 = m.uniformBell (i j) * dp (m + i j) (b j) * ∏ k ≠ j, (dp R (i j) (b j))) ^ m
 =  .. `

 dpow m (∏ i ∈ s, r i) =
 * s = ∅ : dpow m 1 = 1 if m = 0, else = 0 if 1 ∉ I
 * s ≠ ∅ : s = insert j t
    dpow m (r j * ∏ i ∈ t, r i) = dpow m (r j) * ∏ i ∈ t, r i ^ m
    r i ^ m = m! * dpow m (r i)
    = (m!)^(s.card -1) * ∏ i ∈ s, dpow m (r i)

 -/

open scoped Nat

/- Can one simplify the quantity
 n! ^ (#d.support - 1) * ∏ i ∈ d.support n.uniformBell (d i) ? -/
theorem dpow_basis_eq (H : DividedPowers (augIdeal R M))
    (hH : ∀ (n : ℕ) (x : M), H.dpow n (DividedPowerAlgebra.ι R M x) = dp R n x)
    {ι : Type*} [DecidableEq ι] (b : Basis ι R M) (n : ℕ) (d : ι →₀ ℕ) (hd : d ≠ 0) :
    H.dpow n (basis R M b d) = (n ! ^ (#d.support - 1) • ∏ i ∈ d.support, n.uniformBell (d i)) •
        basis R M b (n • d) := by
  classical
  rw [← Finsupp.support_nonempty_iff] at hd
  rw [basis_eq, Finsupp.prod, DividedPowers.dpow_prod H hd (fun i hi ↦ dp_mem_augIdeal R M
    (Nat.zero_lt_of_ne_zero (Finsupp.mem_support_iff.mp hi)) (b i))]
  have (i) (hx : i ∈ d.support) : H.dpow n (dp R (d i) (b i)) =
      (n.uniformBell (d i)) • dp R (n * d i) (b i) := by
    rw [← hH, dpow_comp _ ( Finsupp.mem_support_iff.mp hx) (ι_mem_augIdeal R M (b i)), hH]
    simp
  rw [Finset.prod_congr rfl this, Finset.prod_smul', smul_assoc, basis_eq,
    Finsupp.prod_of_support_subset _ Finsupp.support_smul _ (fun i _ ↦ dp_zero R (b i))]
  simp


      /-
(∑ d ∈ ((basis R M b).repr x).support, Multiset.count d ↑k • d) =  ??

k = k_1, ... , k_n : unordered n-tuple of (ι →₀ ℕ)
((basis R M b).repr x).support : Finset (ι →₀ ℕ)
∀ a, k_a ∈ ((basis R M b).repr x

Multiset.count d ↑k : how many a are there such that k_a = d
Multiset.count d ↑k • d : ι →₀ ℕ

-/

-- TODO: golf and speed up
lemma repr_dp_one [DecidableEq ι] (m : M) : (basis R M b).repr (dp R 1 m) =
    ∑ x ∈ (b.repr m).support, (((b.repr m) x) • (basis R M b).repr
      ((basis R M b) (Multiset.toFinsupp (Sym.oneEquiv x)))) := by
  have hm : m = ((b.repr m).sum fun i c ↦ c • b i) := by
      have := (Basis.linearCombination_repr b m).symm
      simpa only [Finsupp.linearCombination, Finsupp.lsum] using this
  simp only [Finsupp.sum] at hm
  conv_lhs =>
    rw [hm, dp_sum]
    simp only [sym_succ, Nat.succ_eq_add_one, Nat.reduceAdd, sym_zero, image_singleton,
      sup_singleton_apply, Finsupp.mem_support_iff, ne_eq, Sym.cons_inj_left, imp_self,
      implies_true, sum_image, map_sum]
    simp only [dp_smul, Finset.prod_smul', map_smul]
  simp only [Sym.cons_inj_left, implies_true, Set.injOn_of_eq_iff_eq, sum_image, Sym.oneEquiv_apply,
    Sym.coe_mk, Multiset.toFinsupp_singleton, Basis.repr_self, Finsupp.smul_single, smul_eq_mul,
    mul_one]
  have hx' (x : ι) : x ::ₛ (∅ : Sym ι 0) = Sym.oneEquiv x := rfl
  calc
    ∑ x ∈ (b.repr m).support,
  (∏ i ∈ (b.repr m).support, (b.repr m) i ^ Multiset.count i ↑(x ::ₛ ∅)) •
    (basis R M b).repr (∏ i ∈ (b.repr m).support, dp R (Multiset.count i ↑(x ::ₛ ∅)) (b i)) =
    ∑ x ∈ (b.repr m).support,
      ((∏ i ∈ (b.repr m).support, (b.repr m) i ^ Multiset.count i ↑(x ::ₛ (∅ : Sym ι 0))) •
        (basis R M b).repr ((basis R M b) (Multiset.toFinsupp ↑(x ::ₛ (∅ : Sym ι 0))))) := by
      apply Finset.sum_congr rfl
      intro x hx
      rw [basis_eq']
      simp only [Nat.succ_eq_add_one, Nat.reduceAdd, sym_succ, sym_zero, image_singleton,
        sup_singleton_apply, hx' x, Sym.oneEquiv_apply, mem_image, Finsupp.mem_support_iff, ne_eq]
      simp only [Finsupp.mem_support_iff, ne_eq] at hx
      use x, hx
      simp only [hx' x, Sym.oneEquiv_apply]
    _ = ∑ x ∈ (b.repr m).support,
        ((∏ i ∈ (b.repr m).support, (b.repr m) i ^ Multiset.count i {x}) • (basis R M b).repr
        ((basis R M b) (Multiset.toFinsupp ↑(x ::ₛ (∅ : Sym ι 0))))) := by congr
    _ = ∑ x ∈ (b.repr m).support, (((b.repr m) x) • (basis R M b).repr
          ((basis R M b) (Multiset.toFinsupp (Sym.oneEquiv x)))) := by
      apply Finset.sum_congr rfl
      intro x hx
      congr
      conv_rhs => rw [← pow_one (b.repr m x), ← Multiset.count_singleton_self x]
      apply Finset.prod_eq_single_of_mem _ hx
      intro y hy hyx
      have hyx' : Multiset.count y {x} = 0 := by rw [Multiset.count_singleton, if_neg hyx]
      rw [hyx', pow_zero]
    _ = _ := by
      simp


