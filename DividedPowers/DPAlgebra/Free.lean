/-
Copyright (c) 2024 Antoine Chambert-Loir, María Inés de Frutos-Fernández. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir, María Inés de Frutos-Fernández
-/
import DividedPowers.DPAlgebra.BaseChange
import DividedPowers.DPAlgebra.Graded.Basic
import DividedPowers.ForMathlib.RingTheory.TensorProduct.DirectLimit.FG
import Mathlib.LinearAlgebra.FreeModule.Basic

noncomputable section

open DividedPowers Finset Ideal Ideal.Quotient MvPolynomial RingQuot

namespace DividedPowerAlgebra

universe u v v₁ v₂ w uA uR uS uM

section Int

open Module

-- TODO: rename
/-- The basis of the nth graded part of `DividedPowerAlgebra ℤ M` associated with a basis of `M`,
  where `M` is generated by a single element. -/
noncomputable def Int.basis_grade (M : Type v) [AddCommGroup M] (b : Basis Unit ℤ M) (n : ℕ) :
    Basis Unit ℤ (grade ℤ  M n) := by
  set v : Unit → grade ℤ  M n := fun _ ↦ ⟨dp ℤ n (b ()), dp_mem_grade ℤ M n (b ())⟩
  apply Basis.mk (v := v)
  · simp only [LinearIndependent]
    intro f g h
    simp only [Finsupp.linearCombination_apply, Finsupp.sum] at h
    rw [Finset.sum_eq_single () (by tauto) (by aesop),
      Finset.sum_eq_single () (by tauto) (by aesop)] at h
    rw [← sub_eq_zero, sub_eq_add_neg, ← sub_zsmul (v ())] at h
    ext
    rw [← sub_eq_zero]
    suffices ∀ (m : ℤ) (hm : m ≠ 0), m • dp ℤ n (b ()) ≠ 0 by
      by_contra h'
      apply this (f () - g ()) h'
      simpa only [SetLike.mk_smul_mk, Submodule.mk_eq_zero, v] using h
    intro m hm
    -- Define a ℤ-algebra map DividedPowerAlgebra ℤ M → ℚ sending m • dp ℤ n (b ()) to m/n!
    sorry

  · intro x _
    obtain ⟨p, hp, hpx⟩ := (mem_grade_iff _ _ _ _).mp x.2
    rw [mem_weightedHomogeneousSubmodule] at hp
    simp only [IsWeightedHomogeneous, ne_eq] at hp
    have hv : Set.range v = {v ()} := by simp
    rw [hv, Submodule.mem_span_singleton]
    -- I am not sure if I set up the lemma in the easiest way to conclude this
    sorry

end Int

variable (R : Type u) [CommRing R] (M : Type v) [AddCommGroup M] [Module R M] (x : M) {n : ℕ}
  (N : Type w) [AddCommGroup N] [Module R N]

namespace Free

open Module TensorProduct

example (R M N : Type*) [CommSemiring R] [AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]
    (f : M ≃ₗ[R] N) :
    DividedPowerAlgebra R M ≃ₐ[R] DividedPowerAlgebra R N := by
  exact LinearEquiv.lift f

-- Prop. A2.1
noncomputable example : R ⊗[ℤ] DividedPowerAlgebra ℤ M ≃ₐ[R] DividedPowerAlgebra R (R ⊗[ℤ] M) :=
  DividedPowerAlgebra.dpScalarExtensionEquiv ℤ R M

variable {R M} in
def foo (P Q : {P : Submodule R M // P.FG}) (h : P ≤ Q) :
    DividedPowerAlgebra R P →ₗ[R] DividedPowerAlgebra R Q := sorry

-- Prop A2.2 (Also see Submodules_fg_equiv)
example [DecidableEq {P : Submodule R M // P.FG}] :
  Module.DirectLimit (ι := {P : Submodule R M // P.FG})
    (fun P ↦ DividedPowerAlgebra R P) (fun ⦃P Q⦄ (h : P ≤ Q) ↦ foo P Q h) ≃ₗ[R]
    DividedPowerAlgebra R (Module.DirectLimit (ι := {P : Submodule R M // P.FG})
      (G := fun P ↦ P.val) (fun ⦃P Q⦄ (h : P ≤ Q) ↦ Submodule.inclusion h)) := sorry

-- Prop A2.3
example [DecidableEq {P : Submodule R M // P.FG}] :
  DividedPowerAlgebra R M ⊗[R] DividedPowerAlgebra R N ≃ₗ[R]
    DividedPowerAlgebra R (M × N) := sorry


/-- The basis of the nth graded part of `DividedPowerAlgebra R M` associated with a basis of `M`. -/
noncomputable def basis_grade {ι : Type*} (b : Basis ι R M) (n : ℕ) :
    Basis {d : ι →₀ ℕ // d.degree = n} R (grade R M n) := by
  apply Basis.mk (v := fun ⟨d, hd⟩ ↦
    ⟨d.prod (fun i k ↦ dp R k (b i)), by
      suffices n = d.sum (fun i k ↦ k) by
        simp only [this, Finsupp.sum, Finsupp.prod]
        exact SetLike.prod_mem_graded (grade R M) d
          (fun i ↦ dp R (d i) (b i)) (fun i _ ↦ dp_mem_grade R M (d i) (b i))
      simp only [← hd, Finsupp.degree, Finsupp.sum]⟩)
  · sorry
  · sorry

theorem free_grade [Module.Free R M] (n : ℕ) : Module.Free R (grade R M n) :=
  Module.Free.of_basis (basis_grade R M (Module.Free.chooseBasis R M) n)

/-- The basis of `DividedPowerAlgebra R M` associated with a basis of `M`. -/
noncomputable def basis {ι : Type*} (b : Basis ι R M) :
    Basis (ι →₀ ℕ) R (DividedPowerAlgebra R M) := by
  apply Basis.mk (v := fun d ↦ d.prod (fun i k ↦ dp R k (b i)))
  · sorry
  · intro x _
    let y := DividedPowerAlgebra.decompose R M x
    sorry

theorem free [Module.Free R M] : Module.Free R (DividedPowerAlgebra R M) :=
  Module.Free.of_basis (basis R M (Module.Free.chooseBasis R M))
