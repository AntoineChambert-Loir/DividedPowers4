/-
Copyright (c) 2024 Antoine Chambert-Loir, Mar√≠a In√©s de Frutos-Fern√°ndez. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir, Mar√≠a In√©s de Frutos-Fern√°ndez
-/

import DividedPowers.DPAlgebra.Compatible
import Mathlib.Data.Rel

universe u v w

open DividedPowerAlgebra DividedPowers Ideal

namespace DividedPowers

/-- The universal property of a divided power envelope

[Berthelot-Ogus], Theorem 3.19 (general case) -/
def IsDPEnvelope {A : Type u} [CommRing A] {I : Ideal A} (hI : DividedPowers I) {B : Type v}
    [CommRing B] [Algebra A B] (J : Ideal B) {D : Type v} [CommRing D] (J' : Ideal D)
    (hJ' : DividedPowers J') (œà : B ‚Üí+* D) (_ : J.map œà ‚â§ J') : Prop :=
  ‚àÄ (C : Type w) [CommRing C],
    ‚àÄ [Algebra A C] [Algebra B C],
      ‚àÄ [IsScalarTower A B C],
        ‚àÄ (K : Ideal C) (hK : DividedPowers K)
          (_ : J.map (algebraMap B C) ‚â§ K)
          (_ : IsCompatibleWith hI hK (algebraMap A C)),
          ‚àÉ! œÜ : DPMorphism hJ' hK, œÜ.toRingHom.comp œà = algebraMap B C

-- Note (ACL) : I add the assumption `I.map (algebraMap A B) ‚â§ J`, otherwise the property is not reasonable
/-- The weak divided powers envelope, under an additional condition

[Berthelot-Ogus], Theorem 3.19, case 1 -/
def IsWeakDPEnvelope {A : Type u} [CommRing A] {I : Ideal A} (hI : DividedPowers I) {B : Type v}
    [CommRing B] [Algebra A B] (J : Ideal B) (_ : I.map (algebraMap A B) ‚â§ J)
    {D : Type v} [CommRing D] (J' : Ideal D)
    (hJ' : DividedPowers J') (œà : B ‚Üí+* D) (_ : J.map œà ‚â§ J') : Prop :=
  ‚àÄ (C : Type w) [CommRing C],
    ‚àÄ [Algebra A C] [Algebra B C],
      ‚àÄ [IsScalarTower A B C],
        ‚àÄ (K : Ideal C) (hK : DividedPowers K)
          (_ : J.map (algebraMap B C) ‚â§ K)
          (_ : I.map (algebraMap A C) ‚â§ K)
          (_ : IsCompatibleWith hI hK (algebraMap A C)),
          ‚àÉ! œÜ : DPMorphism hJ' hK, œÜ.toRingHom.comp œà = algebraMap B C

-- TODO: universes?

namespace DividedPowerEnvelope

variable {A : Type u} [CommRing A] {I : Ideal A} (hI : DividedPowers I) {B : Type v} [CommRing B]
  [Algebra A B] (J : Ideal B)

-- Case 1 of the proof, B-O pg 61 in pdf
-- 2.3 in B.
section Included

open DividedPowers DividedPowerAlgebra

-- We assume that `f(I) ‚äÜ J`. (`f = algebraMap A B`)
variable (hIJ : I.map (algebraMap A B) ‚â§ J)

include hIJ in
lemma algebraMap_dpow_mem (x : I) {n : ‚Ñï} (hn : n ‚â† 0) :
    algebraMap _ _ (algebraMap A B (dpow hI n x)) ‚àà J := by
  apply hIJ
  simp only [Algebra.id.map_eq_id, RingHomCompTriple.comp_apply]
  exact Ideal.mem_map_of_mem _ (dpow_mem _ hn x.2)

-- (DividedPowerAlgebra.Œπ B J x) is the map œÜ in B-O
-- (i)
/-- The generators of the first kind for the suitable ideal of the divided power algebra

[Berthelot-Ogus], page 61, (i) -/
inductive rel1 : Rel (DividedPowerAlgebra B J) (DividedPowerAlgebra B J)
  | Rel {x : J} : rel1 (Œπ B J x) (algebraMap _ _ (x : B))

variable {J} in
lemma rel1_apply (x : J) :
  rel1 J ((Œπ B ‚Ü•J) x) ((algebraMap B (DividedPowerAlgebra B ‚Ü•J)) ‚Üëx) := by constructor

-- J1
/-- The ideal of the divided power algebra generated by the generators of the first kind

[Berthelot-Ogus], page 61, ùí•‚ÇÅ -/
noncomputable def J1 : Ideal (DividedPowerAlgebra B J) :=
  ofRel (rel1 J)

variable {J} in
lemma rel1_mem_J1 (x : J) :
    ((Œπ B ‚Ü•J) x - ((algebraMap B (DividedPowerAlgebra B ‚Ü•J)) ‚Üëx)) ‚àà J1 J := by
  apply subset_span
  use (Œπ B ‚Ü•J) x, (algebraMap B (DividedPowerAlgebra B ‚Ü•J)) ‚Üëx
  constructor
  ¬∑ exact rel1_apply x
  simp only [sub_add_cancel]


-- (ii)
/- inductive rel2 : Rel (DividedPowerAlgebra B J) (DividedPowerAlgebra B J)
  | Rel {x : I} {n : ‚Ñï} (hn : n ‚â† 0) :
    rel2 (dp B n (‚ü®algebraMap A B x, hIJ (Ideal.mem_map_of_mem _ x.2)‚ü© : J))
      (algebraMap _ _ (algebraMap A B (dpow hI n x))) -/

-- (ii)'
/-- The generators of the second kind of the suitable ideal of the divided power algebra

[Berthelot-Ogus], page 61, (ii)' -/
inductive rel2' : Rel (DividedPowerAlgebra B J) (DividedPowerAlgebra B J)
  | Rel {x : I} {n : ‚Ñï} (hn : n ‚â† 0) :
    rel2' (dp B n (‚ü®algebraMap A B x, hIJ (Ideal.mem_map_of_mem _ x.2)‚ü© : J))
      (Œπ B J ‚ü®(algebraMap A B (dpow hI n x)), algebraMap_dpow_mem hI J hIJ x hn‚ü©)

variable {J} in
lemma rel2'_apply {x : I} {n : ‚Ñï} (hn : n ‚â† 0) :
    rel2' hI J hIJ (dp B n (‚ü®algebraMap A B x, hIJ (Ideal.mem_map_of_mem _ x.2)‚ü© : J))
      (Œπ B J ‚ü®(algebraMap A B (dpow hI n x)), algebraMap_dpow_mem hI J hIJ x hn‚ü©) :=
  rel2'.Rel hn

-- J2
/-- The ideal of the divided power algebra generated by the generators of the first kind

[Berthelot-Ogus], page 61, ùí•‚ÇÇ -/
noncomputable def J2 : Ideal (DividedPowerAlgebra B J) :=
  ofRel (rel2' hI J hIJ)

lemma rel2'_mem_J2 (x : I) {n : ‚Ñï} (hn : n ‚â† 0) :
    (dp B n (‚ü®algebraMap A B x, hIJ (Ideal.mem_map_of_mem _ x.2)‚ü© : J)) -
      (Œπ B J ‚ü®(algebraMap A B (dpow hI n x)), algebraMap_dpow_mem hI J hIJ x hn‚ü©) ‚àà
        J2 hI J hIJ := by
  apply subset_span
  use (dp B n (‚ü®algebraMap A B x, hIJ (Ideal.mem_map_of_mem _ x.2)‚ü© : J)),
      (Œπ B J ‚ü®(algebraMap A B (dpow hI n x)), algebraMap_dpow_mem hI J hIJ x hn‚ü©)
  simp [sub_add_cancel, rel2'_apply hI hIJ hn]


/-- The suitable ideal of the divided power algebra

[Berthelot-Ogus], page 61, ùí• -/
noncomputable def J12 : Ideal (DividedPowerAlgebra B J) :=
  J1 J + J2 hI J hIJ

-- TODO: we might need something similar for rel2
lemma rel1_mem_J12 (x : J) :
    ((Œπ B ‚Ü•J) x - ((algebraMap B (DividedPowerAlgebra B ‚Ü•J)) ‚Üëx)) ‚àà J12 hI J hIJ :=
  mem_sup_left (rel1_mem_J1 x)

private theorem sub_add_sub {A : Type*} [AddCommGroup A] (a b c d : A) :
    (a - b) + (c - d) = a - d + (c - b) := by abel

lemma rel2_mem_J12 (x : I) {n : ‚Ñï} (hn : n ‚â† 0) :
    (dp B n (‚ü®algebraMap A B x, hIJ (Ideal.mem_map_of_mem _ x.2)‚ü© : J)) -
      algebraMap _ _ (algebraMap A B (dpow hI n x)) ‚àà J12 hI J hIJ := by
  have h := rel1_mem_J12 hI J hIJ (‚ü®algebraMap A B (dpow hI n x),
        hIJ (Ideal.mem_map_of_mem (algebraMap A B) (hI.dpow_mem hn x.prop))‚ü© : J)
  rw [‚Üê Ideal.neg_mem_iff, neg_sub] at h
  rw [‚Üê Ideal.add_mem_iff_left (J12 hI J hIJ) h, sub_add_sub]
  apply Ideal.add_mem _ (mem_sup_right (rel2'_mem_J2 hI J hIJ x hn))
  simp only [sub_self, Submodule.zero_mem]


  /- inductive rel2' : Rel (DividedPowerAlgebra B J) (DividedPowerAlgebra B J)
  | Rel {x : I} {n : ‚Ñï} (hn : n ‚â† 0) :
    rel2' (dp B n (‚ü®algebraMap A B x, hIJ (Ideal.mem_map_of_mem _ x.2)‚ü© : J))
      (Œπ B J ‚ü®(algebraMap _ _ (algebraMap A B (dpow hI n x))), algebraMap_dpow_mem hI J hIJ x hn‚ü©)-/

-- B-O : Claim in pg 61, proof in pg 62
theorem J12_IsSubDPIdeal [DecidableEq B] :
    IsSubDPIdeal (DividedPowerAlgebra.dividedPowers' B J)
      (J12 hI J hIJ ‚äì DividedPowerAlgebra.augIdeal B J) where
  isSubideal := inf_le_right
  dpow_mem   := fun _ hn x hx ‚Ü¶ by
    have hJ12 : J12 hI J hIJ ‚äì augIdeal B J = (J1 J  ‚äì augIdeal B J) + J2 hI J hIJ := sorry
    --simp only [dividedPowers', Subtype.forall, mem_inf]
    rw [hJ12, Submodule.add_eq_sup, Submodule.mem_sup'] at hx
    obtain ‚ü®‚ü®x1, hx1‚ü©, ‚ü®x2, hx2‚ü©, hx‚ü© := hx
    suffices ‚àÄ n (hn : n ‚â† 0),
        ((dividedPowers' B ‚Ü•J).dpow n x1 ‚àà J12 hI J hIJ ‚äì augIdeal B ‚Ü•J ‚àß
        (dividedPowers' B ‚Ü•J).dpow n x2 ‚àà J12 hI J hIJ ‚äì augIdeal B ‚Ü•J) by
      sorry
    intro n hn
    constructor
    ¬∑ have heq : J1 J ‚äì augIdeal B ‚Ü•J = J1 J * augIdeal B ‚Ü•J := by
        apply le_antisymm _ Ideal.mul_le_inf
        sorry
      have hsub : IsSubDPIdeal (DividedPowerAlgebra.dividedPowers' B J)
        (J1 J * augIdeal B ‚Ü•J) := {
          isSubideal := mul_le_left
          dpow_mem   := fun n hn x hx ‚Ü¶ by
            --simp? [Ideal.mul_le_inf] at hx
            sorry
        }
      have hss : J1 J * augIdeal B ‚Ü•J ‚â§ J12 hI J hIJ ‚äì augIdeal B ‚Ü•J :=
        heq ‚ñ∏ inf_le_inf_right (augIdeal B ‚Ü•J) le_sup_left
      rw [heq] at hx1
      exact hss (hsub.dpow_mem n hn hx1)
    ¬∑ sorry/- revert n
      induction x2 using DividedPowerAlgebra.induction_on with
      | h_C b =>
          intro n hn
          rw [mk_C]
          sorry
      | h_add a b hna hnb =>
          intro n hn
          rw [dpow_add]
          sorry
      | h_dp x m a hnx =>
          intro n hn
          sorry  -/

/-- The weak divided power envelope of an ideal, in the particular case

[Berthelot-Ogus], page 62, ùíü -/
def dpEnvelopeOfIncluded : Type v :=
  DividedPowerAlgebra B J ‚ß∏ J12 hI J hIJ

noncomputable instance : CommRing (dpEnvelopeOfIncluded hI J hIJ) :=
  Quotient.commRing (J12 hI J hIJ)
  --Ideal.Quotient.commRing _

noncomputable instance : Algebra B (dpEnvelopeOfIncluded hI J hIJ) :=
  Ideal.Quotient.algebra _

noncomputable instance algebraOfIncluded : Algebra A (dpEnvelopeOfIncluded hI J hIJ) :=
  ((algebraMap B (dpEnvelopeOfIncluded hI J hIJ)).comp (algebraMap A B)).toAlgebra

noncomputable instance algebraOfIncluded'' :
    Algebra (DividedPowerAlgebra B J) (dpEnvelopeOfIncluded hI J hIJ) :=
  Ideal.Quotient.algebra _

instance isScalarTower_of_included : IsScalarTower A B (dpEnvelopeOfIncluded hI J hIJ) :=
  IsScalarTower.of_algebraMap_eq (congrFun rfl)

/-- The divided power ideal in the weak divided power envelope

[Berthelot-Ogus], page 62, J_bar -/
noncomputable def dpIdealOfIncluded [DecidableEq B] : Ideal (dpEnvelopeOfIncluded hI J hIJ) :=
  map (Ideal.Quotient.mk (J12 hI J hIJ)) (DividedPowerAlgebra.augIdeal B J)

set_option pp.instances true
-- J_bar has DP
theorem sub_ideal_dpIdealOfIncluded [DecidableEq B] :
    J.map (algebraMap B (dpEnvelopeOfIncluded hI J hIJ)) ‚â§ dpIdealOfIncluded hI J hIJ := by
  have heq : algebraMap B (dpEnvelopeOfIncluded hI J hIJ) =
    (algebraMap (DividedPowerAlgebra B J) (dpEnvelopeOfIncluded hI J hIJ)).comp
      (algebraMap B (DividedPowerAlgebra B J)) := rfl
  intro x hx
  rw [dpIdealOfIncluded, Ideal.mem_map_iff_of_surjective _ Quotient.mk_surjective]
  rw [heq, ‚Üê map_map, mem_map_iff_of_surjective] at hx
  obtain ‚ü®y, hyJ, hyx‚ü© := hx
  ¬∑ rw [‚Üê hyx]
    rw [map, ‚Üê submodule_span_eq] at hyJ
    --TODO:lemma
    have hmap : algebraMap (DividedPowerAlgebra B ‚Ü•J) (dpEnvelopeOfIncluded hI J hIJ) =
      Ideal.Quotient.mk (J12 hI J hIJ) := rfl
    simp_rw [hmap]
    suffices y ‚àà (augIdeal B J) ‚äî (J12 hI J hIJ) by
      rw [Submodule.mem_sup] at this
      obtain ‚ü®y, hy, z, hz, rfl‚ü© := this
      use y, hy
      unfold dpEnvelopeOfIncluded
      rw [eq_comm, Ideal.Quotient.mk_eq_mk_iff_sub_mem (y + z) y]
      simp only [add_sub_cancel_left, hz]
    apply Submodule.span_induction (p := fun y _ ‚Ü¶ y ‚àà (augIdeal B J) ‚äî (J12 hI J hIJ))
      _ _ _ _ hyJ
    ¬∑ intro x hx
      simp only [Set.mem_image, SetLike.mem_coe] at hx
      obtain ‚ü®y, hyJ, hyx‚ü© := hx
      have hsub : (((algebraMap B (DividedPowerAlgebra B ‚Ü•J)) y) - (Œπ B ‚Ü•J) ‚ü®y, hyJ‚ü©) ‚àà
          J12 hI J hIJ := by
        rw [‚Üê neg_sub, Ideal.neg_mem_iff]
        exact rel1_mem_J12 hI J hIJ ‚ü®y, hyJ‚ü©
      rw [Submodule.mem_sup]
      use ((Œπ B ‚Ü•J) ‚ü®y, hyJ‚ü©), dp_mem_augIdeal B ‚Ü•J zero_lt_one ‚ü®y, hyJ‚ü©,
        (((algebraMap B (DividedPowerAlgebra B ‚Ü•J)) y) - (Œπ B ‚Ü•J) ‚ü®y, hyJ‚ü©), hsub
      rw [‚Üê hyx]
      ring
    ¬∑ exact Submodule.zero_mem _
    ¬∑ intro x y _ _ hx hy
      simp only [Submodule.mem_sup] at hx hy ‚ä¢
      obtain ‚ü®ax, hax, cx, hcx, hx‚ü© := hx
      obtain ‚ü®ay, hay, cy, hcy, hy‚ü© := hy
      use (ax + ay), Ideal.add_mem _ hax hay, (cx + cy), Ideal.add_mem _ hcx hcy
      simp only [‚Üê hx, ‚Üê hy]
      ring
    ¬∑ intro a x _ hx
      simp only [Submodule.mem_sup] at hx ‚ä¢
      obtain ‚ü®bx, hbx, cx, hcx, hx‚ü© := hx
      use a ‚Ä¢ bx, Submodule.smul_mem _ a hbx, a ‚Ä¢ cx, Submodule.smul_mem _ a hcx
      rw [‚Üê hx, smul_add]
  exact Quotient.mk_surjective

-- Second part of Theorem 3.19
lemma isCompatibleWith_of_included [DecidableEq B]
    [‚àÄ x, Decidable (x ‚àà (dpIdealOfIncluded hI J hIJ).carrier)] :
    IsCompatibleWith hI (Quotient.dividedPowers (DividedPowerAlgebra.dividedPowers' B J)
      (J12_IsSubDPIdeal hI J hIJ)) (algebraMap A (dpEnvelopeOfIncluded hI J hIJ)) := by
  set hJ := (Quotient.dividedPowers (DividedPowerAlgebra.dividedPowers' B J)
      (J12_IsSubDPIdeal hI J hIJ))
  --have hIJ : ‚àÄ (n : ‚Ñï), ‚àÄ a ‚àà I ‚äì J, hI.dpow n a = hJ.dpow n a := sorry
  --have := (IsCompatibleWith_tfae hI hJ (algebraMap A (dpEnvelopeOfIncluded hI J hIJ))).out 0 1
  --rw [‚Üê extends_to_def, extends_to_iff_exists_dpIdeal] at this
  rw [IsCompatibleWith]
  have I' := I.map (algebraMap A (dpEnvelopeOfIncluded hI J hIJ))
  have J' := (augIdeal B J).map (Ideal.Quotient.mk (J12 hI J hIJ))

  have : extends_to hI (algebraMap A (dpEnvelopeOfIncluded hI J hIJ)) := by
    rw [extends_to_iff_exists_dpIdeal]
    use dpIdealOfIncluded hI J hIJ
    use (Quotient.dividedPowers (DividedPowerAlgebra.dividedPowers' B J)
      (J12_IsSubDPIdeal hI J hIJ))
    rw [IsDPMorphism]
    constructor
    ¬∑ apply le_trans _ (sub_ideal_dpIdealOfIncluded _ _ _)
      have hmap : (algebraMap A (dpEnvelopeOfIncluded hI J hIJ)) =
        (algebraMap B (dpEnvelopeOfIncluded hI J hIJ)).comp (algebraMap A B) := rfl
      rw [hmap]
      simp only [‚Üê map_map]
      apply map_mono hIJ
    ¬∑ intro n a haI
      rw [Quotient.dividedPowers]
      --rw [Quotient.OfSurjective.dpow_apply]


      sorry

  obtain ‚ü®hI', h‚ü© := this

  use hI', h
  rintro n b ‚ü®hb, hb'‚ü©
  simp only [SetLike.mem_coe] at hb hb'
  rw [IsDPMorphism] at h
  refine Submodule.span_induction ?_ ?_ ?_ ?_ hb'
  ¬∑ rintro x ‚ü®a, haI, rfl‚ü©
    --erw [h.2 a haI]
    sorry
  ¬∑ sorry
  ¬∑ sorry
  ¬∑ sorry

  /- have hsurj : Function.Surjective ‚áë(Ideal.Quotient.mk (J12 hI J hIJ)) := by
    apply Ideal.Quotient.mk_surjective
  have := Ideal.mem_image_of_mem_map_of_surjective _ hsurj hb
  obtain ‚ü®c, hc, rfl‚ü© := this -/

  /- have hmap :  (algebraMap A (dpEnvelopeOfIncluded hI J hIJ))  =
    (Ideal.Quotient.mk (J12 hI J hIJ)) := sorry
  rw [h.2] -/
    --((Ideal.Quotient.mk (J12 hI J hIJ)) (augIdeal B ‚Ü•J))

  --sorry

  /- set hK : DividedPowers (map (algebraMap A _) I +
      map (Ideal.Quotient.mk (J12 hI J hIJ)) (augIdeal B ‚Ü•J)) := by
    apply IdealAdd.dividedPowers hI' (Quotient.dividedPowers
      (DividedPowerAlgebra.dividedPowers' B J) (J12_IsSubDPIdeal hI hIJ))

    sorry
    with hK_def -/
  --use IdealAdd.dividedPowers hI hJ (by sorry)
 /-  use hK
  constructor
  ¬∑ simp only [IsDPMorphism, Submodule.add_eq_sup, le_sup_left, true_and]
    intro n a haI
    rw [hK_def]
    --rw [IdealAdd.dpow_eq_of_mem_left]
    --rw [IdealAdd.dividedPowers_dpow_eq_algebraMap]
    sorry
  ¬∑ simp only [IsDPMorphism, map_id, Submodule.add_eq_sup, le_sup_right, RingHom.id_apply,
    true_and]
    sorry -/


-- End of case 1
theorem dpEnvelopeOfIncluded_IsWeakDPEnvelope [DecidableEq B] :
    IsWeakDPEnvelope hI J hIJ (dpIdealOfIncluded hI J hIJ)
      (Quotient.dividedPowers (DividedPowerAlgebra.dividedPowers' B J) (J12_IsSubDPIdeal hI J hIJ))
      (algebraMap B (dpEnvelopeOfIncluded hI J hIJ)) (sub_ideal_dpIdealOfIncluded hI J hIJ) := by
  rw [IsWeakDPEnvelope]
  intro C _ _ _ _ K hK hJK hIK hcomp
  simp only [IsCompatibleWith, mem_inf, and_imp] at hcomp
  have hAC : hI.IsDPMorphism hK (algebraMap A C) := {
    left  := hIK
    right := by
      obtain ‚ü®hI', h, hh‚ü© := hcomp
      intro n a haI
      rw [‚Üê hh ((algebraMap A C) a) (mem_map_of_mem (algebraMap A C) haI), h.2 a haI]
      exact (hIK (mem_map_of_mem (algebraMap A C) haI)) -- Q : Why does this appear??
  }
  have hDC : (DividedPowerAlgebra.dividedPowers' B J).IsDPMorphism hK (sorry) := sorry

  sorry

end Included

-- 2.4 in B. (with compatibility property)
section General

variable (I)

/-- The modified ideal to build the divided power envelope

[Berthelot-Ogus], page 62, J1 -/
def J' : Ideal B :=
  J + I.map (algebraMap A B)

-- IB is a subideal of J'
theorem sub_ideal_J' : I.map (algebraMap A B) ‚â§ J' I J :=
  le_sup_of_le_right (le_refl _)

variable {I}

/-- The divided power envelope of an ideal

[Berthelot-Ogus], page 61, ùíü_B,Œ≥(J‚ÇÅ) -/
def dpEnvelope : Type v :=
  dpEnvelopeOfIncluded hI (J' I J) (sub_ideal_J' I J)
--  DividedPowerAlgebra B (J' I J) ‚ß∏ J12 hI (J' I J) (sub_ideal_J' I J)

noncomputable instance : CommRing (dpEnvelope hI J) :=
  Ideal.Quotient.commRing (J12 hI (J' I J) (sub_ideal_J' I J))

noncomputable instance : Algebra B (dpEnvelope hI J) :=
  Ideal.Quotient.algebra B

lemma algebraMap_eq : algebraMap B (dpEnvelope hI J) =
    (Ideal.Quotient.mk (J12 hI (J' I J) (sub_ideal_J' I J))).comp
      (algebraMap B (DividedPowerAlgebra B (J' I J))) := rfl

noncomputable instance algebra' : Algebra A (dpEnvelope hI J) :=
  ((algebraMap B (dpEnvelope hI J)).comp (algebraMap A B)).toAlgebra

noncomputable instance algebra'' : Algebra (DividedPowerAlgebra B (J' I J)) (dpEnvelope hI J) :=
  Ideal.Quotient.algebra _

instance : IsScalarTower A B (dpEnvelope hI J) :=
  IsScalarTower.of_algebraMap_eq (congrFun rfl)

lemma dpEnvelope_eq_dpEnvelopeOfIncluded (hIJ : map (algebraMap A B) I ‚â§ J) :
    dpEnvelope hI J = dpEnvelopeOfIncluded hI J hIJ := by
  have hJ : J' I J = J := by
    rw [J']
    exact LE.le.add_eq_left hIJ
  rw [dpEnvelope, dpEnvelopeOfIncluded]
  congr 2
  all_goals
    try rw [hJ]
  ¬∑ exact heq_of_eqRec_eq (congrArg (LE.le (map (algebraMap A B) I)) hJ) rfl

section DecidableEq

variable [DecidableEq B]

/-- The modified divided power ideal of the divided power envelope

[Berthelot-Ogus], page 63, J‚ÇÅ_bar -/
noncomputable def J‚ÇÅ_bar : Ideal (dpEnvelope hI J) :=
  dpIdealOfIncluded hI (J' I J) (sub_ideal_J' I J)

/-- The divided power structure on the modified divided power ideal of the divided power envelope -/
noncomputable def dividedPowers' : DividedPowers (J‚ÇÅ_bar hI J) :=
  Quotient.dividedPowers (DividedPowerAlgebra.dividedPowers' B ‚Ü•(J' I J))
    (J12_IsSubDPIdeal hI _ (sub_ideal_J' I J))

/-
lemma J_le_augIdeal :
    J.map (algebraMap B (DividedPowerAlgebra B (J' I J))) ‚â§ (augIdeal B ‚Ü•(J' I J)) := sorry

noncomputable def dpIdeal' : (dividedPowers' B ‚Ü•(J' I J)).SubDPIdeal :=
  SubDPIdeal.generatedDpow (DividedPowerAlgebra.dividedPowers' B (J' I J)) (J_le_augIdeal J) -/


lemma J_le_J‚ÇÅ_bar : map (algebraMap B (dpEnvelope hI J)) J ‚â§ J‚ÇÅ_bar hI J :=
  le_trans (map_mono (le_sup_of_le_left (le_refl J)))
    (sub_ideal_dpIdealOfIncluded hI (J' I J) (sub_ideal_J' I J))

/-- The divided power ideal of the divided power envelope

[Berthelot-Ogus], page 63, J_bar -/
noncomputable def dpIdeal : (dividedPowers' hI J).SubDPIdeal :=
  SubDPIdeal.generatedDpow (dividedPowers' hI J) (J_le_J‚ÇÅ_bar hI J)

-- First claim in Theorem 3.19 : `J‚¨ùD_{B, Œ≥} ‚äÜ J_bar`.
theorem sub_ideal_dpIdeal :
    J.map (algebraMap B (dpEnvelope hI J)) ‚â§ (dpIdeal hI J).carrier := by
  rw [dpIdeal, SubDPIdeal.generatedDpow_carrier]
  intros x hx
  apply subset_span
  use 1, one_ne_zero, x, hx, (dpow_one _ (J_le_J‚ÇÅ_bar _ _ hx)).symm

/-- The divided power structure on the divided power envelope -/
noncomputable def dividedPowers [‚àÄ x, Decidable (x ‚àà (dpIdeal hI J).carrier)] :
    DividedPowers (dpIdeal hI J).carrier :=
  IsSubDPIdeal.dividedPowers (dividedPowers' hI J) (dpIdeal hI J).toIsSubDPIdeal

-- Second part of Theorem 3.19
lemma isCompatibleWith [‚àÄ x, Decidable (x ‚àà (dpIdeal hI J).carrier)] :
    IsCompatibleWith hI (dividedPowers hI J) (algebraMap A (dpEnvelope hI J)) := by
  rw [IsCompatibleWith]
  -- hI' should be the restriction to this SubDPIdeal
  sorry

end DecidableEq
section

-- TODO: improve proof
lemma map_generatedDpow_le {A B : Type*} [CommRing A] [CommRing B] {I : Ideal A}
    {hI : DividedPowers I} {J : Ideal B} {hJ : DividedPowers J}
    (œÜ : DPMorphism hI hJ) {s : Set A} (hs : s ‚äÜ I)  :
    (SubDPIdeal.generatedDpow hI hs).carrier.map œÜ.toRingHom ‚â§ J := by
  simp only [SubDPIdeal.generatedDpow_carrier, map_span, span_le]
  rintro _ ‚ü®_, ‚ü®‚ü®n, hn, x, hx, rfl‚ü©, rfl‚ü©‚ü©
  rw [‚Üê œÜ.dpow_comp (n := n) x (hs hx)]
  exact hJ.dpow_mem hn (œÜ.ideal_comp (Ideal.mem_map_of_mem _ (hs hx)))

lemma map_generatedDpow_le_of_subDPIdeal {A B : Type*} [CommRing A] [CommRing B] {I : Ideal A}
    {hI : DividedPowers I} {J : Ideal B} {hJ : DividedPowers J} {J' : SubDPIdeal hJ}
    {œÜ : DPMorphism hI hJ} {s : Set A} (hs : s ‚äÜ I) (hœÜs : œÜ '' s ‚äÜ J') :
    (SubDPIdeal.generatedDpow hI hs).carrier.map œÜ.toRingHom ‚â§ J'.carrier := by
  simp only [SubDPIdeal.generatedDpow_carrier, map_span, span_le]
  rintro _ ‚ü®_, ‚ü®‚ü®n, hn, x, hx, rfl‚ü©, rfl‚ü©‚ü©
  rw [‚Üê œÜ.dpow_comp (n := n) x (hs hx)]
  exact J'.dpow_mem _ hn (œÜ x) (hœÜs (Set.mem_image_of_mem (‚áëœÜ) hx))

-- Needed because `DPEnvelope` and `DPEnvelopeOfIncluded` are not the same type.
variable {hI J} in
theorem mem_dpIdealOfIncluded_of_mem_dpIdeal [DecidableEq B] {a : dpEnvelope hI J}
    (ha : a ‚àà (dpIdeal hI J)) : a ‚àà dpIdealOfIncluded hI (J' I J) (sub_ideal_J' I J) :=
  map_generatedDpow_le (DPMorphism.id (dividedPowers' hI J) ) (J_le_J‚ÇÅ_bar hI J)
    (Ideal.mem_map_of_mem _ ha)

section dpEnvelope_IsDPEnvelope

variable {C : Type*} [CommRing C] [Algebra A C] [Algebra B C] [IsScalarTower A B C]
  (K : Ideal C) (hK : DividedPowers K) (hJK : map (algebraMap B C) J ‚â§ K)
  (hI' : DividedPowers (map (algebraMap A C) I)) (hI'_ext : hI.IsDPMorphism hI' (algebraMap A C))
  (hI'_int : ‚àÄ {n : ‚Ñï}, ‚àÄ b ‚àà map (algebraMap A C) I ‚äì K, hI'.dpow n b = hK.dpow n b)

variable (I)

-- K1 in page 63 of B-O
private abbrev K1 : Ideal C := I.map (algebraMap A C) + K

variable {I K}

-- Œ¥' in page 63 of B-O
private noncomputable abbrev h1 :  DividedPowers (K1 I K) := IdealAdd.dividedPowers hI'_int

private lemma h1_def : h1 hK hI' hI'_int = IdealAdd.dividedPowers hI'_int := rfl

-- Q: generalize and PR? (I.map (f : A ‚Üí+* C)) + K, plus do left and right versions
private abbrev g' : hI.DPMorphism (h1 hK hI' hI'_int) :=
  { toRingHom  := algebraMap A C
    ideal_comp := le_sup_of_le_left (le_refl _)
    dpow_comp  := fun _ ha =>
      IdealAdd.dividedPowers_dpow_eq_algebraMap' hI'_ext hI'_int _ _ ha }

private lemma algebraMap_J'_le_K1 (hJK : map (algebraMap B C) J ‚â§ K) :
    (J' I J).map (algebraMap B C) ‚â§ K1 I K := by
  rw [J', Ideal.add_eq_sup, Ideal.map_sup, sup_le_iff]
  refine ‚ü®le_trans hJK (le_sup_of_le_right (le_refl _)), ?_‚ü©
  rw [Ideal.map_map, Eq.symm (IsScalarTower.algebraMap_eq A B C)]
  exact le_sup_of_le_left (le_refl _)

private lemma isCompatibleWith_hI_h1 (hI'_ext : hI.IsDPMorphism hI' (algebraMap A C)) :
    IsCompatibleWith hI (h1 hK hI' hI'_int) (algebraMap A C) := by
  rw [IsCompatibleWith]
  use hI', hI'_ext
  intro n c hc
  exact (IdealAdd.dpow_eq_of_mem_left hI'_int hc.1).symm

-- TODO?: generalize to subpdideals of sums (left and right)
private abbrev K' : SubDPIdeal (h1 hK hI' hI'_int) :=
  { carrier := K
    isSubideal := le_sup_right
    dpow_mem := fun {n} hn j hj ‚Ü¶ by
      suffices (h1 hK hI' hI'_int).dpow n j = hK.dpow n j by
        rw [this]
        apply hK.dpow_mem hn hj
      exact IdealAdd.dpow_eq_of_mem_right hI'_int hj }

-- Not needed.
private lemma algebraMap_I_le_K1  :
    map (algebraMap A C) I ‚â§ K1 I K :=
  SemilatticeSup.le_sup_left _ _

private noncomputable abbrev œÜ [DecidableEq B] :
    (Quotient.dividedPowers (DividedPowerAlgebra.dividedPowers' B (J' I J))
      (J12_IsSubDPIdeal hI _ (sub_ideal_J' I J))).DPMorphism (h1 hK hI' hI'_int) :=
  (dpEnvelopeOfIncluded_IsWeakDPEnvelope hI (J' I J) (sub_ideal_J' I J) C _ (h1 hK hI' hI'_int)
    (algebraMap_J'_le_K1 J hJK) (SemilatticeSup.le_sup_left _ _)
    (isCompatibleWith_hI_h1 hI hK hI' hI'_int hI'_ext)).choose

private lemma hœÜ [DecidableEq B] : (œÜ hI J hK hJK hI' hI'_ext hI'_int).toRingHom.comp
    (algebraMap B (dpEnvelopeOfIncluded hI (J' I J) (sub_ideal_J' I J))) = algebraMap B C :=
  (dpEnvelopeOfIncluded_IsWeakDPEnvelope hI (J' I J) (sub_ideal_J' I J) C _ (h1 hK hI' hI'_int)
    (algebraMap_J'_le_K1 J hJK) (SemilatticeSup.le_sup_left _ _)
    (isCompatibleWith_hI_h1 hI hK hI' hI'_int hI'_ext)).choose_spec.1

private lemma hœÜ_unique  [DecidableEq B] :
    ‚àÄ (y : (Quotient.dividedPowers (DividedPowerAlgebra.dividedPowers' B ‚Ü•(J' I J))
      (J12_IsSubDPIdeal hI _ (sub_ideal_J' I J))).DPMorphism (h1 hK hI' hI'_int)),
      (fun œÜ ‚Ü¶ œÜ.toRingHom.comp (algebraMap B (dpEnvelopeOfIncluded hI (J' I J) (sub_ideal_J' I J))) =
        algebraMap B C) y ‚Üí y = œÜ hI J hK hJK hI' hI'_ext hI'_int :=
  (dpEnvelopeOfIncluded_IsWeakDPEnvelope hI (J' I J) (sub_ideal_J' I J) C _ (h1 hK hI' hI'_int)
    (algebraMap_J'_le_K1 J hJK) (SemilatticeSup.le_sup_left _ _)
    (isCompatibleWith_hI_h1 hI hK hI' hI'_int hI'_ext)).choose_spec.2

private noncomputable abbrev œà [DecidableEq B] [‚àÄ x, Decidable (x ‚àà (dpIdeal hI J).carrier)] :
    (dividedPowers hI J).DPMorphism hK where
  toRingHom  := (œÜ hI J hK hJK hI' hI'_ext hI'_int).toRingHom
  ideal_comp := by
    have hK' : (K : Ideal C) = (K' hK hI' hI'_int).carrier := rfl
    conv_rhs => rw [hK']
    rw [dpIdeal]
    apply map_generatedDpow_le_of_subDPIdeal
    suffices (map (algebraMap B (dpEnvelope hI J)) J).map
        (œÜ hI J hK hJK hI' hI'_ext hI'_int).toRingHom ‚â§ K' hK hI' hI'_int by
      rwa [Ideal.map, span_le] at this
    rw [Ideal.map_map, Ideal.map, span_le]
    rintro _ ‚ü®b, hb, rfl‚ü©
    simp only [dpEnvelope, hœÜ hI J hK hJK hI' hI'_ext hI'_int, SetLike.mem_coe]
    exact le_trans hJK (le_refl K) (mem_map_of_mem (algebraMap B C) hb)
  dpow_comp  := fun {n} a ha => by
    -- On `K`, `h1.dpow` coincides with `hK.dpow`, by `dpow_eq_of_mem_right`
    -- The left hand side applies to `œÜ a`, so `hK` can be changed to `h1`
    rw [‚Üê IdealAdd.dpow_eq_of_mem_right hI'_int]
    ¬∑ have hœÜ_comp : ‚àÄ a ‚àà dpIdealOfIncluded hI (J' I J) (sub_ideal_J' I J),
          (h1 hK hI' hI'_int).dpow n (œÜ hI J hK hJK hI' hI'_ext hI'_int a) =
            œÜ hI J hK hJK hI' hI'_ext hI'_int _ :=
        (œÜ hI J hK hJK hI' hI'_ext hI'_int).dpow_comp (n := n)
      have ha' : a ‚àà dpIdealOfIncluded hI (J' I J) (sub_ideal_J' I J) :=
        mem_dpIdealOfIncluded_of_mem_dpIdeal ha
      -- Then we apply `œÜ.dpow_comp`
      simp only [dpEnvelope, dpEnvelopeOfIncluded, DPMorphism.toRingHom_apply]
      rw [hœÜ_comp a ha']
      -- Get `dpow` for `dpEnvelopeOfIncluded`, for `J' I J`,
      -- but this will be the same as `dpow` for `dpEnvelope` because the element is there.
      rw [dividedPowers, IsSubDPIdeal.dpow_eq, if_pos ha]
      rfl
    ¬∑ -- œÜ.toRingHom a ‚àà K
      set K' : SubDPIdeal (h1 hK hI' hI'_int) := IdealAdd.subDPIdeal_right hI'_int
      have hK' : K'.toIdeal = K := rfl
      have hK'_set : (K' : Set C) = K := rfl
      suffices _ ‚àà K'.toIdeal by
        rw [hK'] at this
        exact this
      simp only [dpIdeal, SubDPIdeal.memCarrier] at ha
      have hœÜ' : ‚áë(œÜ hI J hK hJK hI' hI'_ext hI'_int) ''
          (map (algebraMap B (dpEnvelope hI J)) J : Set (dpEnvelope hI J)) ‚äÜ K' := by
        unfold dpEnvelope dpEnvelopeOfIncluded
        simp only [Set.image_subset_iff]
        rw [‚Üê DPMorphism.coe_toRingHom, hK'_set,
          ‚Üê coe_comap (f := (œÜ hI J hK hJK hI' hI'_ext hI'_int).toRingHom) K]
        norm_cast
        rw [Ideal.map_le_iff_le_comap, Ideal.comap_comap]
        have hœÜ_unf := hœÜ hI J hK hJK hI' hI'_ext hI'_int
        unfold dpEnvelopeOfIncluded at hœÜ_unf
        rw [hœÜ_unf]
        exact fun _ hx ‚Ü¶ hJK (Ideal.mem_map_of_mem _ hx)
      exact map_generatedDpow_le_of_subDPIdeal (J_le_J‚ÇÅ_bar hI J) hœÜ' (Ideal.mem_map_of_mem _ ha)

private noncomputable def foo [DecidableEq B] :
    (DividedPowerAlgebra.dividedPowers' B ‚Ü•(J' I J)).DPMorphism (dividedPowers' hI J)  :=
  DPMorphism.mk' (Quotient.isDPMorphism (DividedPowerAlgebra.dividedPowers' B ‚Ü•(J' I J)) _)

private noncomputable def bar [DecidableEq B] [‚àÄ x, Decidable (x ‚àà (dpIdeal hI J).carrier)] :
    (dividedPowers hI J).DPMorphism (dividedPowers' hI J) :=
  DPMorphism.mk' (IsSubDPIdeal.isDPMorphism (dividedPowers' hI J) (dpIdeal hI J).toIsSubDPIdeal)

private noncomputable def foo' [DecidableEq B] [‚àÄ x, Decidable (x ‚àà (dpIdeal hI J).carrier)] :
    (DividedPowerAlgebra.dividedPowers' B ‚Ü•(J' I J)).DPMorphism (dividedPowers hI J)  := by

  /- convert DPMorphism.mk' _ _
    (Quotient.isDPMorphism (DividedPowerAlgebra.dividedPowers' B ‚Ü•(J' I J)) _) using 1 -/
  sorry

private noncomputable def Œ≤_aux [DecidableEq B] [‚àÄ x, Decidable (x ‚àà (dpIdeal hI J).carrier)]
    {Œ± : (dividedPowers hI J).DPMorphism hK}
    (hŒ± : Œ±.toRingHom.comp (algebraMap B (dpEnvelope hI J)) = algebraMap B C) :
    (DividedPowerAlgebra.dividedPowers' B ‚Ü•(J' I J)).DPMorphism (h1 hK hI' hI'_int) where
  toRingHom  := ((Œ±.toRingHom).comp (Ideal.Quotient.mk (J12 hI (J' I J) (sub_ideal_J' I J))))
  ideal_comp := by
    rw [augIdeal_eq_generatedDpow_Œπ_range]
    simp only [SubDPIdeal.generatedDpow_carrier, map_span, span_le]
    rintro _ ‚ü®_, ‚ü®‚ü®n, hn, x, hx, rfl‚ü©, rfl‚ü©‚ü©
    simp only [SetLike.mem_coe, LinearMap.mem_range, Subtype.exists] at hx
    obtain ‚ü®b, hb, rfl‚ü© := hx
    simp only [J', Submodule.add_eq_sup, Submodule.mem_sup] at hb
    rw [DividedPowerAlgebra.dpow_Œπ]
    simp only [dpIdeal, SetLike.mem_coe, SubDPIdeal.memCarrier]
    simp only [K1, Submodule.add_eq_sup, RingHom.coe_comp, DPMorphism.coe_toRingHom,
      Function.comp_apply]
    obtain ‚ü®j, hj, i, hi, rfl‚ü© := hb
    have : (‚ü®j + i, hb‚ü© : ‚Ü•(J' I J)) = ‚ü®j, Ideal.mem_sup_left hj‚ü© + ‚ü®i, Ideal.mem_sup_right hi‚ü© :=
      rfl
    rw [this]
    rw [dp_add] -- TODO: general lemma?
    rw [‚Üê DPMorphism.toRingHom_apply]
    simp only [map_sum, _root_.map_mul, DPMorphism.toRingHom_apply]
    apply Ideal.sum_mem
    intros c hc
    by_cases hc1 : c.1 = 0
    ¬∑ have hŒ±1 : Œ± 1 = 1 := sorry
      rw [hc1]
      simp only [dp_zero, map_one, hŒ±1, one_mul]
      --rw [dp_def]
      apply Ideal.mem_sup_left
      have halg : algebraMap A C = (algebraMap B C).comp (algebraMap A B) :=
        IsScalarTower.algebraMap_eq A B C
      rw [halg, ‚Üê hŒ±]
      rw [‚Üê Ideal.map_map, ‚Üê Ideal.map_map]
      rw [‚Üê Œ±.toRingHom_apply]
      apply Ideal.mem_map_of_mem
      -- Idea: commute mk and dp + use dpow_Œπ

      /- convert Ideal.mem_map_of_mem ?_ hi
      have : (algebraMap B (DividedPowerAlgebra B ‚Ü•(J' I J) ‚ß∏ J12 hI (J' I J) (sub_ideal_J' I J))) =
        (Ideal.Quotient.mk (J12 hI (J' I J) (sub_ideal_J' I J))).comp
          (algebraMap B (DividedPowerAlgebra B ‚Ü•(J' I J))) := by
        simp only [Quotient.mk_comp_algebraMap]
      unfold dpEnvelope dpEnvelopeOfIncluded
      rw [this]
      rw [RingHom.comp_apply]
      congr 1 -/
      --apply Ideal.mem_map_of_mem
      sorry

    ¬∑ apply Ideal.mem_sup_right
      apply Ideal.mul_mem_right
      apply Œ±.ideal_comp
      rw [‚Üê Œ±.toRingHom_apply]
      rw [dp_def]
      apply Ideal.mem_map_of_mem
      unfold dpIdeal
      sorry
  dpow_comp  := by
    intro n b hb'
    rw [h1_def]
    have := Œ±.dpow_comp (n := n)
    sorry

set_option pp.proofs true
private noncomputable def Œ≤ [DecidableEq B] [‚àÄ x, Decidable (x ‚àà (dpIdeal hI J).carrier)]
    {Œ± : (dividedPowers hI J).DPMorphism hK}
    (hŒ± : Œ±.toRingHom.comp (algebraMap B (dpEnvelope hI J)) = algebraMap B C) :
    (Quotient.dividedPowers (DividedPowerAlgebra.dividedPowers' B ‚Ü•(J' I J))
      (J12_IsSubDPIdeal hI _ (sub_ideal_J' I J))).DPMorphism (h1 hK hI' hI'_int) where
  toRingHom  := Œ±.toRingHom
  ideal_comp := by
    -- The map is a divided power morphism
    -- The target ideal is a divided power ideal
    -- To prove inclusion, it suffices to prove that generators for the source ideal (as a dp ideal)
    -- map to the target
    -- By lemma `augIdeal_eq_generatedDpow_Œπ_range` from `DPAlgebra/Dpow`,
    -- the elements of `J' I J` are such generators
    -- and it is basically obvious that they map to `K1`
    -- But, the elements of `J` map to `K` (hypothesis)
    -- and the elements of `I` map to `K` as well (another hypothesis)
    have hKK1 : K ‚â§ K1 I K := le_sup_right
    rw [Ideal.map_map, augIdeal_eq_generatedDpow_Œπ_range]
    set aux : (DividedPowerAlgebra.dividedPowers' B ‚Ü•(J' I J)).DPMorphism (h1 hK hI' hI'_int) :=
        Œ≤_aux hI J hK hI' /- hI'_ext -/ hI'_int hŒ±
    have heq : aux =
        ((Œ±.toRingHom).comp (Ideal.Quotient.mk (J12 hI (J' I J) (sub_ideal_J' I J)))) := rfl
    rw [‚Üê heq]
    exact map_generatedDpow_le aux (Œπ_range_subset_augIdeal B ‚Ü•(J' I J))
  dpow_comp  := fun {n} a ha => by
    have halg : algebraMap A C = (algebraMap B C).comp (algebraMap A B) :=
        IsScalarTower.algebraMap_eq A B C
    obtain ‚ü®hK', hmap, hint‚ü© := isCompatibleWith_hI_h1 hI hK hI' hI'_int hI'_ext
    simp only [K1, Submodule.add_eq_sup, le_sup_left, inf_of_le_left] at hint
    simp only [halg, ‚Üê hŒ±, ‚Üê map_map] at hint
    rw [augIdeal_eq_generatedDpow_Œπ_range] at ha
    simp only [SubDPIdeal.generatedDpow_carrier, SetLike.mem_coe, LinearMap.mem_range,
      Subtype.exists, exists_prop', nonempty_prop, ne_eq, Nat.exists_ne_zero, map_span] at ha
    refine Submodule.span_induction ?_ ?_ ?_ ?_ ha
    ¬∑ intros c hc
      simp only [Set.mem_image, Set.mem_setOf_eq] at hc
      obtain ‚ü®d, ‚ü®m, d', ‚ü®‚ü®b, hb, rfl‚ü©, rfl‚ü©‚ü©, rfl‚ü© := hc
      rw [DividedPowerAlgebra.dpow_Œπ]
      simp only [Submodule.add_eq_sup, h1, DPMorphism.toRingHom_apply]
      simp only [J', Submodule.add_eq_sup] at hb
      rw [IdealAdd.dpow_eq_of_mem_right]
      have Œ±_comp := Œ±.dpow_comp (n := n)
      have hmap' : (algebraMap B (dpEnvelope hI J)) =
          (Ideal.Quotient.mk (J12 hI (J' I J) (sub_ideal_J' I J))).comp
            (algebraMap B (DividedPowerAlgebra B ‚Ü•(J' I J))) := rfl
      ¬∑ have hin : (Ideal.Quotient.mk (J12 hI (J' I J) (sub_ideal_J' I J))) (dp B (m + 1) ‚ü®b, hb‚ü©)
            ‚àà (dpIdeal hI J).carrier := by
          simp only [dpIdeal, SubDPIdeal.generatedDpow_carrier]

          sorry
        unfold dpEnvelope dpEnvelopeOfIncluded at Œ±_comp
        rw [‚Üê DPMorphism.toRingHom_apply]
        rw [Œ±_comp]
        simp only [dividedPowers]
        rw [IsSubDPIdeal.dpow_eq_of_mem]
        rfl
        ¬∑ exact hin
        ¬∑ exact hin
      ¬∑
        have hmap' : (algebraMap B (dpEnvelope hI J)) =
          (Ideal.Quotient.mk (J12 hI (J' I J) (sub_ideal_J' I J))).comp
            (algebraMap B (DividedPowerAlgebra B ‚Ü•(J' I J))) := rfl
        rw [hmap'] at hŒ±
        sorry

    ¬∑ sorry
    ¬∑ sorry
    ¬∑ sorry
    --have := Œ±.ideal_comp
    /- have Œ±_comp := Œ±.dpow_comp
    rw [Ideal.map] at ha
    refine Submodule.span_induction' ?_ ?_ ?_ ?_ ha
    ¬∑ intro c hc
      simp only [Set.mem_image, SetLike.mem_coe, RingHom.mem_ker] at hc
      obtain ‚ü®b, hb, rfl‚ü© := hc
      have hb_in :  (Ideal.Quotient.mk (J12 hI (J' I J) (sub_ideal_J' I J))) b ‚àà
        (dpIdeal hI J).carrier := by
        simp only [dpIdeal, SubDPIdeal.memCarrier, SubDPIdeal.generatedDpow]
        apply subset_span
        simp only [SetLike.mem_coe, exists_prop', nonempty_prop, ne_eq, Nat.exists_ne_zero,
          Set.mem_setOf_eq]

        sorry
      sorry
    sorry
    ¬∑ intros x hx y hy
      sorry
    sorry -/

    /- have ha' : a ‚àà (dpIdeal hI J).carrier := sorry
    rw [h1]
    rw [IdealAdd.dpow_eq_of_mem_right]
    ¬∑ unfold dpEnvelope dpEnvelopeOfIncluded at Œ±_comp
      simp only [Œ±_comp n a ha', dividedPowers, IsSubDPIdeal.dpow_eq_of_mem _ _ ha']
      rfl
    --rw [‚Üê hŒ±] at hmapc
    --simp_rw [‚Üê hI'_ext] at hmap
    --rw œÜ.dpow_comp,
    ¬∑ sorry -/

-- Universal property claim of Theorem 3.19
theorem dpEnvelope_IsDPEnvelope [DecidableEq B] [‚àÄ x, Decidable (x ‚àà (dpIdeal hI J).carrier)] :
    IsDPEnvelope hI J (dpIdeal hI J) (dividedPowers hI J)
      (algebraMap B (dpEnvelope hI J)) (sub_ideal_dpIdeal hI J) := by
  rintro C _ _ _ _ K hK hJK ‚ü®hI', hI'_ext, hI'_int‚ü©
  set œÜ := œÜ hI J hK hJK hI' hI'_ext hI'_int
  have hœÜ := hœÜ hI J hK hJK hI' hI'_ext hI'_int
  have hœÜ_unique := hœÜ_unique hI J hK hJK hI' hI'_ext hI'_int
  dsimp at hœÜ_unique
  use œà hI J hK hJK hI' hI'_ext hI'_int
  refine ‚ü®by rw [‚Üê hœÜ]; rfl, fun Œ± hŒ± ‚Ü¶ ?_‚ü©
  dsimp at hŒ±
  ext x
  simp only [RingHom.toMonoidHom_eq_coe, OneHom.toFun_eq_coe, MonoidHom.toOneHom_coe,
    MonoidHom.coe_coe]
  set foo := Œ≤ hI J hK hI' hI'_ext hI'_int hŒ±
  rw [‚Üê hœÜ_unique (Œ≤ hI J hK hI' hI'_ext hI'_int hŒ±) hŒ±, Œ≤]

end dpEnvelope_IsDPEnvelope
