/-
Copyright (c) 2024 Antoine Chambert-Loir, María Inés de Frutos-Fernández. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir, María Inés de Frutos-Fernández
-/
import Mathlib.RingTheory.Ideal.Quotient.Operations
import Mathlib.RingTheory.TensorProduct.Basic

open scoped TensorProduct

-- The goal is to prove Lemma 9 in Roby (1965)
section RingHom

theorem RingHom.ker_eq_ideal_iff {A B : Type*} [CommRing A] [CommRing B] (f : A →+* B)
    (I : Ideal A) : RingHom.ker f = I ↔
      ∃ h : I ≤ RingHom.ker f, Function.Injective (Ideal.Quotient.lift I f h) := by
  refine ⟨fun hI ↦ ⟨le_of_eq hI.symm, RingHom.lift_injective_of_ker_le_ideal _ _ (le_of_eq hI)⟩, ?_⟩
  rintro ⟨hI, h⟩
  simp only [RingHom.injective_iff_ker_eq_bot, Ideal.ker_quotient_lift f hI,
    Ideal.map_eq_bot_iff_le_ker, Ideal.mk_ker] at h
  exact le_antisymm h hI

end RingHom

section AlgHom

theorem AlgHom.ker_eq_ideal_iff {R A B : Type*} [CommRing R] [CommRing A] [Algebra R A]
    [CommRing B] [Algebra R B] (f : A →ₐ[R] B) (I : Ideal A) :
    RingHom.ker f = I ↔
      ∃ h : I ≤ RingHom.ker f, Function.Injective (Ideal.Quotient.liftₐ I f h) :=
    RingHom.ker_eq_ideal_iff f.toRingHom I

end AlgHom

/-  TODO: when we PR this, ask about why `mkₐ_smul_one_tmul_one` is so slow (and becomes even
  slower inside `ψLeft`.)

  The most general version `mkₐ_smul_one_tmul_one''` is the "correct" one, but it is the
  slowest one inside `ψLeft`.

  Main point: `AlgHom.map_smul` (which we were using before) is deprecated, and `map_smul` is
  much slower.
  -/

variable (R : Type*) [CommRing R] (S : Type*) [CommRing S] [Algebra R S]

variable (M : Type*) [CommRing M] [Algebra R M] [Algebra S M] [IsScalarTower R S M]
  (N : Type*) [CommRing N] [Algebra R N]

lemma mkₐ_smul_one_tmul_one'' (s : S) {B : Type*} [CommRing B] [Algebra S B]
    (f : M ⊗[R] N →ₐ[S] B) :
    f ((s • (1 : M)) ⊗ₜ[R] (1 : N)) = s • (1 : B) := by
  suffices (s • (1 : M)) ⊗ₜ[R] (1 : N) = s • (1 : M ⊗[R] N) by
    rw [this, map_smul, map_one]
  rfl

lemma mkₐ_smul_one_tmul_one (s : S) (I : Ideal (M ⊗[R] N)) :
    (Ideal.Quotient.mkₐ S I) ((s • (1 : M)) ⊗ₜ[R] (1 : N)) = s • (1 : M ⊗[R] N ⧸ I) := by
  suffices (s • (1 : M)) ⊗ₜ[R] (1 : N) = s • (1 : M ⊗[R] N) by
    rw [this, map_smul, map_one]
  rfl

variable [Algebra S N]

/-- The ideal of `M ⊗[R] N` generated by the elements of the form
  `(r • 1)) ⊗ₜ[R] 1 - 1 ⊗ₜ[R] (r •1)`, for `r : R`. -/
def kerφ : Ideal (M ⊗[R] N) :=
  Ideal.span ((fun r : S => (r • (1 : M)) ⊗ₜ[R] (1 : N) - (1 : M) ⊗ₜ[R] (r • (1 : N))) '' ⊤)

lemma mkₐ_smul_one_tmul_one' (s : S) :
    (Ideal.Quotient.mkₐ S (kerφ R S M N)) ((s • (1 : M)) ⊗ₜ[R] (1 : N)) =
      s • (1 : M ⊗[R] N ⧸ kerφ R S M N) := by
  apply mkₐ_smul_one_tmul_one''

lemma mkₐ_one_tmul_smul_one (s : S) :
    (Ideal.Quotient.mk (kerφ R S M N)) (1 ⊗ₜ[R] (s • 1)) = s • 1 := by
  rw [← (Ideal.Quotient.mk (kerφ R S M N)).map_one, ← Ideal.Quotient.mkₐ_eq_mk S, ← map_smul]
  simp only [Ideal.Quotient.mkₐ_eq_mk]
  apply symm
  rw [Ideal.Quotient.eq]
  exact Ideal.subset_span ⟨s, Set.mem_univ s, rfl⟩

open Algebra.TensorProduct TensorProduct

noncomputable def ψLeft : M →ₐ[S] M ⊗[R] N ⧸ kerφ R S M N := {
  ((Ideal.Quotient.mkₐ S (kerφ R S M N)).restrictScalars R).comp
    Algebra.TensorProduct.includeLeft with
  commutes' := fun s => by
    simp only [AlgHom.toFun_eq_coe, AlgHom.coe_comp, AlgHom.coe_restrictScalars',
      Function.comp_apply, includeLeft_apply, Algebra.algebraMap_eq_smul_one]
    rfl }

noncomputable def ψRight : N →ₐ[S] M ⊗[R] N ⧸ kerφ R S M N :=
  { (Ideal.Quotient.mkₐ R (kerφ R S M N)).comp includeRight with
    commutes' := fun s => by
      simp only [AlgHom.toRingHom_eq_coe, RingHom.toMonoidHom_eq_coe,
        Algebra.algebraMap_eq_smul_one, OneHom.toFun_eq_coe, MonoidHom.toOneHom_coe,
        MonoidHom.coe_coe, RingHom.coe_coe, AlgHom.coe_comp, Ideal.Quotient.mkₐ_eq_mk,
        Function.comp_apply, includeRight_apply]
      rw [← (Ideal.Quotient.mk (kerφ R S M N)).map_one, ← Ideal.Quotient.mkₐ_eq_mk S, ← map_smul,
        Ideal.Quotient.mkₐ_eq_mk, eq_comm, Ideal.Quotient.eq]
      exact Ideal.subset_span ⟨s, Set.mem_univ s, rfl⟩ }

noncomputable def ψ : M ⊗[S] N →ₐ[S] M ⊗[R] N ⧸ kerφ R S M N :=
  productMap (ψLeft R S M N) (ψRight R S M N)

theorem ψ_apply (m : M) (n : N) :
    ψ R S M N (m ⊗ₜ[S] n) = Ideal.Quotient.mk (kerφ R S M N) (m ⊗ₜ[R] n) := by
  simp only [ψ, ψLeft, AlgHom.toRingHom_eq_coe, ψRight, productMap_apply_tmul, AlgHom.coe_mk,
    RingHom.coe_coe, AlgHom.coe_comp, AlgHom.coe_restrictScalars', Ideal.Quotient.mkₐ_eq_mk,
    Function.comp_apply, includeLeft_apply, includeRight_apply, ← RingHom.map_mul, tmul_mul_tmul,
    mul_one, one_mul]

section IsScalarTower

variable [IsScalarTower R S N]

/-- The morphism `M ⊗[R] N →ₐ[R] M ⊗[S] N` from Roby65, Lemma 5. -/
noncomputable def φ : M ⊗[R] N →ₐ[R] M ⊗[S] N :=
  Algebra.TensorProduct.productMap Algebra.TensorProduct.includeLeft
    (Algebra.TensorProduct.includeRight.restrictScalars R)

theorem φ_apply (m : M) (n : N) : φ R S M N (m ⊗ₜ[R] n) = m ⊗ₜ[S] n := by
  simp only [φ, productMap_apply_tmul, AlgHom.coe_restrictScalars', includeLeft_apply,
    includeRight_apply, tmul_mul_tmul, _root_.mul_one, _root_.one_mul]

theorem φ_surjective : Function.Surjective (φ R S M N) := by
  intro z
  induction z using TensorProduct.induction_on with
  | zero => use 0; simp only [map_zero]
  | tmul m n => use m ⊗ₜ n; simp only [φ_apply]
  | add x y hx hy =>
      obtain ⟨a, rfl⟩ := hx
      obtain ⟨b, rfl⟩ := hy
      exact ⟨a + b, map_add _ _ _⟩

/-- We prove that the kernel of `φ` is equal to `kerφ` (see Roby65, Lemma 9). -/
theorem kerφ_eq : RingHom.ker (φ R S M N).toRingHom = kerφ R S M N := by
  suffices h : kerφ R S M N ≤ RingHom.ker (φ R S M N).toRingHom by
    rw [RingHom.ker_eq_ideal_iff]
    use h
    apply Function.HasLeftInverse.injective
    use ψ R S M N
    intro z
    obtain ⟨y, rfl⟩ := Ideal.Quotient.mk_surjective z
    simp only [AlgHom.toRingHom_eq_coe, Ideal.Quotient.lift_mk, AlgHom.coe_toRingHom]
    induction y using TensorProduct.induction_on with
    | zero => simp only [RingHom.map_zero, map_zero]
    | tmul m n => simp only [ψ_apply, φ_apply]
    | add x y hx hy =>
        simp only [RingHom.map_add, map_add, ← Ideal.Quotient.mkₐ_eq_mk, hx, hy]
  rw [kerφ, Ideal.span_le]
  intro z hz
  simp only [Set.top_eq_univ, Set.image_univ, Set.mem_range] at hz
  obtain ⟨r, rfl⟩ := hz
  simp only [SetLike.mem_coe, RingHom.sub_mem_ker_iff,AlgHom.toRingHom_eq_coe, AlgHom.coe_toRingHom,
    φ_apply, TensorProduct.tmul_smul]
  rfl

end IsScalarTower
