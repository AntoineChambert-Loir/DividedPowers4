/-
Copyright (c) 2024 Antoine Chambert-Loir, María Inés de Frutos-Fernández. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir, María Inés de Frutos-Fernández
-/
import Mathlib.RingTheory.DividedPowers.Basic
import DividedPowers.DPAlgebra.Misc

noncomputable section

open Finset Ideal Ideal.Quotient MvPolynomial RingQuot

/-!
# The divided power algebra of a module.
-/

section

theorem Ideal.sub_mem_ofRel {R : Type*} [Ring R] {r : R → R → Prop} {a b : R} (hr : r a b) :
    a - b ∈ Ideal.ofRel r :=
  Submodule.subset_span ⟨a, b, hr, by rw [sub_add_cancel]⟩

end


variable (R M : Type*) [CommSemiring R] [AddCommMonoid M] [Module R M]

namespace DividedPowerAlgebra

/-- The type coding the basic relations that will give rise to the divided power algebra.
  The class of `X (n, a)` will be equal to `dpow n a`, for `a ∈ M`. --/
inductive Rel : (MvPolynomial (ℕ × M) R) → (MvPolynomial (ℕ × M) R) → Prop
/-- rfl 0 -/
  | rfl_zero : Rel 0 0 -- Needed for technical reasons.
/-- dpow_zero -/
  | zero {a : M} : Rel (X (0, a)) 1
/-- dpow_smul -/
  | smul {r : R} {n : ℕ} {a : M} : Rel (X (n, r • a)) (r ^ n • X (n, a))
/-- dpow_mul -/
  | mul {m n : ℕ} {a : M} : Rel (X (m, a) * X (n, a)) (Nat.choose (m + n) m • X (m + n, a))
/- dpow_add-/
  | add {n : ℕ} {a b : M} :
    Rel (X (n, a + b)) ((Finset.antidiagonal n).sum fun k => X (k.1, a) * X (k.2, b))

/-- The ideal of `MvPolynomial (ℕ × M) R` generated by `Rel`. -/
def RelI : Ideal (MvPolynomial (ℕ × M) R) := ofRel (DividedPowerAlgebra.Rel R M)

end DividedPowerAlgebra

/-- The divided power algebra of a module M is defined as the ring quotient of the polynomial ring
  in the variables `ℕ × M` by the ring relation defined by the relation `DividedPowerAlgebra.Rel`.
  We will later show that that `DividedPowerAlgebra R M` has divided powers (see `?`).
  It satisfies a weak universal property for morphisms to rings with divided_powers
    (see `DividedPowerAlgebra.lift'`). -/
abbrev DividedPowerAlgebra : Type _ :=
  RingQuot (DividedPowerAlgebra.Rel R M)


namespace DividedPowerAlgebra

open MvPolynomial

variable {R M}

/-- The canonical `AlgHom` from `MvPolynomial (ℕ × M) R ` to `DividedPowerAlgebra R M`. -/
def mk : MvPolynomial (ℕ × M) R →ₐ[R] DividedPowerAlgebra R M :=
  mkAlgHom R (Rel R M)

lemma mk_surjective : Function.Surjective (@mk R M _ _ _) := RingQuot.mkAlgHom_surjective _ _

lemma mk_C (a : R) : mk (C a) = algebraMap R (DividedPowerAlgebra R M) a := by
  rw [← MvPolynomial.algebraMap_eq, AlgHom.commutes]

variable (R)

/-- `dp R n m` is the equivalence class of `X (⟨n, m⟩)` in `divided_power_algebra R M`. -/
def dp (n : ℕ) (m : M) : DividedPowerAlgebra R M := mkAlgHom R (Rel R M) (X ⟨n, m⟩)

theorem dp_def (n : ℕ) (m : M) :
  dp R n m = mkAlgHom R (Rel R M) (X ⟨n, m⟩) := rfl

--theorem dp_def' (n : ℕ) (m : M) : dp R n m = mk (X ⟨n, m⟩) := rfl

theorem dp_eq_mkRingHom (n : ℕ) (m : M) :
    dp R n m = mkRingHom (Rel R M) (X (⟨n, m⟩)) := by
  rw [← mkAlgHom_coe R]; rfl

theorem dp_zero (m : M) : dp R 0 m = 1 := by
  rw [dp_def, ← map_one (mkAlgHom R (Rel R M))]
  exact RingQuot.mkAlgHom_rel R Rel.zero

theorem dp_smul (r : R) (n : ℕ) (m : M) : dp R n (r • m) = r ^ n • dp R n m := by
  rw [dp_def, dp_def, ← map_smul]
  exact mkAlgHom_rel R Rel.smul

theorem dp_null (n : ℕ) : dp R n (0 : M) = if n = 0 then 1 else 0 := by
  cases' Nat.eq_zero_or_pos n with hn hn
  · rw [if_pos hn, hn, dp_zero]
  · rw [if_neg (ne_of_gt hn), ← zero_smul R (0 : M), dp_smul]
    rw [zero_pow (Nat.pos_iff_ne_zero.mp hn), zero_smul]

theorem dp_null_of_ne_zero {n : ℕ} (hn : n ≠ 0) : dp R n (0 : M) = 0 := by
  rw [dp_null R n, if_neg hn]

theorem dp_mul (n p : ℕ) (m : M) :
    dp R n m * dp R p m = (n + p).choose n • dp R (n + p) m := by
  simp only [dp_def, ← _root_.map_mul, ← map_nsmul]
  exact mkAlgHom_rel R Rel.mul

theorem dp_add (n : ℕ) (x y : M) :
    dp R n (x + y) = (antidiagonal n).sum fun k => dp R k.1 x * dp R k.2 y := by
  simp only [dp_def]
  rw [mkAlgHom_rel (A := MvPolynomial (ℕ × M) R) R Rel.add, map_sum,
    Finset.sum_congr rfl (fun k _ ↦ by rw [_root_.map_mul])]

theorem dp_sum {ι : Type*} [DecidableEq ι] (s : Finset ι) (q : ℕ) (x : ι → M) :
    dp R q (s.sum x) =
      (Finset.sym s q).sum fun k => s.prod fun i => dp R (Multiset.count i k) (x i) :=
  DividedPowers.dpow_sum' (I := ⊤) _ (fun {m} _ ↦ dp_zero R m)
    (fun {n x y} _ _ ↦ dp_add R n x y) (dp_null_of_ne_zero R) (fun _ _ ↦ trivial)


theorem dp_sum_smul {ι : Type*} [DecidableEq ι] (s : Finset ι) (q : ℕ) (a : ι → R) (x : ι → M) :
    dp R q (s.sum fun i => a i • x i) =
      (Finset.sym s q).sum fun k =>
        (s.prod fun i => a i ^ Multiset.count i k) •
          s.prod fun i => dp R (Multiset.count i k) (x i) := by
  simp_rw [dp_sum, dp_smul, Algebra.smul_def, map_prod, ← Finset.prod_mul_distrib]

variable {R}

theorem algHom_ext_iff {A : Type*} [CommSemiring A] [Algebra R A]
    {f g : DividedPowerAlgebra R M →ₐ[R] A} :
    (f = g) ↔ (∀ n m, f (dp R n m) = g (dp R n m)) := by
  refine ⟨fun h _ _ ↦ by rw [h], fun h ↦ ?_⟩
  . rw [DFunLike.ext'_iff]
    apply Function.Surjective.injective_comp_right (mkAlgHom_surjective R (Rel R M))
    simp only [← AlgHom.coe_comp, ← AlgHom.coe_comp, ← DFunLike.ext'_iff]
    exact MvPolynomial.algHom_ext fun ⟨n, m⟩ => h n m

@[ext]
theorem algHom_ext {A : Type*} [CommSemiring A] [Algebra R A]
    {f g : DividedPowerAlgebra R M →ₐ[R] A}
    (h : ∀ n m, f (dp R n m) = g (dp R n m)) : f = g :=
  algHom_ext_iff.mpr h

protected theorem induction_on {P : DividedPowerAlgebra R M → Prop} (f : DividedPowerAlgebra R M)
    (h_C : ∀ a, P (mk (C a))) (h_add : ∀ f g, P f → P g → P (f + g))
    (h_dp : ∀ (f : DividedPowerAlgebra R M) (n : ℕ) (m : M), P f → P (f * dp R n m)) : P f := by
  obtain ⟨F, hf⟩ := RingQuot.mkRingHom_surjective (DividedPowerAlgebra.Rel R M) f
  rw [← hf]
  induction F using MvPolynomial.induction_on generalizing f with
  | h_C a =>
      convert h_C a using 1;
      rw [mk, mkAlgHom, AlgHom.coe_mk]
  | h_add g1 g2 hg1 hg2 =>
      rw [map_add]
      exact h_add _ _ (hg1 ((mkRingHom (Rel R M)) g1) rfl) (hg2 ((mkRingHom (Rel R M)) g2) rfl)
  | h_X g nm h =>
      have h' : (mkRingHom (Rel R M)) (X nm) = dp R nm.1 nm.2 := by
        simp only [dp_def, Prod.mk.eta, mkAlgHom, AlgHom.coe_mk]
      rw [_root_.map_mul, h']
      exact h_dp _ _ _ (h (mkRingHom (Rel R M) g) rfl)

variable (R)

section UniversalProperty

variable (M)

variable {A : Type*} [CommSemiring A] [Algebra R A]

theorem lift'_imp {f : ℕ × M → A} (hf_zero : ∀ m, f (0, m) = 1)
    (hf_smul : ∀ (n : ℕ) (r : R) (m : M), f ⟨n, r • m⟩ = r ^ n • f ⟨n, m⟩)
    (hf_mul : ∀ n p m, f ⟨n, m⟩ * f ⟨p, m⟩ = (n + p).choose n • f ⟨n + p, m⟩)
    (hf_add : ∀ n u v, f ⟨n, u + v⟩ = (antidiagonal n).sum fun (k, l) ↦ f ⟨k, u⟩ * f ⟨l, v⟩)
    (p q : MvPolynomial (ℕ × M) R) (h : (Rel R M) p q) :
    (eval₂AlgHom R f) p = (eval₂AlgHom R f) q := by
  rcases h <;>
  simp_all [eval₂AlgHom_X', map_one, map_zero, map_smul, _root_.map_mul, map_nsmul, map_sum]


variable {R M}
/-- The weak universal property of `DividedPowerAlgebra R M`. -/
def lift' {f : ℕ × M → A} (hf_zero : ∀ m, f (0, m) = 1)
    (hf_smul : ∀ (n : ℕ) (r : R) (m : M), f ⟨n, r • m⟩ = r ^ n • f ⟨n, m⟩)
    (hf_mul : ∀ n p m, f ⟨n, m⟩ * f ⟨p, m⟩ = (n + p).choose n • f ⟨n + p, m⟩)
    (hf_add : ∀ n u v, f ⟨n, u + v⟩ = (antidiagonal n).sum fun (k, l) ↦ f ⟨k, u⟩ * f ⟨l, v⟩) :
    DividedPowerAlgebra R M →ₐ[R] A :=
  RingQuot.liftAlgHom R
    {val := eval₂AlgHom R f, property := lift'_imp R M hf_zero hf_smul hf_mul hf_add }

@[simp]
theorem lift'_apply {f : ℕ × M → A} (hf_zero : ∀ m, f (0, m) = 1)
    (hf_smul : ∀ (n : ℕ) (r : R) (m : M), f ⟨n, r • m⟩ = r ^ n • f ⟨n, m⟩)
    (hf_mul : ∀ n p m, f ⟨n, m⟩ * f ⟨p, m⟩ = (n + p).choose n • f ⟨n + p, m⟩)
    (hf_add : ∀ n u v, f ⟨n, u + v⟩ = (antidiagonal n).sum fun (k, l) => f ⟨k, u⟩ * f ⟨l, v⟩)
    (p : MvPolynomial (ℕ × M) R) :
    lift' hf_zero hf_smul hf_mul hf_add (mk p) = aeval f p := by
  rw [mk, lift', RingQuot.liftAlgHom_mkAlgHom_apply, coe_eval₂AlgHom]
  rfl

@[simp]
theorem lift'_apply_dp {f : ℕ × M → A} (hf_zero : ∀ m, f (0, m) = 1)
    (hf_smul : ∀ (n : ℕ) (r : R) (m : M), f ⟨n, r • m⟩ = r ^ n • f ⟨n, m⟩)
    (hf_mul : ∀ n p m, f ⟨n, m⟩ * f ⟨p, m⟩ = (n + p).choose n • f ⟨n + p, m⟩)
    (hf_add : ∀ n u v, f ⟨n, u + v⟩ = (antidiagonal n).sum fun (k, l) => f ⟨k, u⟩ * f ⟨l, v⟩)
    (n : ℕ) (m : M) :
    lift' hf_zero hf_smul hf_mul hf_add (dp R n m) = f ⟨n, m⟩ := by
  rw [dp_def, ← mk, lift'_apply hf_zero hf_smul hf_mul hf_add, aeval_X]

variable {I : Ideal A} (hI : DividedPowers I) (φ : M →ₗ[R] A) (hφ : ∀ m, φ m ∈ I)

/-- The weak universal property of a divided power algebra for morphisms to divided power rings -/
def lift : DividedPowerAlgebra R M →ₐ[R] A :=
  lift' (f := fun nm => hI.dpow nm.1 (φ nm.2))
    (fun m => hI.dpow_zero (hφ m))
    (fun n r m => by
      dsimp
      rw [LinearMap.map_smulₛₗ, RingHom.id_apply, ← algebraMap_smul A r (φ m), smul_eq_mul,
        hI.dpow_mul (hφ m), ← smul_eq_mul, ← map_pow, algebraMap_smul])
    (fun n p m => by
      rw [hI.mul_dpow (hφ m), ← nsmul_eq_mul])
    (fun n u v => by
      dsimp
      rw [map_add, hI.dpow_add (hφ u) (hφ v)])

variable {φ}

@[simp]
theorem lift_apply (p : MvPolynomial (ℕ × M) R) :
    lift hI φ hφ (mk p) = aeval (fun nm : ℕ × M => hI.dpow nm.1 (φ nm.2)) p := by
  rw [lift, lift'_apply]

@[simp]
theorem lift_apply_dp (n : ℕ) (m : M) :
    lift hI φ hφ (dp R n m) = hI.dpow n (φ m) := by rw [lift, lift'_apply_dp]

theorem lift_unique {f : DividedPowerAlgebra R M →ₐ[R] A}
    (hf : ∀ n m, f (dp R n m) = hI.dpow n (φ  m)) : f = lift hI φ hφ :=
  algHom_ext (fun _ _ ↦ by rw [lift_apply_dp, hf])

end UniversalProperty

section Functoriality

variable {R}

variable {S : Type*} [CommSemiring S] {N : Type*} [AddCommMonoid N] [Module R N] [Module S N]
  (f : M →ₗ[R] N)

lemma LinearMap.dp_zero (a : M) : dp S 0 (f a) = 1 := DividedPowerAlgebra.dp_zero S (f a)

lemma LinearMap.dp_mul (m n : ℕ) (a : M) :
    dp S m (f a) * dp S n (f a) = (Nat.choose (m + n) m) • dp S (m + n) (f a) :=
  DividedPowerAlgebra.dp_mul S m n (f a)

lemma LinearMap.dp_add (n : ℕ) (a b : M) :
    dp S n (f (a + b)) = (Finset.antidiagonal n).sum fun k => dp S k.1 (f a) * dp S k.2 (f b) := by
  rw [map_add, DividedPowerAlgebra.dp_add]

section IsScalarTower

variable (S)

variable [Algebra R S] [IsScalarTower R S N]

lemma LinearMap.dp_smul (n : ℕ) (r : R) (a : M) :
    dp S n (f (r • a)) = r ^ n • dp S n (f a) := by
  rw [f.map_smul, algebra_compatible_smul S r (f a),
    DividedPowerAlgebra.dp_smul S ((algebraMap R S) r) n (f a), ← map_pow, algebraMap_smul]

/-- The functoriality map between divided power algebras associated with a linear map of the
  underlying modules.
  Given an `R`-algebra `S`, an `S`-module `N` and an `R`-linear map `f : M →ₗ[R] N`,
  this is the map `DividedPowerAlgebra R M →ₐ[R] DividedPowerAlgebra S N`
  sending `dp R n m` to `dp S n (f m)`. -/
def LinearMap.lift : DividedPowerAlgebra R M →ₐ[R] DividedPowerAlgebra S N :=
  DividedPowerAlgebra.lift' (f := fun nm => dp S nm.fst (f nm.snd))
    (LinearMap.dp_zero f) (LinearMap.dp_smul S f) (LinearMap.dp_mul f) (LinearMap.dp_add f)

theorem LinearMap.lift_apply (p : MvPolynomial (ℕ × M) R) :
    LinearMap.lift S f (mk p) = aeval (fun nm => dp S nm.fst (f nm.snd)) p := by
  rw [LinearMap.lift, lift'_apply]

theorem LinearMap.lift_apply_dp (n : ℕ) (a : M) :
    LinearMap.lift S f (dp R n a) = dp S n (f a) := by
  rw [LinearMap.lift, lift'_apply_dp]

end IsScalarTower

end Functoriality

end DividedPowerAlgebra
