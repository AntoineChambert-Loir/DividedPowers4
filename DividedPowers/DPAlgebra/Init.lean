/-
Copyright (c) 2024 Antoine Chambert-Loir, María Inés de Frutos-Fernández. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir, María Inés de Frutos-Fernández
-/
import DividedPowers.ForMathlib.Algebra.MvPolynomial.Lemmas
import Mathlib.Algebra.RingQuot
import Mathlib.RingTheory.DividedPowers.Basic

noncomputable section

open Finset Ideal Ideal.Quotient MvPolynomial RingQuot Function

/-!
# The divided power algebra of a module.

Let `R` be a ring and `M` be an `R`-module. In this file we define `Γ_R(M)`, the universal
divided power algebra of `M`, as the ring quotient of the polynomial ring in the variables `ℕ × M`
by the ring relation defined by the relation `DividedPowerAlgebra.Rel`.

`DividedPowerAlgebra R M` satisfies a weak universal property for morphisms to rings with
divided_powers (see `DividedPowerAlgebra.lift'`).

We will later show that that `DividedPowerAlgebra R M` has divided powers (see the file
`DividedPowerAlgebra.DPAlgebra.Dpow` for ongoing work on this construction).

## Main definitions

* `DividedPowerAlgebra.Rel`: the type coding the basic relations that will give rise to the
  divided power algebra. The class of `X (n, a)` will be equal to `dpow n a`, for `a ∈ M`.

* `DividedPowerAlgebra R M`: the divided power algebra of the `R`-module `M`.

* `DividedPowerAlgebra.dp R n m`: the equivalence class of `X (⟨n, m⟩)` in
  `DividedPowerAlgebra R M`.

* `DividedPowerAlgebra.LinearMap.lift`: the functoriality map between divided power algebras
  associated with a linear map of the underlying modules.
  Given an `R`-algebra `S`, an `S`-module `N` and an `R`-linear map `f : M →ₗ[R] N`,
  this is the map `DividedPowerAlgebra R M →ₐ[R] DividedPowerAlgebra S N`
  sending `dp R n m` to `dp S n (f m)`.

## Main results

* `DividedPowerAlgebra.lift'`: the weak universal property of `DividedPowerAlgebra R M`.

-/

section

theorem Ideal.sub_mem_ofRel {R : Type*} [Ring R] {r : R → R → Prop} {a b : R} (hr : r a b) :
    a - b ∈ Ideal.ofRel r :=
  Submodule.subset_span ⟨a, b, hr, by rw [sub_add_cancel]⟩

end

variable (R M : Type*) [CommSemiring R] [AddCommMonoid M] [Module R M]

namespace DividedPowerAlgebra

/-- The type coding the basic relations that will give rise to the divided power algebra.
  The class of `X (n, a)` will be equal to `dpow n a`, for `a ∈ M`. --/
inductive Rel : (MvPolynomial (ℕ × M) R) → (MvPolynomial (ℕ × M) R) → Prop
/-- rfl 0 -/
  | rfl_zero : Rel 0 0 -- Needed for technical reasons.
/-- dpow_zero -/
  | zero {a : M} : Rel (X (0, a)) 1
/-- dpow_smul -/
  | smul {r : R} {n : ℕ} {a : M} : Rel (X (n, r • a)) (r ^ n • X (n, a))
/-- dpow_mul -/
  | mul {m n : ℕ} {a : M} : Rel (X (m, a) * X (n, a)) (Nat.choose (m + n) m • X (m + n, a))
/- dpow_add-/
  | add {n : ℕ} {a b : M} :
    Rel (X (n, a + b)) ((Finset.antidiagonal n).sum fun k => X (k.1, a) * X (k.2, b))

/-- The ideal of `MvPolynomial (ℕ × M) R` generated by `Rel`. -/
def RelI : Ideal (MvPolynomial (ℕ × M) R) := ofRel (DividedPowerAlgebra.Rel R M)

end DividedPowerAlgebra

/-- The divided power algebra of a module M is defined as the ring quotient of the polynomial ring
  in the variables `ℕ × M` by the ring relation defined by the relation `DividedPowerAlgebra.Rel`.
  We will later show that that `DividedPowerAlgebra R M` has divided powers (see the file
  `DividedPowerAlgebra.DPAlgebra.Dpow`).
  It satisfies a weak universal property for morphisms to rings with divided_powers
    (see `DividedPowerAlgebra.lift'`). -/
abbrev DividedPowerAlgebra : Type _ :=
  RingQuot (DividedPowerAlgebra.Rel R M)

namespace DividedPowerAlgebra

open MvPolynomial

variable {R M}

/-- The canonical `AlgHom` from `MvPolynomial (ℕ × M) R ` to `DividedPowerAlgebra R M`. -/
def mk : MvPolynomial (ℕ × M) R →ₐ[R] DividedPowerAlgebra R M :=
  mkAlgHom R (Rel R M)

lemma mk_surjective : Function.Surjective (@mk R M _ _ _) := RingQuot.mkAlgHom_surjective _ _

lemma mk_C (a : R) : mk (C a) = algebraMap R (DividedPowerAlgebra R M) a := by
  rw [← MvPolynomial.algebraMap_eq, AlgHom.commutes]

variable (R)

/-- `dp R n m` is the equivalence class of `X (⟨n, m⟩)` in `DividedPowerAlgebra R M`. -/
def dp (n : ℕ) (m : M) : DividedPowerAlgebra R M := mkAlgHom R (Rel R M) (X ⟨n, m⟩)

theorem dp_def (n : ℕ) (m : M) :
  dp R n m = mkAlgHom R (Rel R M) (X ⟨n, m⟩) := rfl

--theorem dp_def' (n : ℕ) (m : M) : dp R n m = mk (X ⟨n, m⟩) := rfl

theorem dp_eq_mkRingHom (n : ℕ) (m : M) :
    dp R n m = mkRingHom (Rel R M) (X (⟨n, m⟩)) := by
  rw [← mkAlgHom_coe R]; rfl

theorem dp_zero (m : M) : dp R 0 m = 1 := by
  rw [dp_def, ← map_one (mkAlgHom R (Rel R M))]
  exact RingQuot.mkAlgHom_rel R Rel.zero

theorem dp_smul (r : R) (n : ℕ) (m : M) : dp R n (r • m) = r ^ n • dp R n m := by
  rw [dp_def, dp_def, ← map_smul]
  exact mkAlgHom_rel R Rel.smul

theorem dp_null (n : ℕ) : dp R n (0 : M) = if n = 0 then 1 else 0 := by
  cases Nat.eq_zero_or_pos n with
  | inl hn =>
    rw [if_pos hn, hn, dp_zero]
  | inr hn =>
    rw [if_neg (ne_of_gt hn), ← zero_smul R (0 : M), dp_smul]
    rw [zero_pow (Nat.pos_iff_ne_zero.mp hn), zero_smul]

theorem dp_null_of_ne_zero {n : ℕ} (hn : n ≠ 0) : dp R n (0 : M) = 0 := by
  rw [dp_null R n, if_neg hn]

theorem dp_mul (n p : ℕ) (m : M) :
    dp R n m * dp R p m = (n + p).choose n • dp R (n + p) m := by
  simp only [dp_def, ← _root_.map_mul, ← map_nsmul]
  exact mkAlgHom_rel R Rel.mul

theorem dp_add (n : ℕ) (x y : M) :
    dp R n (x + y) = (antidiagonal n).sum fun k => dp R k.1 x * dp R k.2 y := by
  simp only [dp_def]
  rw [mkAlgHom_rel (A := MvPolynomial (ℕ × M) R) R Rel.add, map_sum,
    Finset.sum_congr rfl (fun k _ ↦ by rw [_root_.map_mul])]

theorem dp_sum {ι : Type*} [DecidableEq ι] (s : Finset ι) (q : ℕ) (x : ι → M) :
    dp R q (s.sum x) =
      (Finset.sym s q).sum fun k => s.prod fun i => dp R (Multiset.count i k) (x i) :=
  DividedPowers.dpow_sum' (I := ⊤) _ (fun {m} _ ↦ dp_zero R m)
    (fun {n x y} _ _ ↦ dp_add R n x y) (dp_null_of_ne_zero R) (fun _ _ ↦ trivial)

theorem dp_sum_smul {ι : Type*} [DecidableEq ι] (s : Finset ι) (q : ℕ) (a : ι → R) (x : ι → M) :
    dp R q (s.sum fun i => a i • x i) =
      (Finset.sym s q).sum fun k =>
        (s.prod fun i => a i ^ Multiset.count i k) •
          s.prod fun i => dp R (Multiset.count i k) (x i) := by
  simp_rw [dp_sum, dp_smul, Algebra.smul_def, map_prod, ← Finset.prod_mul_distrib]

open scoped Nat

theorem natFactorial_mul_dp_eq (n : ℕ) (x : M) :
    n ! * dp R n x = (dp R 1 x) ^ n := by
  induction n with
  | zero => simp [dp_zero]
  | succ n h  =>
    rw [pow_succ, ← h, mul_assoc, dp_mul]
    simp only [nsmul_eq_mul, ← mul_assoc, ← Nat.cast_mul]
    simp only [Nat.choose_succ_self_right, mul_comm _ (n+1), Nat.factorial_succ]

variable (M) in
/-- The canonical linear map `M →ₗ[R] DividedPowerAlgebra R M`. -/
def ι : M →ₗ[R] DividedPowerAlgebra R M := {
  toFun     := fun m ↦ dp R 1 m
  map_add'  := fun x y ↦ by
    simp only [dp_add]
    simp only [Nat.antidiagonal_succ, zero_add, antidiagonal_zero, map_singleton,
      Embedding.coe_prodMap, Embedding.coeFn_mk, Prod.map_apply, Nat.reduceSucc,
      Embedding.refl_apply, cons_eq_insert]
    simp only [mem_singleton, Prod.mk.injEq, zero_ne_one, one_ne_zero, and_self, not_false_eq_true,
      sum_insert, dp_zero, one_mul, sum_singleton, mul_one, add_comm]
  map_smul' := fun r x ↦ by
    simp only [dp_smul, pow_one, RingHom.id_apply] }

theorem ι_def (m : M) : ι R M m = dp R 1 m := rfl

variable {R}

theorem algHom_ext_iff {A : Type*} [CommSemiring A] [Algebra R A]
    {f g : DividedPowerAlgebra R M →ₐ[R] A} :
    (f = g) ↔ (∀ n m, f (dp R n m) = g (dp R n m)) := by
  refine ⟨fun h _ _ ↦ by rw [h], fun h ↦ ?_⟩
  . rw [DFunLike.ext'_iff]
    apply Function.Surjective.injective_comp_right (mkAlgHom_surjective R (Rel R M))
    simp only [← AlgHom.coe_comp, ← AlgHom.coe_comp, ← DFunLike.ext'_iff]
    exact MvPolynomial.algHom_ext fun ⟨n, m⟩ => h n m

@[ext]
theorem algHom_ext {A : Type*} [CommSemiring A] [Algebra R A]
    {f g : DividedPowerAlgebra R M →ₐ[R] A}
    (h : ∀ n m, f (dp R n m) = g (dp R n m)) : f = g :=
  algHom_ext_iff.mpr h

protected theorem induction_on {P : DividedPowerAlgebra R M → Prop} (f : DividedPowerAlgebra R M)
    (h_C : ∀ a, P (mk (C a))) (h_add : ∀ f g, P f → P g → P (f + g))
    (h_dp : ∀ (f : DividedPowerAlgebra R M) (n : ℕ) (m : M), P f → P (f * dp R n m)) : P f := by
  obtain ⟨F, hf⟩ := RingQuot.mkRingHom_surjective (DividedPowerAlgebra.Rel R M) f
  rw [← hf]
  induction F using MvPolynomial.induction_on generalizing f with
  | C a =>
      convert h_C a using 1;
      rw [mk, mkAlgHom, AlgHom.coe_mk]
  | add g1 g2 hg1 hg2 =>
      rw [map_add]
      exact h_add _ _ (hg1 ((mkRingHom (Rel R M)) g1) rfl) (hg2 ((mkRingHom (Rel R M)) g2) rfl)
  | mul_X g nm h =>
      have h' : (mkRingHom (Rel R M)) (X nm) = dp R nm.1 nm.2 := by
        simp only [dp_def, Prod.mk.eta, mkAlgHom, AlgHom.coe_mk]
      rw [_root_.map_mul, h']
      exact h_dp _ _ _ (h (mkRingHom (Rel R M) g) rfl)

variable (R)

section UniversalProperty

variable (M)

variable {A : Type*} [CommSemiring A] [Algebra R A]

theorem lift'_imp {f : ℕ × M → A} (hf_zero : ∀ m, f (0, m) = 1)
    (hf_smul : ∀ (n : ℕ) (r : R) (m : M), f ⟨n, r • m⟩ = r ^ n • f ⟨n, m⟩)
    (hf_mul : ∀ n p m, f ⟨n, m⟩ * f ⟨p, m⟩ = (n + p).choose n • f ⟨n + p, m⟩)
    (hf_add : ∀ n u v, f ⟨n, u + v⟩ = (antidiagonal n).sum fun (k, l) ↦ f ⟨k, u⟩ * f ⟨l, v⟩)
    (p q : MvPolynomial (ℕ × M) R) (h : (Rel R M) p q) :
    (eval₂AlgHom R f) p = (eval₂AlgHom R f) q := by
  rcases h <;>
  simp_all

variable {R M}
/-- The weak universal property of `DividedPowerAlgebra R M`. -/
def lift' {f : ℕ × M → A} (hf_zero : ∀ m, f (0, m) = 1)
    (hf_smul : ∀ (n : ℕ) (r : R) (m : M), f ⟨n, r • m⟩ = r ^ n • f ⟨n, m⟩)
    (hf_mul : ∀ n p m, f ⟨n, m⟩ * f ⟨p, m⟩ = (n + p).choose n • f ⟨n + p, m⟩)
    (hf_add : ∀ n u v, f ⟨n, u + v⟩ = (antidiagonal n).sum fun (k, l) ↦ f ⟨k, u⟩ * f ⟨l, v⟩) :
    DividedPowerAlgebra R M →ₐ[R] A :=
  RingQuot.liftAlgHom R
    {val := eval₂AlgHom R f, property := lift'_imp R M hf_zero hf_smul hf_mul hf_add }

@[simp]
theorem lift'_apply {f : ℕ × M → A} (hf_zero : ∀ m, f (0, m) = 1)
    (hf_smul : ∀ (n : ℕ) (r : R) (m : M), f ⟨n, r • m⟩ = r ^ n • f ⟨n, m⟩)
    (hf_mul : ∀ n p m, f ⟨n, m⟩ * f ⟨p, m⟩ = (n + p).choose n • f ⟨n + p, m⟩)
    (hf_add : ∀ n u v, f ⟨n, u + v⟩ = (antidiagonal n).sum fun (k, l) => f ⟨k, u⟩ * f ⟨l, v⟩)
    (p : MvPolynomial (ℕ × M) R) :
    lift' hf_zero hf_smul hf_mul hf_add (mk p) = aeval f p := by
  rw [mk, lift', RingQuot.liftAlgHom_mkAlgHom_apply, coe_eval₂AlgHom]
  rfl

@[simp]
theorem lift'_apply_dp {f : ℕ × M → A} (hf_zero : ∀ m, f (0, m) = 1)
    (hf_smul : ∀ (n : ℕ) (r : R) (m : M), f ⟨n, r • m⟩ = r ^ n • f ⟨n, m⟩)
    (hf_mul : ∀ n p m, f ⟨n, m⟩ * f ⟨p, m⟩ = (n + p).choose n • f ⟨n + p, m⟩)
    (hf_add : ∀ n u v, f ⟨n, u + v⟩ = (antidiagonal n).sum fun (k, l) => f ⟨k, u⟩ * f ⟨l, v⟩)
    (n : ℕ) (m : M) :
    lift' hf_zero hf_smul hf_mul hf_add (dp R n m) = f ⟨n, m⟩ := by
  rw [dp_def, ← mk, lift'_apply hf_zero hf_smul hf_mul hf_add, aeval_X]

variable {I : Ideal A} (hI : DividedPowers I) (φ : M →ₗ[R] A) (hφ : ∀ m, φ m ∈ I)

/-- The weak universal property of a divided power algebra for morphisms to divided power rings -/
def lift : DividedPowerAlgebra R M →ₐ[R] A :=
  lift' (f := fun nm => hI.dpow nm.1 (φ nm.2))
    (fun m => hI.dpow_zero (hφ m))
    (fun n r m => by
      dsimp only
      rw [LinearMap.map_smulₛₗ, RingHom.id_apply, ← algebraMap_smul A r (φ m), smul_eq_mul,
        hI.dpow_mul (hφ m), ← smul_eq_mul, ← map_pow, algebraMap_smul])
    (fun n p m => by rw [hI.mul_dpow (hφ m), ← nsmul_eq_mul])
    (fun n u v => by simp [hI.dpow_add (hφ u) (hφ v)])

variable {φ}

@[simp]
theorem lift_apply (p : MvPolynomial (ℕ × M) R) :
    lift hI φ hφ (mk p) = aeval (fun nm : ℕ × M => hI.dpow nm.1 (φ nm.2)) p := by
  rw [lift, lift'_apply]

@[simp]
theorem lift_apply_dp (n : ℕ) (m : M) :
    lift hI φ hφ (dp R n m) = hI.dpow n (φ m) := by rw [lift, lift'_apply_dp]

theorem lift_unique {f : DividedPowerAlgebra R M →ₐ[R] A}
    (hf : ∀ n m, f (dp R n m) = hI.dpow n (φ  m)) : f = lift hI φ hφ :=
  algHom_ext (fun _ _ ↦ by rw [lift_apply_dp, hf])

@[simp]
theorem lift_ι_apply (m : M) : lift hI φ hφ (ι R M m) = φ m := by
  simp [ι_def, hI.dpow_one (hφ m)]

@[simp]
theorem ι_comp_lift : (lift hI φ hφ).toLinearMap.comp (ι R M) = φ := by
  ext; simp

end UniversalProperty

section Functoriality

namespace LinearMap

variable {R}

variable {S : Type*} [CommSemiring S] {N : Type*} [AddCommMonoid N] [Module R N] [Module S N]
  (f : M →ₗ[R] N)

lemma dp_zero (a : M) : dp S 0 (f a) = 1 := DividedPowerAlgebra.dp_zero S (f a)

lemma dp_mul (m n : ℕ) (a : M) :
    dp S m (f a) * dp S n (f a) = (Nat.choose (m + n) m) • dp S (m + n) (f a) :=
  DividedPowerAlgebra.dp_mul S m n (f a)

lemma dp_add (n : ℕ) (a b : M) :
    dp S n (f (a + b)) = (Finset.antidiagonal n).sum fun k => dp S k.1 (f a) * dp S k.2 (f b) := by
  rw [map_add, DividedPowerAlgebra.dp_add]

section IsScalarTower

variable (S)

variable [Algebra R S] [IsScalarTower R S N]

lemma dp_smul (n : ℕ) (r : R) (a : M) : dp S n (f (r • a)) = r ^ n • dp S n (f a) := by
  rw [f.map_smul, algebra_compatible_smul S r (f a),
    DividedPowerAlgebra.dp_smul S ((algebraMap R S) r) n (f a), ← map_pow, algebraMap_smul]

/-- The functoriality map between divided power algebras associated with a linear map of the
  underlying modules.
  Given an `R`-algebra `S`, an `S`-module `N` and an `R`-linear map `f : M →ₗ[R] N`,
  this is the map `DividedPowerAlgebra R M →ₐ[R] DividedPowerAlgebra S N`
  sending `dp R n m` to `dp S n (f m)`. -/
protected def lift : DividedPowerAlgebra R M →ₐ[R] DividedPowerAlgebra S N :=
  DividedPowerAlgebra.lift' (f := fun nm => dp S nm.fst (f nm.snd))
    (LinearMap.dp_zero f) (LinearMap.dp_smul S f) (LinearMap.dp_mul f) (LinearMap.dp_add f)

theorem lift_apply (p : MvPolynomial (ℕ × M) R) :
    LinearMap.lift S f (mk p) = aeval (fun nm => dp S nm.fst (f nm.snd)) p := by
  rw [LinearMap.lift, lift'_apply]

theorem lift_apply_dp (n : ℕ) (a : M) : LinearMap.lift S f (dp R n a) = dp S n (f a) := by
  rw [LinearMap.lift, lift'_apply_dp]

@[simp]
theorem lift_ι_apply (m : M) : LinearMap.lift S f (ι R M m) = ι S N (f m) := by
  simp [ι_def, LinearMap.lift_apply_dp]

theorem lift_comp_ι :
    (LinearMap.lift S f).toLinearMap.comp (ι R M) = ((ι S N).restrictScalars R).comp f := by
  ext; simp

theorem lift_surjective {f : M →ₗ[R] N} (hf : Function.Surjective f) :
    Function.Surjective (LinearMap.lift R f) := by
  rw [← AlgHom.range_eq_top, ← Algebra.map_top (LinearMap.lift R f), eq_top_iff,
    ← (AlgHom.range_eq_top mk).mpr mk_surjective, ← Algebra.map_top,
    (Subalgebra.gc_map_comap _).le_iff_le, ← MvPolynomial.adjoin_range_X, Algebra.adjoin_le_iff]
  intro
  simp only [Set.mem_range, Prod.exists]
  rintro ⟨n, m, rfl⟩
  obtain ⟨l, rfl⟩ := hf m
  simp [Algebra.map_top, Subalgebra.coe_comap, AlgHom.coe_range, Set.mem_preimage,
    Set.mem_range]
  use dp R n l
  simp [LinearMap.lift_apply_dp]
  rfl

end IsScalarTower

end LinearMap

variable {R} (S : Type*) [CommSemiring S] {N : Type*} [AddCommMonoid N] [Module R N] [Module S N]
  (f : M →ₗ[R] N)

section IsScalarTower

variable [Algebra R S] [IsScalarTower R S N] {P : Type*} [AddCommMonoid P] [Module R P]

-- is there a variant where a ring T acts on P?

lemma LinearMap.lift_comp (f : M →ₗ[R] N) (g : N →ₗ[R] P) :
    LinearMap.lift R (g.comp f) = (LinearMap.lift R g).comp (LinearMap.lift R f) := by
  rw [algHom_ext_iff]
  intros; simp [lift_apply_dp]

lemma LinearMap.lift_id :
    LinearMap.lift R (LinearMap.id (R := R) (M := M)) = AlgHom.id R _ := by
  rw [algHom_ext_iff]
  intros
  simp [lift_apply_dp]

/-- The functoriality map between divided power algebras associated with a linear equivalence of the
  underlying modules.
  Given an `R`-algebra `S`, an `S`-module `N` and an `R`-linear equivalence `f : M →ₗ[R] N`,
  this is the map `DividedPowerAlgebra R M →ₐ[R] DividedPowerAlgebra S N`
  sending `dp R n m` to `dp S n (f m)`. -/
def LinearEquiv.lift (g : M ≃ₗ[R] N) :
    DividedPowerAlgebra R M ≃ₐ[R] DividedPowerAlgebra R N :=
  AlgEquiv.ofAlgHom (LinearMap.lift R g.toLinearMap) (LinearMap.lift R g.symm.toLinearMap)
    (by simp [← LinearMap.lift_comp, LinearMap.lift_id])
    (by simp [← LinearMap.lift_comp, LinearMap.lift_id])

theorem LinearEquiv.lift_symm (g : M ≃ₗ[R] N) :
    (LinearEquiv.lift g).symm = LinearEquiv.lift g.symm := rfl

theorem LinearEquiv.coe_lift (g : M ≃ₗ[R] N) :
    LinearEquiv.lift g = LinearMap.lift R g.toLinearMap := rfl

theorem LinearEquiv.coe_lift_symm (g : M ≃ₗ[R] N) :
    (LinearEquiv.lift g).symm = LinearMap.lift R g.symm.toLinearMap := rfl

theorem LinearEquiv.lift_refl :
    LinearEquiv.lift (LinearEquiv.refl R M) = AlgEquiv.refl :=
  AlgEquiv.coe_algHom_injective (by exact LinearMap.lift_id)

theorem LinearEquiv.lift_trans (g : M ≃ₗ[R] N) (h : N ≃ₗ[R] P) :
    (LinearEquiv.lift g).trans (LinearEquiv.lift h) = LinearEquiv.lift (g.trans h) :=
  AlgEquiv.coe_algHom_injective (by exact (LinearMap.lift_comp _ _).symm)

end IsScalarTower

end Functoriality

end DividedPowerAlgebra
