/-
Copyright (c) 2024 Antoine Chambert-Loir, María Inés de Frutos-Fernández. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir, María Inés de Frutos-Fernández
-/
import DividedPowers.ForMathlib.Algebra.MvPolynomial.Lemmas
import Mathlib.Algebra.MvPolynomial.Supported
import Mathlib.Algebra.RingQuot
import Mathlib.Algebra.TrivSqZeroExt
import Mathlib.RingTheory.Ideal.Maps
import Mathlib.RingTheory.MvPolynomial.WeightedHomogeneous

noncomputable section

open Finset MvPolynomial RingQuot DirectSum Ideal Ideal.Quotient

section IdealsAndRel

namespace Ideal

theorem pow_eq_bot {R : Type*} [CommSemiring R] [NoZeroDivisors R] {I : Ideal R} {n : ℕ}
    (hn : n ≠ 0) : I ^ n = ⊥ ↔ I = ⊥ := by
  induction n with
  | zero => exfalso; exact hn (Eq.refl _)
  | succ n ih =>
    by_cases hn0 : n = 0
    · rw [hn0, pow_one]
    · rw [pow_succ, mul_eq_bot, ih hn0, or_self_iff]

namespace Quotient

variable (R : Type*) [CommRing R] {S : Type*}  [CommRing S]

theorem mk_eq_ringQuot_apply [Algebra R S] (r : S → S → Prop) (s : S) :
    mk (ofRel r) s = ringQuotToIdealQuotient r (mkAlgHom R r s) := by
  rw [← ringQuotToIdealQuotient_apply r s, ← mkAlgHom_coe R r]; rfl

theorem mk_eq_ofRel {r : S → S → Prop} {s t : S} (h : r s t) :
    mk (ofRel r) s = mk (ofRel r) t := by
  suffices hinj : Function.Injective (RingQuot.ringQuotEquivIdealQuotient r).invFun by
    apply hinj; exact mkRingHom_rel h
  rw [Function.injective_iff_hasLeftInverse]
  exact ⟨(ringQuotEquivIdealQuotient r).toFun, (ringQuotEquivIdealQuotient r).right_inv⟩

variable {R}

theorem rel_le_ker (I : Ideal R) {r : R → R → Prop} (hr : I = ofRel r) (f : R →+* S)
    (hf : ∀ {a b : R}, r a b → f a = f b) : I ≤ RingHom.ker f := by
  rw [hr, ofRel, Submodule.span_le]
  rintro x ⟨a, b, hx, hab⟩
  rw [eq_sub_iff_add_eq.mpr hab, SetLike.mem_coe, RingHom.mem_ker, map_sub, sub_eq_zero, hf hx]

/-- Given a binary relation `r` on `R` and a ring homomorphism `f : R →+* S` that is constant on
  each equivalent class of `r`, lift `f` to the quotient by the ideal generated by `r`. -/
def liftRel (I : Ideal R) {r : R → R → Prop} (hr : I = ofRel r) (f : R →+* S)
    (hf : ∀ {a b : R}, r a b → f a = f b) : R ⧸ I →+* S :=
  lift I f (rel_le_ker I hr f hf)

end Quotient

end Ideal

end IdealsAndRel


open Ideal Ideal.Quotient

section

open MvPolynomial

variable (R : Type*)  [CommSemiring R] {M : Type*}

/-- The weighted graded algebra structure on `MvPolynomial (ℕ × M) R`. -/
local instance :
    GradedAlgebra (weightedHomogeneousSubmodule R (Prod.fst : ℕ × M → ℕ)) :=
  weightedGradedAlgebra _ _

-- Unused
/-
def degree (v : ℕ × M →₀ ℕ) : ℕ :=
  finsum fun x => v x * x.1

def IsHomogeneousOfDegree (p : MvPolynomial (ℕ × M) R) (n : ℕ) : Prop :=
  ∀ v ∈ p.support, _root_.degree v = n -/

variable (M)

-- TODO: generalize
theorem eq_finsupp_single_of_degree_one [DecidableEq M] {d : ℕ × M →₀ ℕ}
    (hd : (Finsupp.weight Prod.fst) d = 1) (hsupp : ∀ nm ∈ d.support, 0 < nm.fst) :
    ∃ m : M, Finsupp.single (1, m) 1 = d := by
  rw [Finsupp.weight_apply, Finsupp.sum] at hd
  have hnm : ∃ nm : ℕ × M, d nm • nm.fst = 1 := by
    by_contra h0
    rw [not_exists] at h0
    have hd0 : (d.support.sum fun a : ℕ × M => d a • a.fst) = 0 := by
      rw [Finset.sum_eq_zero (fun nm hnm ↦ Nat.lt_one_iff.mp <| lt_of_le_of_ne
        (hd ▸ Finset.single_le_sum (fun x _ => zero_le (d x • x.fst)) hnm) (h0 nm))]
    rw [hd0] at hd
    exact zero_ne_one hd
  obtain ⟨nm, hnm⟩ := hnm
  rw [← hnm] at hd
  simp only [Algebra.id.smul_eq_mul, mul_eq_one] at hnm
  use nm.snd
  ext ab
  rw [Finsupp.single_apply]
  split_ifs with hab <;> rw [← hnm.2, eq_comm, Prod.mk.eta] at hab
  · rw [hab, hnm.1]
  · rw [eq_comm]
    by_contra hab'
    have hne0 : d ab * ab.fst ≠ 0 :=
      mul_ne_zero hab' (ne_of_gt (hsupp ab (Finsupp.mem_support_iff.mpr hab')))
    have hnm_mem : nm ∈ d.support := by rw [Finsupp.mem_support_iff, hnm.1]; exact one_ne_zero
    simp only [Finset.sum_eq_sum_diff_singleton_add hnm_mem, add_eq_right,
      Algebra.id.smul_eq_mul, sum_eq_zero_iff, mem_sdiff,
      Finsupp.mem_support_iff, mem_singleton] at hd
    exact hne0 (hd ab ⟨hab', hab⟩)

end
