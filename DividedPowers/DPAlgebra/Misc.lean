/-
Copyright (c) 2024 Antoine Chambert-Loir, María Inés de Frutos-Fernández. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir, María Inés de Frutos-Fernández
-/
import DividedPowers.ForMathlib.Algebra.MvPolynomial.Lemmas
import Mathlib.Algebra.MvPolynomial.Supported
import Mathlib.Algebra.RingQuot
import Mathlib.Algebra.TrivSqZeroExt
import Mathlib.RingTheory.Ideal.Maps
import Mathlib.RingTheory.MvPolynomial.WeightedHomogeneous

noncomputable section

open Finset MvPolynomial RingQuot DirectSum Ideal Ideal.Quotient

section IdealsAndRel

namespace Ideal

theorem pow_eq_bot {R : Type*} [CommSemiring R] [NoZeroDivisors R] {I : Ideal R} {n : ℕ}
    (hn : n ≠ 0) : I ^ n = ⊥ ↔ I = ⊥ := by
  induction n with
  | zero => exfalso; exact hn (Eq.refl _)
  | succ n ih =>
    by_cases hn0 : n = 0
    · rw [hn0, pow_one]
    · rw [pow_succ, mul_eq_bot, ih hn0, or_self_iff]

namespace Quotient

variable (R : Type*) [CommRing R] {S : Type*}  [CommRing S]

theorem mk_eq_ringQuot_apply [Algebra R S] (r : S → S → Prop) (s : S) :
    mk (ofRel r) s = ringQuotToIdealQuotient r (mkAlgHom R r s) := by
  rw [← ringQuotToIdealQuotient_apply r s, ← mkAlgHom_coe R r]; rfl

theorem mk_eq_ofRel {r : S → S → Prop} {s t : S} (h : r s t) :
    mk (ofRel r) s = mk (ofRel r) t := by
  suffices hinj : Function.Injective (RingQuot.ringQuotEquivIdealQuotient r).invFun by
    apply hinj; exact mkRingHom_rel h
  rw [Function.injective_iff_hasLeftInverse]
  exact ⟨(ringQuotEquivIdealQuotient r).toFun, (ringQuotEquivIdealQuotient r).right_inv⟩

variable {R}

theorem rel_le_ker (I : Ideal R) {r : R → R → Prop} (hr : I = ofRel r) (f : R →+* S)
    (hf : ∀ {a b : R}, r a b → f a = f b) : I ≤ RingHom.ker f := by
  rw [hr, ofRel, Submodule.span_le]
  rintro x ⟨a, b, hx, hab⟩
  rw [eq_sub_iff_add_eq.mpr hab, SetLike.mem_coe, RingHom.mem_ker, map_sub, sub_eq_zero, hf hx]

/-- Given a binary relation `r` on `R` and a ring homomorphism `f : R →+* S` that is constant on
  each equivalent class of `r`, lift `f` to the quotient by the ideal generated by `r`. -/
def liftRel (I : Ideal R) {r : R → R → Prop} (hr : I = ofRel r) (f : R →+* S)
    (hf : ∀ {a b : R}, r a b → f a = f b) : R ⧸ I →+* S :=
  lift I f (rel_le_ker I hr f hf)

end Quotient

end Ideal

end IdealsAndRel


open Ideal Ideal.Quotient

section

open MvPolynomial

variable (R : Type*)  [CommSemiring R] {M : Type*}

/-- The weighted graded algebra structure on `MvPolynomial (ℕ × M) R`. -/
local instance :
    GradedAlgebra (weightedHomogeneousSubmodule R (Prod.fst : ℕ × M → ℕ)) :=
  weightedGradedAlgebra _ _





end
