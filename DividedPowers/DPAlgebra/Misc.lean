/- Copyright 2022 ACL & MIdFF
! This file was ported from Lean 3 source module divided_powers.dp_algebra.misc
-/

import Mathlib.Algebra.MvPolynomial.Supported
import Mathlib.Algebra.RingQuot
import Mathlib.Algebra.TrivSqZeroExt
import Mathlib.RingTheory.Ideal.Maps
import Mathlib.RingTheory.MvPolynomial.WeightedHomogeneous

noncomputable section

open Finset MvPolynomial RingQuot DirectSum Ideal Ideal.Quotient

theorem Ideal.pow_eq_bot {R : Type _} [CommSemiring R] [NoZeroDivisors R]
    {I : Ideal R} {n : ‚Ñï} (hn : n ‚â† 0) :
  I ^ n = ‚ä• ‚Üî I = ‚ä• := by
  induction' n with n ih
  ¬∑ exfalso; exact hn (Eq.refl _)
  ¬∑ by_cases hn0 : n = 0
    ¬∑ rw [hn0, pow_one]
    ¬∑ rw [pow_succ, mul_eq_bot, ih hn0, or_self_iff]

namespace MvPolynomial

variable {R S œÉ : Type _} [CommSemiring R] [CommSemiring S]

@[simp]
theorem eval‚ÇÇHom.smul (f : R ‚Üí+* S) (g : œÉ ‚Üí S) (r : R) (P : MvPolynomial œÉ R) :
    eval‚ÇÇHom f g (r ‚Ä¢ P) = f r ‚Ä¢ eval‚ÇÇHom f g P := by
  simp only [smul_eq_C_mul, coe_eval‚ÇÇHom, eval‚ÇÇ_mul, eval‚ÇÇ_C, Algebra.id.smul_eq_mul]

variable [Algebra R S]

variable (R)

/-- `MvPolynomial.eval‚ÇÇ (algebraMap R S) g` as an `R`-algebra homomorphism. -/
def eval‚ÇÇAlgHom (g : œÉ ‚Üí S) : MvPolynomial œÉ R ‚Üí‚Çê[R] S :=
  { eval‚ÇÇHom (algebraMap R S) g with
    commutes' := fun r => by rw [RingHom.toFun_eq_coe, coe_eval‚ÇÇHom, algebraMap_eq, eval‚ÇÇ_C] }

variable {R}

theorem eval‚ÇÇAlgHom_apply (g : œÉ ‚Üí S) (P : MvPolynomial œÉ R) :
  eval‚ÇÇAlgHom R g P = eval‚ÇÇHom (algebraMap R S) g P := rfl

@[simp]
theorem coe_eval‚ÇÇAlgHom (g : œÉ ‚Üí S) :
  ‚áë(eval‚ÇÇAlgHom R g) = eval‚ÇÇ (algebraMap R S) g := rfl

@[simp]
theorem eval‚ÇÇAlgHom_X' (g : œÉ ‚Üí S) (i : œÉ) :
  eval‚ÇÇAlgHom R g (X i : MvPolynomial œÉ R) = g i := eval‚ÇÇ_X (algebraMap R S) g i

end MvPolynomial

section IdealsAndRel

theorem quotient_mk_eq_ofRel {A : Type _} [CommRing A] {r : A ‚Üí A ‚Üí Prop}
    {a b : A} (h : r a b) :
  mk (ofRel r) a = mk (ofRel r) b := by
  suffices hinj : Function.Injective (RingQuot.ringQuotEquivIdealQuotient r).invFun by
    apply hinj; exact mkRingHom_rel h
  rw [Function.injective_iff_hasLeftInverse]
  exact ‚ü®(ringQuotEquivIdealQuotient r).toFun, (ringQuotEquivIdealQuotient r).right_inv‚ü©

namespace Ideal

theorem quotient_mk_eq_ringQuot_apply (R : Type _) [CommRing R] {A : Type _} [CommRing A]
    [Algebra R A] (r : A ‚Üí A ‚Üí Prop) (a : A) :
    mk (ofRel r) a = ringQuotToIdealQuotient r (mkAlgHom R r a) := by
  rw [‚Üê ringQuotToIdealQuotient_apply r a, ‚Üê mkAlgHom_coe R r]
  rfl

namespace Quotient

variable {R S : Type _} [CommRing R] [CommRing S]

theorem rel_le_ker (I : Ideal R) {r : R ‚Üí R ‚Üí Prop} (hr : I = ofRel r) (f : R ‚Üí+* S)
    (hf : ‚àÄ {a b : R}, r a b ‚Üí f a = f b) : I ‚â§ RingHom.ker f := by
  rw [hr, ofRel, Submodule.span_le]
  rintro x ‚ü®a, b, hx, hab‚ü©
  rw [eq_sub_iff_add_eq.mpr hab, SetLike.mem_coe, RingHom.mem_ker, map_sub, sub_eq_zero, hf hx]

/-- Given a binary relation `r` on `R` and a ring homomorphism `f : R ‚Üí+* S` that is constant on
  each equivalent class of `r`, lift `f` to the quotient by the ideal generated by `r`. -/
def liftRel (I : Ideal R) {r : R ‚Üí R ‚Üí Prop} (hr : I = ofRel r) (f : R ‚Üí+* S)
    (hf : ‚àÄ {a b : R}, r a b ‚Üí f a = f b) : R ‚ß∏ I ‚Üí+* S :=
  lift I f (rel_le_ker I hr f hf)


end Quotient

end Ideal

end IdealsAndRel

namespace TrivSqZeroExt

variable (R M : Type _) [CommSemiring R] [AddCommMonoid M] [Module R M] [Module R·µê·µí·µñ M]
  [IsCentralScalar R M]

def kerIdeal : Ideal (TrivSqZeroExt R M) :=
  RingHom.ker (fstHom R R M)

theorem mem_kerIdeal_iff_inr (x : TrivSqZeroExt R M) : x ‚àà kerIdeal R M ‚Üî x = inr x.snd :=
  by
  obtain ‚ü®r, m‚ü© := x
  simp only [kerIdeal, RingHom.mem_ker, fstHom_apply, fst_mk]
  exact ‚ü®fun hr => by rw [hr]; rfl, fun hrm => by rw [‚Üê fst_mk r m, hrm, fst_inr]‚ü©

theorem mem_kerIdeal_iff_exists (x : TrivSqZeroExt R M) : x ‚àà kerIdeal R M ‚Üî ‚àÉ m : M, x = inr m := by
  rw [mem_kerIdeal_iff_inr]
  exact ‚ü®fun h => ‚ü®x.snd, h‚ü©, fun ‚ü®m, hm‚ü© => by rw [hm]; rfl‚ü©

theorem sqZero : kerIdeal R M ^ 2 = (‚ä• : Ideal (TrivSqZeroExt R M)) :=
  by
  simp only [pow_two, zero_eq_bot, eq_bot_iff, mul_le, mem_kerIdeal_iff_inr]
  rintro x hx y hy
  rw [hx, hy, mem_bot, inr_mul_inr]

end TrivSqZeroExt

open Ideal Ideal.Quotient TrivSqZeroExt

section GradedAlgebra

section CommSemiring

variable {R : Type _} [CommSemiring R]

variable {A : Type _} [CommSemiring A] [Algebra R A]

variable {Œπ : Type _} [CanonicallyOrderedAddCommMonoid Œπ]

variable (ùíú : Œπ ‚Üí Submodule R A)

theorem gradeZero_coe_smul (r : R) (x : ùíú 0) : (‚Üë(r ‚Ä¢ x) : A) = r ‚Ä¢ x := rfl

variable [DecidableEq Œπ] [GradedAlgebra ùíú]

instance : One (ùíú 0) where
  one : ùíú 0 := ‚ü®1, SetLike.one_mem_graded ùíú‚ü©

instance : Mul (ùíú 0) where
  mul := fun x y => ‚ü®x * y, by
    convert SetLike.mul_mem_graded x.2 y.2
    rw [add_zero]‚ü©

@[simp]
theorem gradeZero_coe_mul (x y : ùíú 0) : (‚Üë(x * y) : A) = x * y := rfl

@[simp]
theorem gradeZero_val_mul (x y : ùíú 0) : (x * y).val = x.val * y.val := rfl

omit [DecidableEq Œπ] [GradedAlgebra ùíú] in
@[simp]
theorem gradeZero_coe_zero : (‚Üë(0 : ùíú 0) : A) = 0 := rfl

@[simp]
theorem gradeZero_coe_one : (‚Üë(1 : ùíú 0) : A) = 1 := rfl

theorem one_mem : (1 : A) ‚àà ùíú 0 := SetLike.one_mem_graded ùíú

example : AddCommMonoid (ùíú 0) :=
  inferInstance

instance gradeZeroCommSemiring : CommSemiring (ùíú 0) :=
  { (inferInstance : AddCommMonoid (ùíú 0)) with
    add := (¬∑ + ¬∑)
    zero := 0
    natCast_zero := by simp only [Nat.cast_zero]
    natCast_succ := fun n ‚Ü¶ by simp only [Nat.cast_succ] -- TODO: Zulip?
    one := 1
    mul := (¬∑ * ¬∑)
    zero_mul := fun x => by
      ext
      rw [gradeZero_coe_mul, gradeZero_coe_zero, zero_mul]
    mul_zero := fun x => by
      ext
      rw [gradeZero_coe_mul, gradeZero_coe_zero, mul_zero]
    mul_assoc := fun x y z => by
      ext
      simp only [gradeZero_coe_mul, mul_assoc]
    one_mul := fun x => by
      ext
      rw [gradeZero_coe_mul, gradeZero_coe_one, one_mul]
    mul_one := fun x => by
      ext
      rw [gradeZero_coe_mul, gradeZero_coe_one, mul_one]
    left_distrib := fun x y z => by
      ext
      simp only [Submodule.coe_add, gradeZero_coe_mul, left_distrib]
    right_distrib := fun x y z => by
      ext
      simp only [Submodule.coe_add, gradeZero_coe_mul, right_distrib]
    mul_comm := fun x y => by
      ext
      simp only [gradeZero_coe_mul, mul_comm]
     }

instance gradeZeroAlgebra : Algebra R (ùíú 0) :=
  Algebra.ofModule'
    (fun r x => by
      ext
      simp only [gradeZero_coe_mul, gradeZero_coe_smul, SetLike.val_smul,
        gradeZero_coe_one, Algebra.smul_mul_assoc, one_mul])
    (fun r x => by
      ext
      simp only [gradeZero_coe_mul, gradeZero_coe_smul, SetLike.val_smul,
        gradeZero_coe_one, Algebra.mul_smul_comm, mul_one])

/-- The projection from `A` to the degree `i` component `ùíú i`, as an `R`-linear map. -/
def proj (i : Œπ) : A ‚Üí‚Çó[R] ùíú i where
  toFun a := decompose ùíú a i
  map_add' a b := by simp only [decompose_add, add_apply]
  map_smul' r a := by
    simp only [decompose_smul, RingHom.id_apply]
    rfl

@[simps]
def projZeroRingHom' : A ‚Üí+* ùíú 0 where
  toFun a := proj ùíú 0 a
  map_one' := by
    ext
    simp only [proj, LinearMap.coe_mk, AddHom.coe_mk,
     decompose_of_mem_same ùíú (one_mem ùíú), gradeZero_coe_one]
  map_zero' := by simp only [proj, decompose_zero, LinearMap.coe_mk, AddHom.coe_mk, zero_apply]
  map_add' _ _ := by simp only [proj, decompose_add, LinearMap.coe_mk, AddHom.coe_mk, add_apply]
  map_mul' x y := by
    ext
    simp only [proj, LinearMap.coe_mk, AddHom.coe_mk, SetLike.coe_eq_coe,
      gradeZero_coe_mul, ‚Üê GradedRing.projZeroRingHom_apply ùíú, ‚Üê _root_.map_mul]

end CommSemiring

section CommRing

variable {R : Type _} [CommRing R]

variable {A : Type _} [CommRing A] [Algebra R A]

variable {Œπ : Type _} [CanonicallyOrderedAddCommMonoid Œπ]

variable (ùíú : Œπ ‚Üí Submodule R A) [DecidableEq Œπ] [GradedAlgebra ùíú]

instance gradeZeroCommRing : CommRing (ùíú 0) :=
{ (inferInstance : AddCommGroup (ùíú 0)) with
    add := (¬∑ + ¬∑)
    zero := 0
    one := 1
    mul := (¬∑ * ¬∑)
    natCast_zero := by simp only [Nat.cast_zero]
    natCast_succ := fun n ‚Ü¶ by simp only [Nat.cast_succ]
    intCast_ofNat := fun n ‚Ü¶ by simp only [Int.cast_natCast]
    intCast_negSucc := fun n ‚Ü¶ by rw [‚Üê Int.cast_negSucc]
    zero_mul := fun x => by
      ext
      rw [gradeZero_coe_mul, gradeZero_coe_zero, zero_mul]
    mul_zero := fun x => by
      ext
      rw [gradeZero_coe_mul, gradeZero_coe_zero, mul_zero]
    mul_assoc := fun x y z => by
      ext
      simp only [gradeZero_coe_mul, mul_assoc]
    one_mul := fun x => by
      ext
      rw [gradeZero_coe_mul, gradeZero_coe_one, one_mul]
    mul_one := fun x => by
      ext
      rw [gradeZero_coe_mul, gradeZero_coe_one, mul_one]
    left_distrib := fun x y z => by
      ext
      simp only [Submodule.coe_add, gradeZero_coe_mul, left_distrib]
    right_distrib := fun x y z => by
      ext
      simp only [Submodule.coe_add, gradeZero_coe_mul, right_distrib]
    mul_comm := fun x y => by
      ext
      simp only [gradeZero_coe_mul, mul_comm]
     }

end CommRing

end GradedAlgebra

section GradedAlgebra

variable {R : Type _} [CommSemiring R]
variable {S : Type _} [CommSemiring S] [Algebra R S]

def GalgHom.IsHomogeneous {Œπ : Type _}
    {A : Type _} [CommSemiring A] [Algebra R A] (ùíú : Œπ ‚Üí Submodule R A)
    {B : Type _} [CommSemiring B] [Algebra S B] [Algebra R B] [IsScalarTower R S B]
    (‚Ñ¨ : Œπ ‚Üí Submodule S B) (f : A ‚Üí‚Çê[R] B) :=
  ‚àÄ i a, a ‚àà ùíú i ‚Üí f a ‚àà ‚Ñ¨ i

theorem Finsupp.prod.mem_grade
    {Œ∫ A : Type _} [AddCommMonoid Œ∫] [DecidableEq Œ∫] [CommSemiring A] [Algebra R A]
    (ùíú : Œ∫ ‚Üí Submodule R A) [GradedAlgebra ùíú]
    {œÉ : Type _} (c : œÉ ‚Üí‚ÇÄ ‚Ñï) (f : œÉ ‚Üí A) (d : œÉ ‚Üí Œ∫)
    (hc : ‚àÄ s ‚àà c.support, f s ‚àà ùíú (d s)) :
  (c.prod fun s e => f s ^ e) ‚àà ùíú (c.sum fun s e => e ‚Ä¢ d s) := by
  classical
  rw [Finsupp.prod, Finsupp.sum]
  let p : Finset œÉ ‚Üí Prop := fun s =>
    s ‚äÜ c.support ‚Üí (s.prod fun i => f i ^ c i) ‚àà ùíú (s.sum fun i => c i ‚Ä¢ d i)
  apply @Finset.induction_on œÉ p _ c.support
  ¬∑ exact imp_intro (SetLike.one_mem_graded ùíú)
  ¬∑ intro a s ha hs hs'
    rw [Finset.prod_insert ha, Finset.sum_insert ha]
    exact
      SetLike.mul_mem_graded (SetLike.pow_mem_graded _ (hc a (hs' (mem_insert_self a s))))
        (hs (subset_trans (subset_insert a s) hs'))
  ¬∑ exact subset_rfl

def GalgHom.isHomogeneous'
    {Œπ Œ∫ : Type _} (A : Type _) [CommSemiring A] [Algebra R A]
    (ùíú : Œπ ‚Üí Submodule R A)
    (B : Type _) [CommSemiring B] [Algebra R B] [Algebra S B] [IsScalarTower R S B]
    (‚Ñ¨ : Œ∫ ‚Üí Submodule S B) (œÜ : Œπ ‚Üí Œ∫) (f : A ‚Üí‚Çê[R] B) :=
  ‚àÄ i a, a ‚àà ùíú i ‚Üí f a ‚àà ‚Ñ¨ (œÜ i)

/-- The evaluation of a weighted homogeneous polynomial at
  elements of adequate grades is homogeneous -/
theorem GalgHom.isHomogeneous'_aeval (œÉ : Type _)
    {Œπ Œ∫ : Type _} [AddCommMonoid Œπ] [AddCommMonoid Œ∫] [DecidableEq Œ∫]
    (A : Type _) [CommSemiring A] [Algebra R A]
    (ùíú : Œ∫ ‚Üí Submodule R A) [GradedAlgebra ùíú]
    (w : œÉ ‚Üí Œπ) (œÜ : Œπ ‚Üí+ Œ∫) (f : œÉ ‚Üí A) (h : ‚àÄ s : œÉ, f s ‚àà ùíú (œÜ (w s))) :
    GalgHom.isHomogeneous' (MvPolynomial œÉ R)
      (weightedHomogeneousSubmodule R w) A ùíú œÜ (MvPolynomial.aeval f) := by
  intro i p hp
  simp only [mem_weightedHomogeneousSubmodule, IsWeightedHomogeneous] at hp
  rw [p.as_sum, map_sum]
  apply Submodule.sum_mem
  intro c hc
  rw [aeval_monomial, ‚Üê smul_eq_mul, algebraMap_smul]
  apply Submodule.smul_mem
  convert Finsupp.prod.mem_grade ùíú c f _ fun s _ => h s
  rw [‚Üê hp (mem_support_iff.mp hc), Finsupp.weight_apply]
  rw [Finsupp.sum, map_sum, Finsupp.sum_of_support_subset _ le_rfl]
  apply Finset.sum_congr rfl
  . intro x _ ; simp only [map_nsmul]
  . intro s _ ; simp only [zero_smul]

end GradedAlgebra

theorem MvPolynomial.vars_X_subset {R : Type _} {œÉ : Type _} (n : œÉ) [CommSemiring R] :
    (X n : MvPolynomial œÉ R).vars ‚äÜ {n} := by
  classical
  intro u
  rw [X, mem_vars, mem_singleton]
  rintro ‚ü®c, hc, hc'‚ü©
  by_contra h'
  rw [mem_support_iff, coeff_monomial, ne_eq] at hc
  by_cases h : Finsupp.single n 1 = c
  ¬∑ rw [‚Üê h, Finsupp.mem_support_iff, ne_eq, Finsupp.single_apply] at hc'
    apply hc'; rw [if_neg (Ne.symm h')]
  ¬∑ apply hc; rw [if_neg h]

section

open MvPolynomial

variable {R M : Type _} [CommSemiring R]

local instance [DecidableEq R] [DecidableEq M] :
    GradedAlgebra (weightedHomogeneousSubmodule R (Prod.fst : ‚Ñï √ó M ‚Üí ‚Ñï)) :=
  weightedGradedAlgebra _ _

def degree (v : ‚Ñï √ó M ‚Üí‚ÇÄ ‚Ñï) : ‚Ñï :=
  finsum fun x => v x * x.1

def IsHomogeneousOfDegree (p : MvPolynomial (‚Ñï √ó M) R) (n : ‚Ñï) : Prop :=
  ‚àÄ v ‚àà p.support, _root_.degree v = n

variable (R)

theorem variable_mem_supported (nm : ‚Ñï √ó M) (hn : 0 < nm.1) :
    X nm ‚àà supported R {nm : ‚Ñï √ó M | 0 < nm.1} := by
  rw [mem_supported]
  refine' Set.Subset.trans (Finset.coe_subset.mpr (vars_X_subset nm)) _
  rw [coe_singleton, Set.singleton_subset_iff, Set.mem_setOf_eq]
  exact hn

def toSupported : MvPolynomial (‚Ñï √ó M) R ‚Üí‚Çê[R] supported R {nm : ‚Ñï √ó M | 0 < nm.1} :=
  aeval fun nm : ‚Ñï √ó M =>
    dite (0 < nm.1) (fun h => ‚ü®X nm, variable_mem_supported R nm h‚ü©) fun _ => 1

theorem toSupported_isHomogeneous' [DecidableEq M] [DecidableEq R] :
    GalgHom.isHomogeneous' (MvPolynomial (‚Ñï √ó M) R)
      (weightedHomogeneousSubmodule R (Prod.fst : ‚Ñï √ó M ‚Üí ‚Ñï)) (MvPolynomial (‚Ñï √ó M) R)
      (weightedHomogeneousSubmodule R Prod.fst) (id : ‚Ñï ‚Üí ‚Ñï)
      ((Subalgebra.val _).comp (toSupported R)) := by
  have heq : aeval
    ((supported R {nm : ‚Ñï √ó M | 0 < nm.fst}).val.toFun ‚àò
        fun nm : ‚Ñï √ó M =>
          if h : 0 < nm.fst
          then ‚ü®X nm, variable_mem_supported R nm h‚ü©
          else 1) =
      (supported R {nm : ‚Ñï √ó M | 0 < nm.fst}).val.comp (toSupported R) :=
    by
    apply MvPolynomial.algHom_ext
    intro nm
    simp only [toSupported, AlgHom.toFun_eq_coe, Function.comp_apply, AlgHom.coe_comp, aeval_X]
  rw [‚Üê heq]
  apply GalgHom.isHomogeneous'_aeval (‚Ñï √ó M) (MvPolynomial (‚Ñï √ó M) R)
    (weightedHomogeneousSubmodule R Prod.fst) Prod.fst (AddMonoidHom.id ‚Ñï)
  ¬∑ intro nm
    simp only [mem_weightedHomogeneousSubmodule, AlgHom.toFun_eq_coe, Subalgebra.coe_val,
      Function.comp_apply, AddMonoidHom.id_apply]
    split_ifs with h
    ¬∑ apply isWeightedHomogeneous_X
    ¬∑ simp only [not_lt, le_zero_iff] at h
      rw [h, OneMemClass.coe_one]
      apply isWeightedHomogeneous_one

variable (M)

-- TODO: generalize
theorem eq_finsupp_single_of_degree_one [DecidableEq M]
    {d : ‚Ñï √ó M ‚Üí‚ÇÄ ‚Ñï} (hd : (Finsupp.weight Prod.fst) d = 1)
    (hsupp : ‚àÄ nm ‚àà d.support, 0 < nm.fst) :
  ‚àÉ m : M, Finsupp.single (1, m) 1 = d := by
  rw [Finsupp.weight_apply, Finsupp.sum] at hd
  have hnm : ‚àÉ nm : ‚Ñï √ó M, d nm ‚Ä¢ nm.fst = 1 := by
    by_contra h0
    rw [not_exists] at h0
    have hd0 : (d.support.sum fun a : ‚Ñï √ó M => d a ‚Ä¢ a.fst) = 0 := by
      rw [Finset.sum_eq_zero]
      intro nm hnm
      rw [‚Üê Nat.lt_one_iff]
      apply lt_of_le_of_ne _ (h0 nm)
      rw [‚Üê hd]
      exact Finset.single_le_sum (fun x _ => zero_le (d x ‚Ä¢ x.fst)) hnm
    rw [hd0] at hd
    exact zero_ne_one hd
  obtain ‚ü®nm, hnm‚ü© := hnm
  rw [‚Üê hnm] at hd
  simp only [Algebra.id.smul_eq_mul, mul_eq_one] at hnm
  use nm.snd
  ext ab
  rw [Finsupp.single_apply]
  split_ifs with hab <;> rw [‚Üê hnm.2, eq_comm, Prod.mk.eta] at hab
  ¬∑ rw [hab, hnm.1]
  ¬∑ rw [eq_comm]
    by_contra hab'
    have hne0 : d ab * ab.fst ‚â† 0 :=
      mul_ne_zero hab' (ne_of_gt (hsupp ab (Finsupp.mem_support_iff.mpr hab')))
    have hnm_mem : nm ‚àà d.support := by rw [Finsupp.mem_support_iff, hnm.1]; exact one_ne_zero
    simp only [Finset.sum_eq_sum_diff_singleton_add hnm_mem, add_left_eq_self,
      Algebra.id.smul_eq_mul, sum_eq_zero_iff, mem_sdiff,
      Finsupp.mem_support_iff, mem_singleton] at hd
    exact hne0 (hd ab ‚ü®hab', hab‚ü©)

end
